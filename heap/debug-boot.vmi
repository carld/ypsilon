((push.const . |.list?|)
 (push.gloc.of list?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 7171)
 (push.const . |.null?|)
 (push.gloc.of null?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 8195)
 (push.const . |.pair?|)
 (push.gloc.of pair?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 9219)
 (push.const . |.car|)
 (push.gloc.of car)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 10243)
 (push.const . |.cdr|)
 (push.gloc.of cdr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 11267)
 (push.const . |.caar|)
 (push.gloc.of caar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 12291)
 (push.const . |.cadr|)
 (push.gloc.of cadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 13315)
 (push.const . |.cdar|)
 (push.gloc.of cdar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 14339)
 (push.const . |.cddr|)
 (push.gloc.of cddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 15363)
 (push.const . |.caaar|)
 (push.gloc.of caaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 16387)
 (push.const . |.caadr|)
 (push.gloc.of caadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 17411)
 (push.const . |.cadar|)
 (push.gloc.of cadar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 18435)
 (push.const . |.caddr|)
 (push.gloc.of caddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 19459)
 (push.const . |.cdaar|)
 (push.gloc.of cdaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 20483)
 (push.const . |.cdadr|)
 (push.gloc.of cdadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 21507)
 (push.const . |.cddar|)
 (push.gloc.of cddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 22531)
 (push.const . |.cdddr|)
 (push.gloc.of cdddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 23555)
 (push.const . |.cdddar|)
 (push.gloc.of cdddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 24579)
 (push.const . |.caddar|)
 (push.gloc.of caddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 25603)
 (push.const . |.cddadr|)
 (push.gloc.of cddadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 26627)
 (push.const . |.cadadr|)
 (push.gloc.of cadadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 27651)
 (push.const . |.caaadr|)
 (push.gloc.of caaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 28675)
 (push.const . |.cddddr|)
 (push.gloc.of cddddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 29699)
 (push.const . |.cadddr|)
 (push.gloc.of cadddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 30723)
 (push.const . |.cdaadr|)
 (push.gloc.of cdaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 31747)
 (push.const . |.cdaddr|)
 (push.gloc.of cdaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 32771)
 (push.const . |.caaddr|)
 (push.gloc.of caaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 33795)
 (push.const . |.list|)
 (push.gloc.of list)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 34819)
 (push.const . |.cons*|)
 (push.gloc.of cons*)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 35843)
 (push.const . |.memq|)
 (push.gloc.of memq)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 36867)
 (push.const . |.append|)
 (push.gloc.of append)
 (ret.subr.gloc.of set-top-level-value! "./boot/first-load.scm" . 37891))

;
((close
   (0 1 . max)
   (iloc.0 . 0)
   (if.null?
     (push.const . max)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 8204))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 9242)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 9228)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 12316))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 13347)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 13333)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 14370)
           (>.iloc (0 . 0) "./boot/r6rs-aux.scm" . 14367)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 14387))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 15404)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 15394))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 16411)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 14357))
       (push.const . max)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 18515)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 18479)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 18453))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10270)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10296)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 10286)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10314)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 10252))
   (push.const . max)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 20554)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 20518)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 20492))
 (set.gloc.of max)
 (ret.const.unspec))
((close
   (0 1 . min)
   (iloc.0 . 0)
   (if.null?
     (push.const . min)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 25612))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 26650)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 26636)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 29724))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 30755)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 30741)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 31778)
           (<.iloc (0 . 0) "./boot/r6rs-aux.scm" . 31775)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 31795))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 32812)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 32802))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 33819)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 31765))
       (push.const . min)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 35923)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 35887)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 35861))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27678)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27704)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 27694)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27722)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 27660))
   (push.const . min)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 37962)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 37926)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 37900))
 (set.gloc.of min)
 (ret.const.unspec))
((close
   (2 0 . gcd2)
   (=n.iloc (0 . 1) 0 "./boot/r6rs-aux.scm" . 41993)
   (if.true
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 43026)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 43039))
       (ret.iloc 0 . 0))
     (push)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 43017))
   (touch.gloc.of gcd2)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of remainder 2 "./boot/r6rs-aux.scm" . 44049)
   (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 44041))
 (set.gloc.of gcd2)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 53261)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54292)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54302)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 54286))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 55315)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 55310))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 0)
   (touch.gloc.of |loop`7|)
   (call
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57377)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57387)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 57371))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57399)
   (push.cons)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 57359))
 (set.gloc.of |loop`7|)
 (close
   (0 1 . gcd)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 49173)
       (if.true.ret)
       (push.const . gcd)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 50223)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 50197))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 48133))
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 52229))
 (set.gloc.of gcd)
 (ret.const.unspec))
((close
   (2 0 . lcm2)
   (call
     (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 64529)
     (if.true.ret)
     (push.iloc.0 . 1)
     (push.const . 0)
     (ret.subr.gloc.of = "./boot/r6rs-aux.scm" . 64537))
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of exact? 1 "./boot/r6rs-aux.scm" . 65558)
       (if.false.ret)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of exact? "./boot/r6rs-aux.scm" . 65569))
     (if.true.ret.const . 0)
     (ret.const . 0.0))
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of gcd2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 66593))
   (push)
   (push.subr.gloc.of quotient 2 "./boot/r6rs-aux.scm" . 66581)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 66578)
   (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 66573))
 (set.gloc.of |lcm2`2|)
 (close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 73741)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of |lcm2`2|)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74772)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74782)
     (apply.gloc.of |lcm2`2| "./boot/r6rs-aux.scm" . 74766))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 75795)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 75790))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 1)
   (touch.gloc.of |loop`9|)
   (call
     (touch.gloc.of |lcm2`2|)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77857)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77867)
     (apply.gloc.of |lcm2`2| "./boot/r6rs-aux.scm" . 77851))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77879)
   (push.cons)
   (apply.gloc.of |loop`9| "./boot/r6rs-aux.scm" . 77839))
 (set.gloc.of |loop`9|)
 (close
   (0 1 . lcm)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 69653)
       (if.true.ret)
       (push.const . lcm)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 70703)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 70677))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 68613))
   (touch.gloc.of |loop`9|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`9| "./boot/r6rs-aux.scm" . 72709))
 (set.gloc.of lcm)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (=.iloc (0 . 1) "./boot/r6rs-aux.scm" . 92183)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.subr.gloc.of ceiling 1 "./boot/r6rs-aux.scm" . 94240)
   (extend . 1)
   (iloc.0 . 0)
   (<.iloc (1 . 1) "./boot/r6rs-aux.scm" . 95264)
   (if.true (ret.iloc 0 . 0))
   (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 97321)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . 1)
   (call
     (touch.gloc.of |loop`7|)
     (push.const . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98359)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98354)
     (push.const . 1)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98375)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98370)
     (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 98348))
   (push)
   (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98343)
   (ret.subr.gloc.of + "./boot/r6rs-aux.scm" . 98338))
 (set.gloc.of |loop`7|)
 (close
   (2 0 . rationalize)
   (push.iloc.0 . 0)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 81929)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 81973)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 82026)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 81939))
   (push.iloc.0 . 1)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 82953)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 82997)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 83050)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 82963))
   (push.iloc.0 . 1)
   (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 83980)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 85008)
     (if.true.ret.const . +nan.0)
     (ret.const . 0.0))
   (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 86028)
   (if.true.ret.const . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of negative? 1 "./boot/r6rs-aux.scm" . 87052)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 1 "./boot/r6rs-aux.scm" . 88092)
       (push.iloc.0 . 1)
       (apply.gloc.of rationalize "./boot/r6rs-aux.scm" . 88079))
     (push)
     (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 88076))
   (push.iloc.0 . 1)
   (push.subr.gloc.of abs 1 "./boot/r6rs-aux.scm" . 90133)
   (extend . 1)
   (touch.gloc.of |loop`7|)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 91169)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of + 2 "./boot/r6rs-aux.scm" . 91183)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 91150))
 (set.gloc.of rationalize)
 (ret.const.unspec))
((close
   (1 0 . list->string)
   (push.gloc.of string)
   (push.iloc.0 . 0)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 101393))
 (set.gloc.of list->string)
 (ret.const.unspec))
((close
   (1 0 . list->vector)
   (push.gloc.of vector)
   (push.iloc.0 . 0)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 104465))
 (set.gloc.of list->vector)
 (ret.const.unspec))
((close
   (1 0 . string->list)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 109579)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 111633)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-ref 2 "./boot/r6rs-aux.scm" . 111647)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 111627))
   (push.iloc.1 . 0)
   (push.subr.gloc.of string-length 1 "./boot/r6rs-aux.scm" . 108566)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 108563)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 108549))
 (set.gloc.of string->list)
 (ret.const.unspec))
((close
   (2 0 . map-n)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 128034)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 128022))
   (push)
   (call
     (touch.gloc.of |map-n`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 129058)
     (apply.gloc.of |map-n`2| "./boot/r6rs-aux.scm" . 129046))
   (ret.cons "./boot/r6rs-aux.scm" . 128016))
 (set.gloc.of |map-n`2|)
 (close
   (2 0 . map-1)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 120860)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 120854))
   (push)
   (call
     (touch.gloc.of |map-1`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 121890)
     (apply.gloc.of |map-1`2| "./boot/r6rs-aux.scm" . 121878))
   (ret.cons "./boot/r6rs-aux.scm" . 120848))
 (set.gloc.of |map-1`2|)
 (close
   (2 1 . map)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 132109)
     (if.true
       (touch.gloc.of |map-1`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |map-1`2| "./boot/r6rs-aux.scm" . 133133))
     (push.const . map)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 134183))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 134234)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 134157))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 135184))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |map-n`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |map-n`2| "./boot/r6rs-aux.scm" . 136225))
   (push.const . map)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 138318)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 138256))
 (set.gloc.of map)
 (ret.const.unspec))
((close
   (2 0 . for-each-n)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 151597)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 151585))
   (touch.gloc.of |for-each-n`2|)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 152626)
   (apply.gloc.of |for-each-n`2| "./boot/r6rs-aux.scm" . 152609))
 (set.gloc.of |for-each-n`2|)
 (close
   (2 0 . for-each-1)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 146470)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 146464))
   (touch.gloc.of |for-each-1`2|)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 147505)
   (apply.gloc.of |for-each-1`2| "./boot/r6rs-aux.scm" . 147488))
 (set.gloc.of |for-each-1`2|)
 (close
   (2 1 . for-each)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 154637)
     (if.true
       (touch.gloc.of |for-each-1`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |for-each-1`2| "./boot/r6rs-aux.scm" . 155661))
     (push.const . for-each)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 156716))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 156767)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 156685))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 157712))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |for-each-n`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |for-each-n`2| "./boot/r6rs-aux.scm" . 158753))
   (push.const . for-each)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 160851)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 160784))
 (set.gloc.of for-each)
 (ret.const.unspec))
((close
   (2 1 . vector-map)
   (call
     (push.gloc.of map)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 165910)
     (call
       (push.gloc.of vector->list)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/r6rs-aux.scm" . 166925))
     (push)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 165894))
   (push)
   (apply.gloc.of list->vector "./boot/r6rs-aux.scm" . 164869))
 (set.gloc.of vector-map)
 (ret.const.unspec))
((close
   (2 1 . vector-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 171034)
   (call
     (push.gloc.of vector->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 172044))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 171013))
 (set.gloc.of vector-for-each)
 (ret.const.unspec))
((close
   (2 1 . string-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/r6rs-aux.scm" . 176154))
   (push)
   (call
     (push.gloc.of string->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 177164))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 176133))
 (set.gloc.of string-for-each)
 (ret.const.unspec))
((close
   (2 0 . call-with-values)
   (touch.gloc.of apply-values)
   (push.iloc.0 . 1)
   (call (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 181276))
   (push)
   (apply.gloc.of apply-values "./boot/r6rs-aux.scm" . 181253))
 (set.gloc.of call-with-values)
 (ret.const.unspec))
((close
   (2 0 . mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 185357)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 185354)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 185349))
 (set.gloc.of mod)
 (ret.const.unspec))
((close
   (2 0 . div-and-mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 189454)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 190486)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 190481)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 190471))
 (set.gloc.of div-and-mod)
 (ret.const.unspec))
((close
   (2 0 . mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 194573)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 194570)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 194565))
 (set.gloc.of mod0)
 (ret.const.unspec))
((close
   (2 0 . div0-and-mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 198671)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 199703)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 199698)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 199687))
 (set.gloc.of div0-and-mod0)
 (ret.const.unspec))

;
((close
   (1 0 . top-level-unbound?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-bound? 1 "./boot/common.scm" . 7178)
   (ret.subr.gloc.of not "./boot/common.scm" . 7173))
 (set.gloc.of top-level-unbound?)
 (ret.const.unspec))
((close
   (3 0 . acons)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (ret.cons "./boot/common.scm" . 11269))
 (set.gloc.of acons)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 16413)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 16423)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 16407))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . count-pair)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 15365))
 (set.gloc.of count-pair)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/common.scm" . 22547)
   (if.not.pair?.ret.const . #f)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 23573)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (touch.gloc.of |loop`5|)
   (push.cddr.iloc (0 . 0) "./boot/common.scm" . 24598)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 24610)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 24592))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . circular-list?)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 20485))
 (set.gloc.of circular-list?)
 (ret.const.unspec))
((close
   (1 0 . circular-tree?)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (2 0 . loop)
       (call
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/common.scm" . 30743)
         (if.false.ret)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/common.scm" . 31767))
       (if.true.ret)
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 33817)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/common.scm" . 35877)
           (push.iloc.0 . 0)
           (apply.iloc (2 . 0) "./boot/common.scm" . 35871))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/common.scm" . 36901)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/common.scm" . 36895))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/common.scm" . 37913)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 38937)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 41005))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/common.scm" . 41024)
         (apply.gloc.of any1 "./boot/common.scm" . 40987))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/common.scm" . 42009)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 43033)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 45101))
         (push.iloc.1 . 0)
         (push.subr.gloc.of tuple->list 1 "./boot/common.scm" . 45120)
         (apply.gloc.of any1 "./boot/common.scm" . 45083))
       (ret.const . #f))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc (0 . 0) "./boot/common.scm" . 29708))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of circular-tree?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 53265)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 53275)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 53259))
   (call (iloc.0 . 0) (if.not.null?.ret.const . #f) (ret.iloc 0 . 1))
   (if.true.ret)
   (ret.const . -1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . safe-length)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 51205))
 (set.gloc.of safe-length)
 (ret.const.unspec))
((close
   (2 0 . split-at)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-head 2 "./boot/common.scm" . 58383)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-tail 2 "./boot/common.scm" . 58401)
   (ret.subr.gloc.of values "./boot/common.scm" . 58375))
 (set.gloc.of split-at)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/common.scm" . 65576)
   (if.not.symbol?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 66592)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 66602)
   (subr.gloc.of memq 2 "./boot/common.scm" . 66586)
   (if.true.ret)
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 67616)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 67610))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . unique-id-list?)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 62474)
   (if.false.ret)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 63503))
   (push)
   (ret.subr.gloc.of not "./boot/common.scm" . 62469))
 (set.gloc.of unique-id-list?)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 74779)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 74789)
   (subr.gloc.of memq 2 "./boot/common.scm" . 74773)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/common.scm" . 75797))
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 76827)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 76821))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . find-duplicates)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 71690)
   (if.false.ret)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 72714))
 (set.gloc.of find-duplicates)
 (ret.const.unspec))
((close
   (2 0 . every1)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (2 0 . loop)
     (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "./boot/common.scm" . 82960))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 85018)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 85029)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 85012))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 81946)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 81963)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 81929))
 (set.gloc.of every1)
 (ret.const.unspec))
((close
   (3 0 . every2)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (iloc.0 . 2)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (4 0 . loop)
     (call (push.iloc.0 . 0) (push.iloc.0 . 2) (apply.iloc (2 . 0) "./boot/common.scm" . 92176))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (iloc.0 . 3)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 95258)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 95270)
     (push.car.iloc (0 . 3) "./boot/common.scm" . 95282)
     (push.cdr.iloc (0 . 3) "./boot/common.scm" . 95294)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 95252))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 91163)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 91182)
   (push.car.iloc (1 . 2) "./boot/common.scm" . 91201)
   (push.cdr.iloc (1 . 2) "./boot/common.scm" . 91220)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 91145))
 (set.gloc.of every2)
 (ret.const.unspec))
((close
   (2 0 . any1)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 100372)
     (apply.iloc (0 . 0) "./boot/common.scm" . 100366))
   (if.true.ret)
   (touch.gloc.of any1)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 100394)
   (apply.gloc.of any1 "./boot/common.scm" . 100383))
 (set.gloc.of any1)
 (ret.const.unspec))
((close
   (3 0 . any2)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (iloc.0 . 2)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 106516)
     (push.car.iloc (0 . 2) "./boot/common.scm" . 106527)
     (apply.iloc (0 . 0) "./boot/common.scm" . 106510))
   (if.true.ret)
   (touch.gloc.of any2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 107545)
   (push.cdr.iloc (0 . 2) "./boot/common.scm" . 107556)
   (apply.gloc.of any2 "./boot/common.scm" . 107534))
 (set.gloc.of any2)
 (ret.const.unspec))
((close
   (2 0 . filter)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 113684)
       (apply.iloc (2 . 0) "./boot/common.scm" . 113678))
     (if.true
       (push.car.iloc (0 . 0) "./boot/common.scm" . 113701)
       (call
         (push.cdr.iloc (0 . 0) "./boot/common.scm" . 113717)
         (apply.iloc+ (1 . 0) "./boot/common.scm" . 113711))
       (ret.cons "./boot/common.scm" . 113695))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 114713)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 114707))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 111621))
 (set.gloc.of filter)
 (ret.const.unspec))
((close
   (2 0 . partition)
   (extend.enclose+
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 119842)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 119857)
       (ret.subr.gloc.of values "./boot/common.scm" . 119834))
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 120852)
       (apply.iloc (2 . 0) "./boot/common.scm" . 120846))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/common.scm" . 120869)
       (push.car.iloc (0 . 0) "./boot/common.scm" . 120885)
       (iloc.0 . 1)
       (push.cons)
       (push.iloc.0 . 2)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 120863))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 121881)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/common.scm" . 121902)
     (iloc.0 . 2)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 121875))
   (push.iloc.1 . 1)
   (push.const)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 118789))
 (set.gloc.of partition)
 (ret.const.unspec))
((close
   (2 0 . split->list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of make-string-input-port 1 "./boot/common.scm" . 129043)
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop1)
     (extend.enclose+
       (1 0 . loop2)
       (push.iloc.0 . 0)
       (subr.gloc.of eof-object? 1 "./boot/common.scm" . 133142)
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 134175)
         (extend . 1)
         (push.iloc.0 . 0)
         (push.const . "")
         (subr.gloc.of string=? 2 "./boot/common.scm" . 135196)
         (if.true (push.iloc 3 . 0) (ret.subr.gloc.of reverse "./boot/common.scm" . 136220))
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (push.cons)
         (ret.subr.gloc.of reverse "./boot/common.scm" . 137244))
       (call (push.iloc.0 . 0) (apply.iloc (5 . 1) "./boot/common.scm" . 138262))
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 139299)
         (iloc 2 . 0)
         (push.cons)
         (apply.iloc+ (3 . 0) "./boot/common.scm" . 139286))
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of put-char 2 "./boot/common.scm" . 141334)
       (push.iloc 4 . 0)
       (push.subr.gloc.of get-char 1 "./boot/common.scm" . 142365)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 142358))
     (push.iloc 3 . 0)
     (push.subr.gloc.of get-char 1 "./boot/common.scm" . 132124)
     (apply.iloc+ (0 . 0) "./boot/common.scm" . 132109))
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 131083))
 (set.gloc.of |split->list`2|)
 (close
   (2 0 . string-split)
   (push.iloc.0 . 1)
   (subr.gloc.of char? 1 "./boot/common.scm" . 144396)
   (if.true
     (touch.gloc.of |split->list`2|)
     (push.iloc.0 . 0)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of char=? "./boot/common.scm" . 145449))
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 145420))
   (push.iloc.0 . 1)
   (subr.gloc.of string? 1 "./boot/common.scm" . 146444)
   (if.true
     (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/common.scm" . 147479))
     (push)
     (extend . 1)
     (touch.gloc.of |split->list`2|)
     (push.iloc.1 . 0)
     (push.close
       (1 0)
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (ret.subr.gloc.of char=? "./boot/common.scm" . 148541))
       (push.iloc.1 . 0)
       (apply.gloc.of any1 "./boot/common.scm" . 148523))
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 148494))
   (push.iloc.0 . 1)
   (subr.gloc.of procedure? 1 "./boot/common.scm" . 149516)
   (if.true
     (touch.gloc.of |split->list`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 150540))
   (ret.const.unspec))
 (set.gloc.of string-split)
 (ret.const.unspec))
((close
   (2 1 . wrong-type-argument-message)
   (iloc.0 . 2)
   (if.null?
     (push.const . "expected ~a, but got ~a")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of format "./boot/common.scm" . 155657))
   (push.const . "expected ~a, but got ~a, as argument ~a")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.car.iloc (0 . 2) "./boot/common.scm" . 156742)
   (ret.subr.gloc.of format "./boot/common.scm" . 156681))
 (set.gloc.of wrong-type-argument-message)
 (ret.const.unspec))

;
((close
   (1 1 . make-parameter)
   (call
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of parameter-proc-0)
       (subr.gloc.of gensym 0)
       (push)
       (apply.gloc.of parameter-proc-0 "./boot/parameter.scm" . 8218))
     (touch.gloc.of parameter-proc-1)
     (subr.gloc.of gensym 0)
     (push)
     (push.car.iloc (0 . 1) "./boot/parameter.scm" . 9269)
     (apply.gloc.of parameter-proc-1 "./boot/parameter.scm" . 9242))
   (push)
   (extend . 1)
   (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/parameter.scm" . 10254))
   (ret.iloc 0 . 0))
 (set.gloc.of make-parameter)
 (ret.const.unspec))
((close
   (1 0 . parameter-proc-0)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 16395))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (0 . 0) "./boot/parameter.scm" . 17474)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 17419)))
 (set.gloc.of parameter-proc-0)
 (ret.const.unspec))
((close
   (2 0 . parameter-proc-1)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 23563))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (call
       (push.car.iloc (0 . 0) "./boot/parameter.scm" . 24648)
       (apply.iloc (1 . 1) "./boot/parameter.scm" . 24642))
     (push)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 24587)))
 (set.gloc.of parameter-proc-1)
 (ret.const.unspec))

;
((call (push.const . "") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 5152))
 (set.gloc.of current-library-prefix)
 (ret.const.unspec))
((call (push.const . ".") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 6175))
 (set.gloc.of current-library-infix)
 (ret.const.unspec))
((call (push.const . "'") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 7200))
 (set.gloc.of current-library-suffix)
 (ret.const.unspec))
((call (push.const . ".") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 8226))
 (set.gloc.of current-primitive-prefix)
 (ret.const.unspec))
((call (push.const . "`") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 9250))
 (set.gloc.of current-rename-delimiter)
 (ret.const.unspec))
((call (push.const . 5) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 10269))
 (set.gloc.of expansion-backtrace)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 11295))
 (set.gloc.of expansion-trace-stack)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 12319))
 (set.gloc.of expansion-trace-level)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 13351))
 (set.gloc.of current-immutable-identifiers)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 14368))
 (set.gloc.of current-expansion-mode)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 15399))
 (set.gloc.of current-expansion-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 16418))
 (set.gloc.of current-macro-expression)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 17449))
 (set.gloc.of current-transformer-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 18465))
 (set.gloc.of unexpect-top-level-form)
 (ret.const.unspec))
((close (3 0) (ret.iloc 0 . 0))
 (set.gloc.of |.fn1.1`1|)
 (call (push.gloc.of |.fn1.1`1|) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 19494))
 (set.gloc.of current-after-expansion-hook)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 20513))
 (set.gloc.of current-temporary-count)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 21534))
 (set.gloc.of current-rename-count)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 22562))
 (set.gloc.of current-closure-comments)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 23588))
 (set.gloc.of current-top-level-exterior)
 (ret.const.unspec))
((close
   (4 0)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/initial.scm" . 27658)
     (if.false.ret)
     (push.iloc.0 . 1)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 28682))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (call
     (push.iloc.0 . 0)
     (const . syntax)
     (if.eq?
       (touch.gloc.of make-macro)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of make-macro "./boot/macro/initial.scm" . 33821))
     (push.iloc.0 . 0)
     (const . variable)
     (if.eq?
       (push.iloc.0 . 2)
       (subr.gloc.of procedure? 1 "./boot/macro/initial.scm" . 35876)
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 36900))
       (call
         (touch.gloc.of variable-transformer-token?)
         (push.iloc.0 . 2)
         (apply.gloc.of variable-transformer-token? "./boot/macro/initial.scm" . 37924))
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/initial.scm" . 38969)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 38948))
       (push.const
         .
         "internal error in .set-top-level-macro!: bad transformer type:~s keyword:~s datum:~s")
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 40996))
     (ret.const.unspec))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 26627))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.set-top-level-macro!|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 26627))
((close
   (1 0 . core-primitive-name)
   (push.const . "~a~a")
   (call
     (touch.gloc.of current-primitive-prefix)
     (apply.gloc.of current-primitive-prefix "./boot/macro/initial.scm" . 45092))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 3 "./boot/macro/initial.scm" . 45077)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 45061))
 (set.gloc.of core-primitive-name)
 (ret.const.unspec))
((close
   (2 0 . generate-global-id)
   (push.const . "~a~a~a~a")
   (call
     (touch.gloc.of current-library-prefix)
     (apply.gloc.of current-library-prefix "./boot/macro/initial.scm" . 49192))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-library-suffix)
     (apply.gloc.of current-library-suffix "./boot/macro/initial.scm" . 49228))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 49173)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 49157))
 (set.gloc.of generate-global-id)
 (ret.const.unspec))
((close
   (0 0 . generate-temporary-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 53266))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 54304)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 54279))
   (push.const . ".L~a")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/initial.scm" . 55319)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 55303))
 (set.gloc.of generate-temporary-symbol)
 (ret.const.unspec))
((close
   (1 0 . generate-local-macro-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 59410))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 60448)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 60423))
   (push.const . ".local-macro-~a.~a~a~a")
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 61505))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 61532))
   (push)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 61463)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 61447))
 (set.gloc.of generate-local-macro-symbol)
 (ret.const.unspec))
((close
   (0 0 . fresh-rename-count)
   (call
     (touch.gloc.of current-rename-count)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 65566))
     (push)
     (push.const . 1)
     (push.subr.gloc.of + 2 "./boot/macro/initial.scm" . 65563)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 65541))
   (touch.gloc.of current-rename-count)
   (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 66565))
 (set.gloc.of fresh-rename-count)
 (ret.const.unspec))
((close
   (2 0 . rename-id)
   (push.const . "~a~a~a")
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 70697))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 4 "./boot/macro/initial.scm" . 70677)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 70661))
 (set.gloc.of rename-id)
 (ret.const.unspec))
((close
   (1 0 . renamed-id?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of symbol-contains)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 75806))
   (push)
   (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 75786))
 (set.gloc.of renamed-id?)
 (ret.const.unspec))
((close
   (1 0 . original-id)
   (call
     (touch.gloc.of symbol-contains)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of current-rename-delimiter)
       (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 79904))
     (push)
     (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 79884))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 80953)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of substring 3 "./boot/macro/initial.scm" . 80942)
     (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 80926))
   (ret.iloc 1 . 0))
 (set.gloc.of original-id)
 (ret.const.unspec))
((close
   (1 0 . strip-rename-suffix)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 87082)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 87061))
     (push)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 88106)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 88085))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/initial.scm" . 89121)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/initial.scm" . 89139)
       (ret.eq? "./boot/macro/initial.scm" . 89132))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/initial.scm" . 90138))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of original-id)
     (push.iloc.0 . 0)
     (apply.gloc.of original-id "./boot/macro/initial.scm" . 91162))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/initial.scm" . 92172)
   (if.true
     (call
       (push.gloc.of strip-rename-suffix)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/initial.scm" . 92225)
       (apply.gloc.of map "./boot/macro/initial.scm" . 92200))
     (push)
     (apply.gloc.of list->vector "./boot/macro/initial.scm" . 92186))
   (ret.iloc 0 . 0))
 (set.gloc.of strip-rename-suffix)
 (ret.const.unspec))
((close
   (1 0 . retrieve-rename-suffix)
   (call
     (touch.gloc.of symbol-contains)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of current-rename-delimiter)
       (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 97312))
     (push)
     (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 97292))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 99357)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/macro/initial.scm" . 100392)
     (ret.subr.gloc.of substring "./boot/macro/initial.scm" . 100371))
   (ret.const . ""))
 (set.gloc.of retrieve-rename-suffix)
 (ret.const.unspec))
((close
   (2 0 . set-closure-comment!)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 105482))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 106527))
   (push)
   (push.iloc.0 . 0)
   (push.const . heap)
   (iloc.0 . 1)
   (push.cons)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 106506))
 (set.gloc.of set-closure-comment!)
 (ret.const.unspec))
((close
   (2 1 . annotate-closure)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 110602))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 111653))
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 111633)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (iloc.1 . 2)
     (if.null?
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 114735))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 114714))
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 115759))
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (1 . 2) "./boot/macro/initial.scm" . 115797)
     (cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 115808)
     (push.cons)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 115738))
   (ret.const.unspec))
 (set.gloc.of annotate-closure)
 (ret.const.unspec))
((close
   (1 0 . annotated?)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 119818)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 120842)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of annotated?)
 (ret.const.unspec))
((close
   (1 0 . get-annotation)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 126986)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 128010))
 (set.gloc.of get-annotation)
 (ret.const.unspec))
((close
   (2 0 . put-annotation)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 133130)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 134154))
   (ret.iloc 0 . 0))
 (set.gloc.of put-annotation)
 (ret.const.unspec))
((close
   (2 0 . put-note!)
   (iloc.0 . 1)
   (if.false.ret)
   (extend.enclose
     (1 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/initial.scm" . 144405)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 145433)
     (if.true.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (subr.gloc.of core-hashtable-set! 3 "./boot/macro/initial.scm" . 147483)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/macro/initial.scm" . 148507))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/initial.scm" . 143374))
 (set.gloc.of |put-note!`2|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 154644)
   (if.true.ret)
   (call
     (touch.gloc.of |loop`15|)
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 155674)
     (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 155668))
   (if.true.ret)
   (touch.gloc.of |loop`15|)
   (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 156698)
   (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 156692))
 (set.gloc.of |loop`15|)
 (close
   (1 0 . get-note)
   (touch.gloc.of |loop`15|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 152585))
 (set.gloc.of |get-note`2|)
 (close
   (2 0 . annotate)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #f)
     (call
       (call
         (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 162840)
         (if.false.ret)
         (touch.gloc.of |get-note`2|)
         (push.iloc.0 . 1)
         (apply.gloc.of |get-note`2| "./boot/macro/initial.scm" . 162866))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of |put-note!`2|)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |put-note!`2| "./boot/macro/initial.scm" . 163874))
       (ret.const.unspec))
     (call
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 164888))
       (if.false.ret)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 164935))
       (push)
       (push.iloc.0 . 1)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 164915))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 165943))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 165922))
     (ret.const.unspec))
   (ret.iloc 0 . 0))
 (set.gloc.of annotate)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 174095)
     (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 174104))
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 175130)
     (call
       (touch.gloc.of |loop`5|)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 175146)
       (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 175156)
       (apply.gloc.of |loop`5| "./boot/macro/initial.scm" . 175140))
     (ret.cons "./boot/macro/initial.scm" . 175124))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`5|)
 (close
   (2 0 . abbreviated-take)
   (touch.gloc.of annotate)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`5| "./boot/macro/initial.scm" . 172038))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 172038))
 (set.gloc.of abbreviated-take)
 (ret.const.unspec))
((close
   (3 0 . abbreviated-take-form)
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 183315)
           (if.true.ret)
           (push.iloc.0 . 2)
           (push.const . 0)
           (ret.subr.gloc.of <= "./boot/macro/initial.scm" . 183325))
         (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 183336))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 184352)
           (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 184362)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 184346))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 184381)
           (push.iloc 2 . 1)
           (push.n+.iloc (0 . 2) -1 "./boot/macro/initial.scm" . 184396)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 184375))
         (ret.cons "./boot/macro/initial.scm" . 184340))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (apply.iloc+ (0 . 0) "./boot/macro/initial.scm" . 181254))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 179203))
 (set.gloc.of abbreviated-take-form)
 (ret.const.unspec))

;
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 9234)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 9259)
       (apply.gloc.of formals->list "./boot/macro/expand.scm" . 9244))
     (ret.cons "./boot/macro/expand.scm" . 9228))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/macro/expand.scm" . 11276))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . collect-lambda-formals)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/macro/expand.scm" . 15377))
   (push)
   (extend . 1)
   (call
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/expand.scm" . 16395))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 17437)
     (push.const . "malformed formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 17419))
   (call
     (call
       (touch.gloc.of unique-id-list?)
       (push.iloc.0 . 0)
       (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 18443))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 19485)
     (push.const . "duplicate formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 19467))
   (ret.iloc 0 . 0))
 (set.gloc.of collect-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . rename-lambda-formals)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 26653)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 26647)
     (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 26642)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 27689)
       (push.iloc.0 . 1)
       (apply.gloc.of rename-lambda-formals "./boot/macro/expand.scm" . 27666))
     (ret.cons "./boot/macro/expand.scm" . 26636))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 29713)
   (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 29708))
 (set.gloc.of rename-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . check-let*-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 33801)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 34843)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 34825))
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.0 . 0)
         (apply.gloc.of safe-length "./boot/macro/expand.scm" . 36893))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/expand.scm" . 36890)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 36927)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 36918))
     (if.true.ret)
     (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 37927)
     (push.const . "expected each binding consist of symbol and expression")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 37909))
   (push.iloc.0 . 1)
   (apply.gloc.of for-each "./boot/macro/expand.scm" . 35845))
 (set.gloc.of check-let*-bindings)
 (ret.const.unspec))
((close
   (2 0 . check-let-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 43017)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 44059)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 44041))
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.close
         (1 0)
         (call
           (call
             (touch.gloc.of safe-length)
             (push.iloc.0 . 0)
             (apply.gloc.of safe-length "./boot/macro/expand.scm" . 47133))
           (push)
           (push.const . 2)
           (subr.gloc.of = 2 "./boot/macro/expand.scm" . 47130)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 47167)
           (if.not.symbol?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 47182))
         (if.true.ret)
         (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 48167)
         (push.const . "expected each binding consist of symbol and expression")
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 48149))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 46090))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 45065))
   (if.true.ret)
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 50203)
   (push.const . "duplicate bindings")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 50185))
 (set.gloc.of check-let-bindings)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`7|)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 59416)
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 60446)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 60440))
     (push)
     (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 59410))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 62489)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 63518))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of |filter-unique-ids`2|)
   (call
     (touch.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`15| "./boot/macro/expand.scm" . 69642))
   (push)
   (apply.gloc.of |filter-unique-ids`2| "./boot/macro/expand.scm" . 57353))
 (set.gloc.of |collect-ids`2|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 72738)
     (push.const . quote)
     (push.subr.gloc.of eq? 2 "./boot/macro/expand.scm" . 72733)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 72728))
   (if.true
     (push.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 73747))
   (ret.const))
 (set.gloc.of |loop`15|)
 (close
   (1 0 . filter-unique-ids)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 57353))
 (set.gloc.of |filter-unique-ids`2|)
 (close
   (2 0 . check-internal-def-contract-violation)
   (call
     (touch.gloc.of |collect-ids`2|)
     (push.iloc.0 . 1)
     (apply.gloc.of |collect-ids`2| "./boot/macro/expand.scm" . 76816))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 77855)
     (if.false.ret)
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 77831))
 (set.gloc.of check-internal-def-contract-violation)
 (ret.const.unspec))
((close
   (1 0 . filter-unique-ids)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 85001))
 (set.gloc.of |filter-unique-ids`2|)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`7|)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 87064)
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 88094)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 88088))
     (push)
     (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 87058))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 90137)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 91166))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of |filter-unique-ids`2|)
   (call
     (touch.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`15| "./boot/macro/expand.scm" . 97290))
   (push)
   (apply.gloc.of |filter-unique-ids`2| "./boot/macro/expand.scm" . 83975))
 (set.gloc.of |collect-ids`2|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 100387)
     (push.const lambda quote)
     (push.subr.gloc.of memq 2 "./boot/macro/expand.scm" . 100381)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 100376))
   (if.true
     (push.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 101395))
   (ret.const))
 (set.gloc.of |loop`15|)
 (close
   (2 0 . check-rec-contract-violation)
   (call
     (touch.gloc.of |collect-ids`2|)
     (push.iloc.0 . 1)
     (apply.gloc.of |collect-ids`2| "./boot/macro/expand.scm" . 104464))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of memq "./boot/macro/expand.scm" . 105498))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 105479))
 (set.gloc.of check-rec-contract-violation)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of check-rec-contract-violation)
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 111667)
     (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 111632))
   (if.true.ret)
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 112662)
   (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 112673)
   (apply.gloc.of |loop`5| "./boot/macro/expand.scm" . 112656))
 (set.gloc.of |loop`5|)
 (close
   (2 0 . check-rec*-contract-violation)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of |loop`5| "./boot/macro/expand.scm" . 109573))
 (set.gloc.of check-rec*-contract-violation)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/expand.scm" . 124935))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . rewrite-letrec*-bindings)
   (push.close
     (0 0)
     (touch.gloc.of partition)
     (push.close
       (1 0)
       (cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 118835)
       (if.not.pair?.ret.const . #t)
       (call
         (touch.gloc.of denote-quote?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 119866)
         (apply.gloc.of denote-quote? "./boot/macro/expand.scm" . 119847))
       (if.true.ret)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 120891)
         (apply.gloc.of denote-lambda? "./boot/macro/expand.scm" . 120871))
       (if.true
         (call
           (touch.gloc.of set-closure-comment!)
           (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 121924)
           (call
             (touch.gloc.of original-id)
             (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 121952)
             (apply.gloc.of original-id "./boot/macro/expand.scm" . 121939))
           (push)
           (apply.gloc.of set-closure-comment! "./boot/macro/expand.scm" . 121902))
         (ret.const . #t))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (apply.gloc.of partition "./boot/macro/expand.scm" . 116741))
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 115715))
 (set.gloc.of rewrite-letrec*-bindings)
 (ret.const.unspec))
((close
   (2 0 . flatten-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 132117)
     (if.not.pair?.ret.const . #f)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 133145)
       (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 133138)
       (if.true.ret)
       (push.const . #f)
       (push.const . "expression is not a proper list")
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 134217)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 134162))
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 135201)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 135182))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 140303))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 141333)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 142363)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 142357))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 141327))
       (iloc.0 . 1)
       (if.null? (ret.iloc 0 . 0))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of append "./boot/macro/expand.scm" . 146454))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 138246))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 130053))
 (set.gloc.of flatten-begin)
 (ret.const.unspec))
((close
   (2 0 . flatten-top-level-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 154645)
     (if.not.pair?.ret.const . #f)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 155673)
       (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 155666)
       (if.true.ret)
       (push.const . #f)
       (push.const . "expression is not a proper list")
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 156745)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 156690))
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 157729)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 157710))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 162831))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 163861)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 164891)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 164885))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 163855))
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 166933)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 167963)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 167957))
       (ret.cons "./boot/macro/expand.scm" . 166927))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 160774))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 152581))
 (set.gloc.of flatten-top-level-begin)
 (ret.const.unspec))
((close
   (3 0 . compile-macro)
   (extend.unbound . 2)
   (push.close+
     (2 0 . compile-transformer)
     (push.const . |.transformer-thunk|)
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (call
             (touch.gloc.of make-out-of-context)
             (push.const . #f)
             (apply.gloc.of make-out-of-context "./boot/macro/expand.scm" . 177207))
           (push)
           (extend . 2)
           (call
             (push.close
               (1 0)
               (car.iloc (0 . 0) "./boot/macro/expand.scm" . 179244)
               (if.not.symbol?.ret.const . #f)
               (call
                 (touch.gloc.of renamed-id?)
                 (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 180272)
                 (apply.gloc.of renamed-id? "./boot/macro/expand.scm" . 180259))
               (if.false.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 181310)
               (push.const . #f)
               (subr.gloc.of core-hashtable-ref 3 "./boot/macro/expand.scm" . 181287)
               (if.true.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 182335)
               (push.iloc.1 . 1)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/expand.scm" . 182311))
             (push.iloc.1 . 1)
             (apply.gloc.of for-each "./boot/macro/expand.scm" . 178194))
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable->alist "./boot/macro/expand.scm" . 184338))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 185414))
       (push)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 185389))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 185361)
     (extend . 1)
     (call
       (touch.gloc.of interpret-coreform)
       (push.iloc.0 . 0)
       (apply.gloc.of interpret-coreform "./boot/macro/expand.scm" . 186393))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 187414)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 187432))
     (call
       (touch.gloc.of variable-transformer-token?)
       (push.iloc.0 . 0)
       (apply.gloc.of variable-transformer-token? "./boot/macro/expand.scm" . 188438))
     (if.true
       (call
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 0)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/expand.scm" . 189491)
         (push.iloc 2 . 1)
         (apply.gloc.of make-macro-variable "./boot/macro/expand.scm" . 189470))
       (push)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 189462))
     (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 191528)
     (push.const . "invalid transformer expression")
     (push.iloc 4 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 191510))
   (push.close
     (1 0 . syntax-rules?)
     (touch.gloc.of denote-syntax-rules?)
     (push.iloc 2 . 2)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-syntax-rules? "./boot/macro/expand.scm" . 195593))
   (enclose . 2)
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (if.not.null?.ret.const . #f)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 174085))
   (if.true
     (push.const . syntax-rules)
     (push.const . "expected literals and rules")
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 174085)
     (if.false.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 174085))
   (if.true
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (push.cadr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (extend . 2)
     (call
       (call
         (push.iloc.0 . 1)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 174085)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 1)
         (apply.gloc.of every1 "./boot/macro/expand.scm" . 174085))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "invalid literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 1)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 174085))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "duplicate literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call
       (push.const . _)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 174085)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "_ in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call
       (push.const . ...)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 174085)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "... in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 174085)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 174085)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 174085)
           (ret.null? "./boot/macro/expand.scm" . 174085))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/expand.scm" . 174085)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 174085))
         (if.true.ret.const . #t)
         (iloc.0 . 0)
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected identifer for first subform of pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 174085)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 174085)
           (ret.null? "./boot/macro/expand.scm" . 174085))
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected list for pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
         (push.const . syntax-rules)
         (push.const . "expected (pattern template) for each rule")
         (push.iloc 4 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/expand.scm" . 174085))
     (touch.gloc.of compile-syntax-rules)
     (push.iloc 2 . 1)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 2 . 2)
     (apply.gloc.of compile-syntax-rules "./boot/macro/expand.scm" . 174085))
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 174085))
 (set.gloc.of compile-macro)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 235575))
   (ret.cons "./boot/macro/expand.scm" . 235563))
 (set.gloc.of |.fn1.1`1|)
 (close
   (3 0 . expand-let-syntax-bindings)
   (call
     (push.gloc.of car)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 227345))
   (push)
   (extend . 1)
   (touch.gloc.of extend-env)
   (call
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 231478))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 232486))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 233515))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 230427))
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 228370))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 230408))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 235538))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 236562))
     (push)
     (ret.subr.gloc.of append "./boot/macro/expand.scm" . 235530))
   (push)
   (push.iloc.1 . 2)
   (apply.gloc.of extend-env "./boot/macro/expand.scm" . 227333))
 (set.gloc.of expand-let-syntax-bindings)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 250962))
   (ret.cons "./boot/macro/expand.scm" . 250942))
 (set.gloc.of |.fn1.1`1|)
 (close
   (3 0 . expand-letrec-syntax-bindings)
   (extend.enclose
     (1 0 . undefined-macro)
     (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 244763)
     (push.const . "attempt to reference uninitialized syntactic keyword")
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 244745))
   (call
     (push.gloc.of car)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 246801))
   (push)
   (call
     (push.gloc.of cadr)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 247826))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (touch.gloc.of make-macro)
       (push.iloc 2 . 0)
       (push.const)
       (apply.gloc.of make-macro "./boot/macro/expand.scm" . 248881))
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 248861))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of extend-env)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 250909))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 251933))
     (push)
     (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 250901)
     (push.iloc 3 . 2)
     (apply.gloc.of extend-env "./boot/macro/expand.scm" . 249876))
   (push)
   (extend . 1)
   (call
     (push.close
       (2 0)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 259125))
       (push)
       (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 259146)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 259115))
     (push.iloc 2 . 0)
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 6 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 255033))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 256041))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 257070))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 253982))
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 253963))
     (push)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 259085))
   (ret.iloc 0 . 0))
 (set.gloc.of expand-letrec-syntax-bindings)
 (ret.const.unspec))
((close
   (3 0 . expand-macro-use)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 265221))
   (call
     (touch.gloc.of current-macro-expression)
     (push.iloc.0 . 0)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 266245))
   (push.const . #f)
   (push.const . #f)
   (push.cddr.iloc (0 . 2) "./boot/macro/expand.scm" . 267353)
   (extend . 3)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 268295))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-transformer-environment)
       (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 268295))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 268295))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 2)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 268295))
   (push.close
     (0 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 268311)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 268299)
     (if.true (push.iloc 2 . 0) (cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 269324) (apply))
     (touch.gloc.of transcribe-syntax-rules)
     (push.iloc 2 . 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 270377)
     (apply.gloc.of transcribe-syntax-rules "./boot/macro/expand.scm" . 270347))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc.1 . 0)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 268295))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 1)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 268295))
   (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 268295))
 (set.gloc.of expand-macro-use)
 (ret.const.unspec))
((close
   (2 0 . rewrite-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 316425)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 316425)
     (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 316425)
     (if.false.ret)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 316425)
     (ret.subr.gloc.of list? "./boot/macro/expand.scm" . 316425))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 316425)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 316425)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 316425))
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 316425))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 316425))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 316425))
         (ret.cons "./boot/macro/expand.scm" . 316425))
       (call
         (push.gloc.of car)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 316425))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 316425))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (touch.gloc.of |rewrite-form`2|)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 316425))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/expand.scm" . 316425))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 316425))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 316425))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 316425)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 316425))
 (set.gloc.of |rewrite-letrec-syntax`2|)
 (close
   (2 0 . rewrite-form)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 290839)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 290832))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 292880)
   (if.true
     (touch.gloc.of annotate)
     (call
       (touch.gloc.of |rewrite-form-each`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |rewrite-form-each`2| "./boot/macro/expand.scm" . 293914))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 293904))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/expand.scm" . 294928)
   (if.true
     (call
       (touch.gloc.of |rewrite-form-each`2|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/expand.scm" . 295985)
       (push.iloc.0 . 1)
       (apply.gloc.of |rewrite-form-each`2| "./boot/macro/expand.scm" . 295966))
     (push)
     (apply.gloc.of list->vector "./boot/macro/expand.scm" . 295952))
   (ret.iloc 0 . 0))
 (set.gloc.of |rewrite-form`2|)
 (close
   (2 0 . rewrite-form-each)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 280618)
       (push.iloc 2 . 1)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 280604))
     (push)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 281634)
       (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 281628))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/expand.scm" . 282661)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 282680)
       (ret.eq? "./boot/macro/expand.scm" . 282672))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 284696))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 277513))
 (set.gloc.of |rewrite-form-each`2|)
 (close
   (2 0 . rewrite-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 301065)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 301065)
     (ret.subr.gloc.of |.list?| "./boot/macro/expand.scm" . 301065))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 301065)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 301065)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 301065))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 301065))
     (push)
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 301065))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 301065))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/expand.scm" . 301065))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 301065))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of list)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 301065))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/expand.scm" . 301065))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of cons)
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/expand.scm" . 301065))
       (push)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 301065))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 301065))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 301065)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 301065))
 (set.gloc.of |rewrite-let-syntax`2|)
 (close
   (2 0 . expand-initial-forms)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 328743)
     (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 328734))
   (if.true
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 329768)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 329752))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (gloc.of denote-let-syntax)
     (if.eq?
       (touch.gloc.of |rewrite-let-syntax`2|)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of |rewrite-let-syntax`2| "./boot/macro/expand.scm" . 331797))
     (push.iloc.0 . 0)
     (gloc.of denote-letrec-syntax)
     (if.eq?
       (touch.gloc.of |rewrite-letrec-syntax`2|)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of |rewrite-letrec-syntax`2| "./boot/macro/expand.scm" . 333845))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 334869))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 335922))
       (push.close
         (2 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 336932))
         (push)
         (ret.subr.gloc.of values "./boot/macro/expand.scm" . 336919))
       (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 329740))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 338965))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of values "./boot/macro/expand.scm" . 341004))
 (set.gloc.of expand-initial-forms)
 (ret.const.unspec))
((close
   (3 0 . expand-body)
   (extend.unbound . 6)
   (push.const)
   (push.const)
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 352287)
       (push.iloc 2 . 2)
       (apply.gloc.of extend-env "./boot/macro/expand.scm" . 352275))
     (set.iloc 2 . 2)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 353294))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/expand.scm" . 355361))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 1)
         (call
           (touch.gloc.of generate-local-macro-symbol)
           (push.iloc.0 . 0)
           (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 356409))
         (push.cons)
         (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 356390)
         (push.iloc 2 . 2)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 356378))
       (set.iloc 2 . 2)
       (ret.const.unspec))
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 357417)
       (push.iloc 3 . 2)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 357407))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 357385))
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 362517)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/expand.scm" . 363543)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 364586)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 364570))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 365588))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/expand.scm" . 369684))
   (push.close
     (3 0 . rewrite-body)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of annotate)
       (call
         (touch.gloc.of expand-each)
         (push.iloc.0 . 0)
         (push.iloc 2 . 2)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 375834))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of annotate "./boot/macro/expand.scm" . 375824))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 377893))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 377876))
       (if.true.ret)
       (call
         (touch.gloc.of find-duplicates)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 378927))
         (push)
         (apply.gloc.of find-duplicates "./boot/macro/expand.scm" . 378910))
       (push)
       (extend . 1)
       (push.const . define)
       (push.const . "duplicate definitions")
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 382001)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 382018))
       (push)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 383034)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 383025)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 383052))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 379926))
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 384057)
         (push.iloc.1 . 2)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 384051)
         (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 384046))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 384027))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 385083)
         (push.iloc 3 . 2)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 385070))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 385051))
     (push)
     (extend . 2)
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/expand.scm" . 386073))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 388164)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 388172)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 388183))
         (push.iloc 2 . 2)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 388136))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 389152))
       (push.const . define)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 391218)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 393309)
             (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 393319)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 393279))
           (if.false.ret)
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 394303))
         (push.iloc 3 . 1)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 392242))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 390176))
     (call
       (touch.gloc.of check-internal-def-contract-violation)
       (call
         (push.gloc.of car)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 396352))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of check-internal-def-contract-violation "./boot/macro/expand.scm" . 396313))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 398366))
       (push.const . define)
       (push.const
         .
         "identifier ~u already used to determine the meaning of undeferred portions of definition")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 400432)
       (call
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 401463)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 401493))
         (ret.const . #f))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 386066))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 405568))
       (push)
       (push.iloc 5 . 2)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/expand.scm" . 405542))
     (push)
     (call
       (touch.gloc.of expand-each)
       (push.iloc 3 . 0)
       (push.iloc 5 . 2)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 405594))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/expand.scm" . 404505)
     (push.subr.gloc.of |.list| 1 "./boot/macro/expand.scm" . 404505)
     (push.iloc 5 . 1)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 404505))
   (enclose . 6)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 408595))
   (push)
   (extend . 1)
   (extend.enclose
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (car.iloc (0 . 0) "./boot/macro/expand.scm" . 411676)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 411697)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 411688))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 412712)
       (push.iloc 3 . 2)
       (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 412706)
       (set.iloc 3 . 2)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 4 . 2)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 413740)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 413724))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 415775))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 415769))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 417817)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/expand.scm" . 417817)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/expand.scm" . 417817)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/expand.scm" . 417817)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 417817)
           (ret.subr.gloc.of |.list?| "./boot/macro/expand.scm" . 417817))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/expand.scm" . 417817)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 417817))
         (if.true
           (push.cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 417817)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/expand.scm" . 417817)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/expand.scm" . 417817)
           (extend . 3)
           (call
             (push.close
               (0 0)
               (touch.gloc.of compile-macro)
               (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 417817)
               (push.iloc.1 . 1)
               (push.iloc 8 . 2)
               (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 417817))
             (push.close
               (1 1)
               (call
                 (iloc.0 . 1)
                 (if.not.pair?.ret.const . #f)
                 (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 417817)
                 (push.iloc 7 . 1)
                 (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 417817)
                 (set.iloc 7 . 1)
                 (ret.const.unspec))
               (call
                 (touch.gloc.of macro-variable?)
                 (push.iloc.0 . 0)
                 (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 417817))
               (if.true
                 (push.iloc.1 . 2)
                 (push.iloc.0 . 0)
                 (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 417817))
               (push.iloc.1 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.0 . 0)
                 (push.iloc 8 . 2)
                 (apply.gloc.of make-macro "./boot/macro/expand.scm" . 417817))
               (push)
               (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 417817))
             (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 417817))
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (call
             (touch.gloc.of acons)
             (push.iloc.0 . 2)
             (push.const . #f)
             (push.iloc 3 . 2)
             (apply.gloc.of acons "./boot/macro/expand.scm" . 417817))
           (push)
           (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 417817))
         (iloc.0 . 0)
         (if.true
           (push.iloc 2 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 417817)
           (push.const . "expected symbol for first clause")
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 417817)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 417817))
         (push.iloc 2 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 417817)
         (push.const . "expected symbol and transformer expression")
         (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 417817)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 417817))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 433219)
             (apply.gloc.of desugar-define "./boot/macro/expand.scm" . 433203))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 433198)
           (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 433232)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 433188))
         (push)
         (extend . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 434214)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 434241)
           (push.iloc 4 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 434230))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 2)
           (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 435236)
           (if.true
             (call
               (touch.gloc.of current-macro-expression)
               (push.iloc 7 . 0)
               (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 437289))
             (push.const . define)
             (push.const
               .
               "identifier ~u already used to determine the meaning of undeferred portions of definition")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 439344)
             (push.car.iloc (3 . 0) "./boot/macro/expand.scm" . 440368)
             (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 438313))
           (ret.const.unspec))
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (6 . 3) "./boot/macro/expand.scm" . 441373))
         (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 442403)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 2)
           (apply.gloc.of acons "./boot/macro/expand.scm" . 442430))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 442397))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/expand.scm" . 443421))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/expand.scm" . 445469))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 446536)
           (push.iloc 6 . 2)
           (apply.gloc.of expand-initial-forms "./boot/macro/expand.scm" . 446514))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 6 . 2)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 448571)
             (push.iloc 6 . 2)
             (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 448556))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 450602)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 450596))
           (call (push.iloc.0 . 0) (apply.iloc (6 . 4) "./boot/macro/expand.scm" . 451620))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 452668)
             (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 452650)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 452644))
           (push.iloc.0 . 0)
           (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 454724)
           (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 454706)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 454736)
           (push.iloc 3 . 2)
           (apply.iloc (6 . 5) "./boot/macro/expand.scm" . 454692))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 413712))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 456748)
       (push.iloc.1 . 2)
       (apply.iloc (4 . 5) "./boot/macro/expand.scm" . 456729))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 458787)
     (push.iloc.0 . 2)
     (apply.iloc (3 . 5) "./boot/macro/expand.scm" . 458768))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 409624))
   (push)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/expand.scm" . 409607))
 (set.gloc.of expand-body)
 (ret.const.unspec))
((close
   (2 0 . expand-each)
   (call
     (touch.gloc.of current-macro-expression)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 462865))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (call
     (push.close
       (1 0)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc.1 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 464920))
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 465944))
     (push.iloc.1 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 463889))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 463879))
 (set.gloc.of expand-each)
 (ret.const.unspec))
((close
   (2 0 . expand-form)
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 473112))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.symbol? (ret.iloc 0 . 0))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 475157))
     (if.true
       (push.close
         (0 0)
         (call
           (touch.gloc.of expansion-trace-level)
           (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 477226))
         (push)
         (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 477250))
         (push)
         (subr.gloc.of < 2 "./boot/macro/expand.scm" . 477223)
         (if.true
           (push.const . #f)
           (push.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 478291))
           (push)
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 478318))
           (push.cons)
           (push.const . 1)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 479314))
           (push)
           (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 479309)
           (extend . 4)
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 480297))
             (set.iloc 1 . 0)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 480297))
             (set.iloc 1 . 1)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 2)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 480297))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 3)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 480297))
           (push.close
             (0 0)
             (touch.gloc.of expand-macro-use)
             (push.iloc 4 . 0)
             (push.iloc 4 . 1)
             (push.iloc 3 . 0)
             (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 480297))
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 0)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 480297))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 1)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 480297))
           (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 480297))
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 481319))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 482345))
         (push)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 482327))
       (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 473100))
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/expand.scm" . 483349))
     (if.true
       (touch.gloc.of undefined/syntax-violation)
       (push.const . #f)
       (push.const . "attempt to reference unbound identifier ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 485415)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 486439))
       (push)
       (apply.gloc.of undefined/syntax-violation "./boot/macro/expand.scm" . 484373))
     (call
       (touch.gloc.of out-of-context?)
       (push.iloc.0 . 0)
       (apply.gloc.of out-of-context? "./boot/macro/expand.scm" . 487445))
     (if.true
       (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 488473)
       (if.true
         (push.const . #f)
         (push.const . "identifer ~u out of context")
         (push.iloc.1 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 490539)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 491563))
         (push)
         (call
           (touch.gloc.of annotate)
           (push.const . syntax)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 492611)
           (push.subr.gloc.of list 2 "./boot/macro/expand.scm" . 492597)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 492623)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 492587))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 489497))
       (push.const . #f)
       (push.const . "identifer ~u out of context")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 494635)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 495659))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 493593))
     (call
       (touch.gloc.of special?)
       (push.iloc.0 . 0)
       (apply.gloc.of special? "./boot/macro/expand.scm" . 496661))
     (if.true
       (push.const . #f)
       (push.const . "misplaced syntactic keyword ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 497706)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 497753))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 497685))
     (call
       (touch.gloc.of pattern-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of pattern-variable? "./boot/macro/expand.scm" . 498709))
     (if.true
       (push.const . #f)
       (push.const . "misplaced pattern variable ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 499754)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 499800))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 499733))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 501772)
   (if.true
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.const . #f)
       (push.const . "invalid expression")
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 502814))
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.0 . 0)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 503820))
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 504860)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.0 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 505903)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 505887))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/expand.scm" . 506908))
       (if.true
         (call
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 507940))
           (if.true.ret)
           (push.gloc.of denote-begin)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-import)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-macro)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-let-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-letrec-syntax)
           (iloc.0 . 0)
           (ret.eq? "./boot/macro/expand.scm" . 515108))
         (if.true
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 516129)
           (apply))
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 518178))
           (set.iloc 1 . 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.const . #t)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 518178))
         (push.close
           (0 0)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 518179)
           (apply))
         (push.close
           (0 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.iloc.1 . 0)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 518178))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 518178))
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 0)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 519196))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-macro-use)
           (push.iloc 2 . 0)
           (push.iloc 2 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 520249))
         (push.close
           (2 0)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 521253))
           (push)
           (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 521277))
           (push)
           (subr.gloc.of < 2 "./boot/macro/expand.scm" . 521250)
           (if.true
             (push.const . #f)
             (push.const . #f)
             (push.iloc 2 . 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 522323))
             (push.cons)
             (push.const . 1)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 523341))
             (push)
             (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 523336)
             (extend . 4)
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 524324))
               (set.iloc 1 . 0)
               (call
                 (touch.gloc.of expansion-trace-level)
                 (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 524324))
               (set.iloc 1 . 1)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 2)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 524324))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 3)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 524324))
             (push.close
               (0 0)
               (touch.gloc.of expand-form)
               (push.iloc 2 . 0)
               (call
                 (touch.gloc.of extend-env)
                 (push.iloc 2 . 1)
                 (push.iloc 4 . 1)
                 (apply.gloc.of extend-env "./boot/macro/expand.scm" . 524342))
               (push)
               (apply.gloc.of expand-form "./boot/macro/expand.scm" . 524324))
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 0)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 524324))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 1)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 524324))
             (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 524324))
           (touch.gloc.of expand-form)
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of extend-env)
             (push.iloc.0 . 1)
             (push.iloc 2 . 1)
             (apply.gloc.of extend-env "./boot/macro/expand.scm" . 525364))
           (push)
           (apply.gloc.of expand-form "./boot/macro/expand.scm" . 525346))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 505875))
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 527392))
       (if.true
         (touch.gloc.of expand-each)
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 528416))
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 530466))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 530466))
       (push.close
         (0 0)
         (touch.gloc.of expand-each)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 530466))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 530466))
       (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 530466))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 533525))
       (set.iloc 1 . 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #t)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 533525))
     (push.close
       (0 0)
       (touch.gloc.of expand-each)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 533525))
     (push.close
       (0 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 0)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 533525))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 533525))
   (iloc.0 . 0)
   (if.pair?
     (push.const . #f)
     (push.const . "expression is not a proper list")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 535564))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/expand.scm" . 536592)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/expand.scm" . 536608)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/expand.scm" . 536623)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/expand.scm" . 536636)
     (if.true.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of bytevector? "./boot/macro/expand.scm" . 536651))
   (if.true (ret.iloc 0 . 0))
   (push.const . #f)
   (push.const . "invalid expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 538636))
 (set.gloc.of expand-form)
 (ret.const.unspec))
((close
   (1 1 . macro-expand)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (extend . 8)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-macro-expression)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 2)
     (call
       (touch.gloc.of current-expansion-mode)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 3)
     (call
       (touch.gloc.of current-top-level-exterior)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 4)
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 5)
     (call
       (touch.gloc.of expansion-trace-level)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 6)
     (call
       (touch.gloc.of expansion-trace-stack)
       (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 550919))
     (set.iloc 1 . 7)
     (call
       (touch.gloc.of current-temporary-count)
       (push.const . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-rename-count)
       (push.const . 0)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-macro-expression)
       (push.const . #f)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.const . #f)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #f)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.const . 0)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 550919))
     (touch.gloc.of expansion-trace-stack)
     (push.const)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 550919))
   (push.close
     (0 0)
     (call
       (call
         (touch.gloc.of denote-begin?)
         (push.const)
         (push.const . begin)
         (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 550935))
       (if.true
         (touch.gloc.of flatten-top-level-begin)
         (push.const . begin)
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 551959)
         (push.gloc.of private-primitives-environment)
         (apply.gloc.of flatten-top-level-begin "./boot/macro/expand.scm" . 551959))
       (ret.iloc 2 . 0))
     (push)
     (extend . 1)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 554004)
     (if.null? (ret.const.unspec))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.gloc.of private-primitives-environment)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 556077))
     (push)
     (push.gloc.of annotate)
     (push.gloc.of annotate-closure)
     (call (apply.gloc.of current-after-expansion-hook "./boot/macro/expand.scm" . 556046))
     (apply))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (push.iloc.1 . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-rename-count)
       (push.iloc.1 . 1)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.1 . 2)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc.1 . 3)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 4)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 5)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 550919))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.iloc.1 . 6)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 550919))
     (touch.gloc.of expansion-trace-stack)
     (push.iloc.1 . 7)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 550919))
   (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 549908))
 (set.gloc.of macro-expand)
 (ret.const.unspec))

;
((close
   (2 0 . expand-lambda)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 7183))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/base.scm" . 7180)
   (if.true
     (call
       (touch.gloc.of collect-lambda-formals)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 8240)
       (push.iloc.0 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/base.scm" . 8216))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 9245))
     (push)
     (extend . 1)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/base.scm" . 10303))
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/base.scm" . 10285))
       (push)
       (apply.gloc.of map "./boot/macro/base.scm" . 10270))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 3 . 0)
       (push.cddr.iloc (3 . 0) "./boot/macro/base.scm" . 11309)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of extend-env "./boot/macro/base.scm" . 11321))
       (push)
       (apply.gloc.of expand-body "./boot/macro/base.scm" . 11291))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.const . lambda)
       (push.const . "empty body")
       (push.iloc 4 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 13332))
     (touch.gloc.of annotate)
     (push.const . lambda)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cadr.iloc (4 . 0) "./boot/macro/base.scm" . 14399)
       (push.iloc.1 . 0)
       (apply.gloc.of rename-lambda-formals "./boot/macro/base.scm" . 14376))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/base.scm" . 14356)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 14356))
   (push.const . lambda)
   (push.const . "expected formals and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 16396))
 (set.gloc.of expand-lambda)
 (ret.const.unspec))
((close
   (2 0 . expand-quote)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 20492))
   (push)
   (push.const . 2)
   (subr.gloc.of = 2 "./boot/macro/base.scm" . 20489)
   (if.true
     (touch.gloc.of annotate)
     (push.const . quote)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 21553)
       (apply.gloc.of strip-rename-suffix "./boot/macro/base.scm" . 21532))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/base.scm" . 21513)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 21513))
   (push.const . quote)
   (push.const . "expected single datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 22537))
 (set.gloc.of expand-quote)
 (ret.const.unspec))
((close
   (2 0 . expand-begin)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 26634))
     (if.false.ret)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 27669)
     (if.pair?.ret.const . #t)
     (push.const . begin)
     (push.const . "misplaced empty begin")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 28686))
   (touch.gloc.of annotate)
   (push.const . begin)
   (call
     (touch.gloc.of flatten-begin)
     (call
       (touch.gloc.of expand-each)
       (push.cdr.iloc (0 . 0) "./boot/macro/base.scm" . 29749)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/base.scm" . 29736))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of flatten-begin "./boot/macro/base.scm" . 29721))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 29701))
 (set.gloc.of expand-begin)
 (ret.const.unspec))
((close
   (2 0 . expand-if)
   (touch.gloc.of annotate)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (ret.pair? "./boot/macro/base.scm" . 33797))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 33797)
       (extend . 1)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/base.scm" . 33797))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddddr| 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cadddr| 1 "./boot/macro/base.scm" . 33797)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 33797)
       (extend . 2)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 1)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/base.scm" . 33797))
     (push.const . if)
     (push.const . "expected 2 or 3 expressions")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 33797))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 32771))
 (set.gloc.of expand-if)
 (ret.const.unspec))
((close
   (2 0 . expand-set!)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 48133)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 48133))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 48133)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (extend . 2)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/base.scm" . 48133))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 3 . 1)
           (apply.gloc.of extend-env "./boot/macro/base.scm" . 48133))
         (push)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
       (apply.gloc.of |.call-with-values| "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/base.scm" . 48133))
       (if.true.ret)
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.const . set!)
       (push.const . "misplaced syntactic keyword as variable")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (push.gloc.of immutable-primitives)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (call
         (touch.gloc.of renamed-id?)
         (push.iloc.0 . 0)
         (apply.gloc.of renamed-id? "./boot/macro/base.scm" . 48133))
       (if.true.ret.const . #f)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 4 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
         (apply.gloc.of denote-lambda? "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 0)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 48133))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 48133))
     (touch.gloc.of annotate)
     (push.const . set!)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 3 "./boot/macro/base.scm" . 48133)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 48133))
   (push.const . set!)
   (push.const . "expected variable and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
 (set.gloc.of expand-set!)
 (ret.const.unspec))
((close
   (2 0 . expand-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (ret.subr.gloc.of |.list?| "./boot/macro/base.scm" . 74757))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 74757)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 74757))
     (touch.gloc.of expand-form)
     (push.const . |.BEGIN|)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/base.scm" . 74757))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 74757))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
 (set.gloc.of expand-let-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (ret.subr.gloc.of |.list?| "./boot/macro/base.scm" . 87045))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 87045)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 87045))
     (touch.gloc.of expand-form)
     (push.const . |.BEGIN|)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/base.scm" . 87045))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 87045))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
 (set.gloc.of expand-letrec-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-define-syntax)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99338))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 100380)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 100362))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 99333)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 99333))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 99333)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/base.scm" . 99333)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 99333)
       (push.const . "expression is not a proper list")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 99333))
     (call
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 4 . 0)
           (push.iloc 3 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-macro "./boot/macro/base.scm" . 99333))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 99333))
           (if.true
             (push.const . variable)
             (push.iloc 3 . 1)
             (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
             (push.iloc 4 . 1)
             (apply.gloc.of |.set-top-level-macro!| "./boot/macro/base.scm" . 99333))
           (push.const . syntax)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |.set-top-level-macro!| "./boot/macro/base.scm" . 99333))
         (apply.gloc.of |.call-with-values| "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (apply.gloc.of |.dynamic-wind| "./boot/macro/base.scm" . 99333))
     (call
       (touch.gloc.of env-delete!)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-delete! "./boot/macro/base.scm" . 99333))
     (ret.const begin))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
   (push.const . "expected symbol and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 99333))
 (set.gloc.of expand-define-syntax)
 (ret.const.unspec))
((close
   (1 0 . immutable?)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 121869)
   (if.true.ret)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (ret.subr.gloc.of memq "./boot/macro/base.scm" . 122893))
 (set.gloc.of |immutable?`2|)
 (close
   (2 0 . expand-define)
   (extend.enclose+
     (1 0 . let?)
     (touch.gloc.of denote-let?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-let? "./boot/macro/base.scm" . 133129))
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135178))
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 136220)
     (push.const . "misplaced definition")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 136202))
   (call
     (touch.gloc.of desugar-define)
     (push.iloc.1 . 0)
     (apply.gloc.of desugar-define "./boot/macro/base.scm" . 137242))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 137242)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 137242)
   (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
   (extend . 2)
   (call
     (call
       (touch.gloc.of |immutable?`2|)
       (push.iloc.0 . 1)
       (apply.gloc.of |immutable?`2| "./boot/macro/base.scm" . 137242))
     (if.false.ret)
     (push.car.iloc (3 . 0) "./boot/macro/base.scm" . 137242)
     (push.const . "attempt to modify immutable binding")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 137242))
   (call
     (push.const . #f)
     (push.const . #f)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 137242))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 137242))
       (set.iloc 1 . 1)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 137242))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc 2 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 137242))
     (push.close
       (0 0)
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 137242))
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 137242))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 137242))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/base.scm" . 137242))
   (push)
   (extend . 1)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 137242)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
       (apply.iloc+ (3 . 0) "./boot/macro/base.scm" . 137242))
     (if.true
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 137242)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 1)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 137242))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 137242))
     (touch.gloc.of set-closure-comment!)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of original-id)
       (push.iloc.1 . 1)
       (apply.gloc.of original-id "./boot/macro/base.scm" . 137242))
     (push)
     (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 137242))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/base.scm" . 137242)
   (call
     (touch.gloc.of env-delete!)
     (push.iloc 4 . 1)
     (push.iloc.1 . 1)
     (apply.gloc.of env-delete! "./boot/macro/base.scm" . 137242))
   (touch.gloc.of annotate)
   (push.const . define)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 3 "./boot/macro/base.scm" . 137242)
   (push.iloc 4 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 137242))
 (set.gloc.of expand-define)
 (ret.const.unspec))

;
((close
   (2 0 . expand-let)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.pair? "./boot/macro/derived.scm" . 7173))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 7173)
     (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 7173)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 7173)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 7173)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 3)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 1)
       (push.const . |.LETREC*|)
       (push.iloc.0 . 2)
       (push.const . |.LAMBDA|)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 7173)
       (push.iloc.0 . 2)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push.cons)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 7173)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 7173))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 4 . 0)
       (push.cddr.iloc (4 . 0) "./boot/macro/derived.scm" . 7173)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of cons)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
         (push)
         (push.iloc 4 . 1)
         (apply.gloc.of extend-env "./boot/macro/derived.scm" . 7173))
       (push)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 5 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (call
       (push.close
         (2 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (call
           (touch.gloc.of denote-lambda?)
           (push.iloc 6 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
           (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 7173))
         (if.false.ret)
         (touch.gloc.of set-closure-comment!)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of original-id)
           (push.iloc.0 . 1)
           (apply.gloc.of original-id "./boot/macro/derived.scm" . 7173))
         (push)
         (apply.gloc.of set-closure-comment! "./boot/macro/derived.scm" . 7173))
       (push.iloc 2 . 1)
       (push.iloc 2 . 0)
       (apply.gloc.of for-each "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.1 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
 (set.gloc.of expand-let)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec*)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.pair? "./boot/macro/derived.scm" . 44037))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 44037))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 44037))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 44037))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 44037))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 44037))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 44037)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
             (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 44037)
             (push.iloc.0 . 0)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 44037))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (push.iloc.1 . 0)
         (apply.gloc.of any1 "./boot/macro/derived.scm" . 44037))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc 2 . 0)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 44037))
     (push)
     (push.iloc.1 . 1)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 7 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
 (set.gloc.of expand-letrec*)
 (ret.const.unspec))
((close
   (2 0 . expand-let*)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 74764))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 74761)
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 75801)
     (extend . 1)
     (call
       (touch.gloc.of check-let*-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let*-bindings "./boot/macro/derived.scm" . 76811))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . |.LET|)
             (push.const)
             (push.cddr.iloc (3 . 0) "./boot/macro/derived.scm" . 81951)
             (ret.subr.gloc.of |.cons*| "./boot/macro/derived.scm" . 80911))
           (push.const . |.LET|)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 82972)
           (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 80911)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 82990)
             (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 82984))
           (push)
           (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 80911))
         (push.iloc.1 . 0)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 79885))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 75785))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 75785))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 86043)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 86025))
 (set.gloc.of expand-let*)
 (ret.const.unspec))
((close
   (2 0)
   (push.const . set!)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn4.1`4|)
 (close (1 0) (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn3.1`3|)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . |.&UNDEF|)
   (ret.subr.gloc.of list "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . expand-letrec)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.pair? "./boot/macro/derived.scm" . 90117))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.const)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
     (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LETREC*|)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caaadr| 1 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 90117)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 90117))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 90117))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 90117)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 90117)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
     (call
       (touch.gloc.of check-rec-contract-violation)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 90117)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 90117)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
             (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 90117)
             (push.iloc.0 . 0)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 90117))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (push.iloc.1 . 0)
         (apply.gloc.of any1 "./boot/macro/derived.scm" . 90117))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
     (call
       (touch.gloc.of every1)
       (push.close
         (1 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (touch.gloc.of denote-lambda?)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
         (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 90117))
       (push.iloc.1 . 0)
       (apply.gloc.of every1 "./boot/macro/derived.scm" . 90117))
     (if.true
       (touch.gloc.of annotate)
       (push.const . letrec*)
       (call
         (touch.gloc.of rewrite-letrec*-bindings)
         (call
           (push.gloc.of list)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 90117))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc 7 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (call
       (push.gloc.of |.fn3.1`3|)
       (push.iloc 5 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (push.const . let)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (push.gloc.of |.fn4.1`4|)
       (push.iloc 4 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc 2 . 1)
     (push.subr.gloc.of |.append| 2 "./boot/macro/derived.scm" . 90117)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 90117))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
 (set.gloc.of expand-letrec)
 (ret.const.unspec))
((close
   (2 0 . expand-let-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 124933))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 124933)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "expected bindings and body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of append)
           (call
             (push.close
               (1 0)
               (call
                 (iloc.0 . 0)
                 (if.not.pair?.ret.const . #f)
                 (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (if.not.pair?.ret.const . #f)
                 (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (ret.null? "./boot/macro/derived.scm" . 124933))
               (if.true
                 (touch.gloc.of collect-lambda-formals)
                 (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (push.iloc 2 . 0)
                 (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 124933))
               (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 124933)
               (push.const . "expected each binding consist of formals and expression")
               (push.iloc 2 . 0)
               (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
             (push.iloc.0 . 1)
             (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
           (push)
           (apply.gloc.of apply "./boot/macro/derived.scm" . 124933))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/derived.scm" . 124933))
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "duplicate formals")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (touch.gloc.of annotate)
     (call
       (extend.enclose
         (2 0 . loop)
         (iloc.0 . 0)
         (if.null?
           (touch.gloc.of expand-form)
           (push.const . |.LET|)
           (push.const)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 124933)
           (push.iloc.0 . 1)
           (apply.gloc.of expand-form "./boot/macro/derived.scm" . 124933))
         (call
           (car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 124933)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 124933)
           (ret.null? "./boot/macro/derived.scm" . 124933))
         (if.true
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 124933)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 124933)
           (extend . 2)
           (call
             (touch.gloc.of collect-lambda-formals)
             (push.iloc.0 . 1)
             (push.iloc 4 . 0)
             (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of fresh-rename-count)
             (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (call
             (push.gloc.of cons)
             (push.iloc.1 . 0)
             (call
               (push.close
                 (1 0)
                 (touch.gloc.of rename-id)
                 (push.iloc.0 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of rename-id "./boot/macro/derived.scm" . 124933))
               (push.iloc.1 . 0)
               (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
             (push)
             (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (push.const . |.call-with-values|)
           (push.const . lambda)
           (push.const)
           (call
             (touch.gloc.of expand-form)
             (push.iloc 3 . 0)
             (push.iloc 7 . 1)
             (apply.gloc.of expand-form "./boot/macro/derived.scm" . 124933))
           (push)
           (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 124933)
           (push.const . lambda)
           (call
             (touch.gloc.of rename-lambda-formals)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of rename-lambda-formals "./boot/macro/derived.scm" . 124933))
           (push)
           (call
             (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 124933)
             (call
               (touch.gloc.of extend-env)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of extend-env "./boot/macro/derived.scm" . 124933))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/derived.scm" . 124933))
           (push)
           (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 124933)
           (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 124933))
         (push.const . "internal error: let-values: ~m")
         (push.iloc 3 . 0)
         (apply.gloc.of scheme-error "./boot/macro/derived.scm" . 124933))
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 124933))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 124933))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
 (set.gloc.of expand-let-values)
 (ret.const.unspec))
((close
   (2 0 . expand-do)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 166917)
     (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 166917)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 166917))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (extend . 4)
     (call
       (push.iloc.0 . 3)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 166917)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
       (push.const . "malformed (variable init update)")
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 166917))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
           (ret.pair? "./boot/macro/derived.scm" . 166917))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
           (ret.null? "./boot/macro/derived.scm" . 166917))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.car| "./boot/macro/derived.scm" . 166917))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
           (ret.null? "./boot/macro/derived.scm" . 166917))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.caddr| "./boot/macro/derived.scm" . 166917))
         (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 166917)
         (push.const . "malformed (variable init update)")
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
       (push.iloc.0 . 3)
       (apply.gloc.of map "./boot/macro/derived.scm" . 166917))
     (push)
     (extend . 2)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 0)
       (call
         (push.close
           (1 0)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 166917))
           (if.true
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (ret.subr.gloc.of list "./boot/macro/derived.scm" . 166917))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 166917)
           (push.const . "malformed (variable init update)")
           (push.iloc 3 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
         (push.iloc.1 . 3)
         (apply.gloc.of map "./boot/macro/derived.scm" . 166917))
       (push)
       (push.const . |.IF|)
       (push.iloc.1 . 2)
       (call
         (iloc.1 . 1)
         (if.null? (ret.const |.UNSPECIFIED|))
         (push.const . |.BEGIN|)
         (iloc.1 . 1)
         (ret.cons "./boot/macro/derived.scm" . 166917))
       (push)
       (push.const . |.BEGIN|)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 166917)
       (subr.gloc.of |.append| 2 "./boot/macro/derived.scm" . 166917)
       (push.cons)
       (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 166917)
       (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 166917)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 166917))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 166917))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
   (push.const . "expected (variable init update), test, and command")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
 (set.gloc.of expand-do)
 (ret.const.unspec))
((close
   (2 0 . expand-let*-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 199685))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 199685)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 199685)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 199685)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . |.LET|)
             (push.const)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.cons*| "./boot/macro/derived.scm" . 199685))
           (call
             (car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 199685)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 199685)
             (ret.null? "./boot/macro/derived.scm" . 199685))
           (if.true
             (push.const . |.CALL-WITH-VALUES|)
             (push.const . |.LAMBDA|)
             (push.const)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 199685)
             (push.const . |.LAMBDA|)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 199685)
             (call
               (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
               (apply.iloc (1 . 0) "./boot/macro/derived.scm" . 199685))
             (push)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 199685)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 199685))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 199685)
           (push.const . "expected each binding consist of formals and expression")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
         (push.iloc.1 . 1)
         (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 199685))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 199685))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 199685))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
 (set.gloc.of expand-let*-values)
 (ret.const.unspec))
((close
   (2 0 . expand-cond)
   (extend.unbound . 3)
   (push.close+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 228384))
   (push.close+
     (1 0 . =>?)
     (touch.gloc.of denote-=>?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-=>? "./boot/macro/derived.scm" . 229406))
   (push.close+
     (1 0 . lambda?)
     (touch.gloc.of denote-lambda?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 230434))
   (enclose . 3)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.1 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 232463))
   (push)
   (push.const . 1)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 232460)
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?.ret.const |.UNSPECIFIED|)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 238626)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.pair? "./boot/macro/derived.scm" . 239638))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (call
               (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 239638))
             (if.false.ret)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.pair? "./boot/macro/derived.scm" . 239638))
           (if.true
             (cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
             (if.null?
               (push.const . |.BEGIN|)
               (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (ret.cons "./boot/macro/derived.scm" . 239638))
             (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 239638)
             (push.const . "misplaced else")
             (push.iloc 5 . 0)
             (push.iloc.1 . 0)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 239638)
             (if.false.ret)
             (call
               (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 239638))
             (if.false.ret)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 239638)
             (apply.iloc+ (4 . 2) "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 239638)
             (extend . 1)
             (push.const . |.LET|)
             (push.iloc.0 . 0)
             (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 239638)
             (push.const . |.IF|)
             (push.iloc.0 . 0)
             (push.const . |.LET|)
             (push.const)
             (push.iloc 2 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (extend . 2)
             (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 239638))
             (push)
             (extend . 1)
             (push.const . |.LET|)
             (push.iloc.0 . 0)
             (push.iloc.1 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 239638)
             (push.const . |.IF|)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (5 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.null? "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.const . |.OR|)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.const . |.IF|)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (push.const . |.BEGIN|)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (push.cons)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 239638)
           (push.const . "malformed cond clause")
           (push.iloc 5 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 239638))
         (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 235550)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 235534))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 228357))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 228357))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 267294)
   (push.const . "expected cond clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 267276))
 (set.gloc.of expand-cond)
 (ret.const.unspec))
((close
   (2 0 . maplist)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call (push.iloc.0 . 1) (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 277531))
   (push)
   (call
     (touch.gloc.of |maplist`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/macro/derived.scm" . 277556)
     (apply.gloc.of |maplist`2| "./boot/macro/derived.scm" . 277542))
   (ret.cons "./boot/macro/derived.scm" . 277525))
 (set.gloc.of |maplist`2|)
 (close
   (2 0 . expand-case)
   (extend.enclose+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 272416))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (ret.pair? "./boot/macro/derived.scm" . 298040))
   (if.true
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (extend . 2)
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 298040))
     (push)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 298040)
       (push.const . |.COND|)
       (call
         (touch.gloc.of |maplist`2|)
         (push.close
           (1 0)
           (push.gloc.of pair?)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (car.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
             (ret.pair? "./boot/macro/derived.scm" . 298040))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 298040)
             (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 298040))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (call
               (push.iloc 3 . 0)
               (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
               (apply.iloc+ (6 . 0) "./boot/macro/derived.scm" . 298040))
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (if.null?
               (push.const . |.ELSE|)
               (push.iloc 3 . 0)
               (subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 298040)
             (push.const . "misplaced else")
             (push.iloc 7 . 0)
             (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (if.not.pair?.ret.const . #f)
             (push.iloc 3 . 0)
             (subr.gloc.of |.cdaar| 1 "./boot/macro/derived.scm" . 298040)
             (if.not.null?.ret.const . #f)
             (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 298040)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caaar| 1 "./boot/macro/derived.scm" . 298040)
             (extend . 2)
             (call
               (iloc.0 . 1)
               (if.symbol?.ret.const . #t)
               (push.iloc.0 . 1)
               (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (iloc.0 . 1)
               (ret.null? "./boot/macro/derived.scm" . 298040))
             (if.true
               (push.const . |.EQ?|)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
               (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.const . |.EQV?|)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 298040))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 298040)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (extend . 2)
             (iloc.0 . 1)
             (if.null?.ret.const #f)
             (call
               (touch.gloc.of every1)
               (push.close
                 (1 0)
                 (iloc.0 . 0)
                 (if.symbol?.ret.const . #t)
                 (push.iloc.0 . 0)
                 (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (iloc.1 . 1)
                 (ret.null? "./boot/macro/derived.scm" . 298040))
               (push.iloc.0 . 1)
               (apply.gloc.of every1 "./boot/macro/derived.scm" . 298040))
             (if.true
               (push.const . |.MEMQ|)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
               (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.const . |.MEMV|)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 298040))
           (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 298040)
           (push.const . "malformed case clause")
           (push.iloc 7 . 0)
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
         (push.iloc.1 . 0)
         (apply.gloc.of |maplist`2| "./boot/macro/derived.scm" . 298040))
       (push.cons)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
       (push.iloc 3 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 298040))
     (push)
     (push.iloc 3 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 298040))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
   (push.const . "expected case clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
 (set.gloc.of expand-case)
 (ret.const.unspec))
((close
   (2 0 . expand-and)
   (touch.gloc.of annotate)
   (push.const . and)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 312356)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 312343))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 312325))
 (set.gloc.of expand-and)
 (ret.const.unspec))
((close
   (2 0 . expand-or)
   (touch.gloc.of annotate)
   (push.const . or)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 316451)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 316438))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 316421))
 (set.gloc.of expand-or)
 (ret.const.unspec))
((close
   (1 0 . desugar-define)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true
     (touch.gloc.of annotate)
     (push.const . define)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const (|.UNSPECIFIED|))
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (extend . 2)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 337933))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 1)
     (push.const . lambda)
     (push.iloc.0 . 0)
     (push.const (|.UNSPECIFIED|))
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 337933))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.iloc 2 . 0)
   (push.subr.gloc.of length 1 "./boot/macro/derived.scm" . 337933)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/derived.scm" . 337933)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "expected 1 or 2, but no clause given")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.iloc.0 . 0)
   (push.const 1 2)
   (subr.gloc.of |.memq| 2 "./boot/macro/derived.scm" . 337933)
   (if.true
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "expected symbol for first clause")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
   (push.const . "expected 1 or 2, but ~a clauses given")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 337933)
   (push.iloc 3 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
 (set.gloc.of desugar-define)
 (ret.const.unspec))
((close
   (1 0 . desugar-define-macro)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 344069)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 344069))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 344069)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 344069))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 344069))
     (touch.gloc.of annotate)
     (push.const . define-macro)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 344069)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 344069)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 344069))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 344069))
   (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
   (push.const . "expected symbol and expression")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 344069))
 (set.gloc.of desugar-define-macro)
 (ret.const.unspec))
((close
   (1 0 . rewrite-define-macro)
   (call
     (touch.gloc.of desugar-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of desugar-define-macro "./boot/macro/derived.scm" . 357402))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 357402)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 357402)
   (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (extend . 2)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 357402))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (push.const . |.DEFINE-SYNTAX|)
   (push.iloc.1 . 1)
   (push.const . |.LAMBDA|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 357402)
   (push.const . |.APPLY|)
   (push.iloc.1 . 0)
   (push.const . |.CDR|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.iloc 3 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 357402))
 (set.gloc.of rewrite-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-define-macro)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/derived.scm" . 364554))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 365596)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 365578))
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of rewrite-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of rewrite-define-macro "./boot/macro/derived.scm" . 366610))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 366597))
 (set.gloc.of expand-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-identifier-syntax)
   (extend.enclose+
     (1 0 . set!?)
     (touch.gloc.of denote-set!?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-set!? "./boot/macro/derived.scm" . 371744))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 371717)
     (ret.pair? "./boot/macro/derived.scm" . 371717))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
     (ret.null? "./boot/macro/derived.scm" . 371717))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LAMBDA|)
       (push.const x)
       (push.const . |.SYNTAX-CASE|)
       (push.const . x)
       (push.const)
       (push.const . id)
       (push.const |.IDENTIFIER?| (|.SYNTAX| id))
       (push.const . |.SYNTAX|)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
       (push.const _ x ...)
       (push.const . |.SYNTAX|)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
       (const x ...)
       (push.cons)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 5 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 371717))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 371717))
   (iloc.0 . 0)
   (if.false.ret)
   (cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cddadr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (call
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 371717)
     (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 371717))
   (if.false.ret)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.cadadr| 1 "./boot/macro/derived.scm" . 371717)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 371717)
   (extend . 2)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (push.const . |.MAKE-VARIABLE-TRANSFORMER|)
     (push.const . |.LAMBDA|)
     (push.const x)
     (push.const . |.SYNTAX-CASE|)
     (push.const . x)
     (push.const set!)
     (push.const . set!)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 371717)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.const . |.SYNTAX|)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc.0 . 1)
     (const x ...)
     (push.cons)
     (push.const . |.SYNTAX|)
     (push.iloc.0 . 0)
     (const x ...)
     (push.cons)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc.0 . 1)
     (push.const |.IDENTIFIER?| (|.SYNTAX| id))
     (push.const . |.SYNTAX|)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 6 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 371717))
   (push)
   (push.iloc 3 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 371717))
 (set.gloc.of expand-identifier-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-assert)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (ret.null? "./boot/macro/derived.scm" . 398341))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.OR|)
       (push.iloc.0 . 0)
       (push.const . assertion-violation)
       (push.const . quote)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/derived.scm" . 398341))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 398341)
       (push.const . "assertion failed in expression ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 398341)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 398341)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 398341)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 398341))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 398341))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
   (push.const . "expected single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 398341))
 (set.gloc.of expand-assert)
 (ret.const.unspec))

;
((close
   (2 0 . expand-quasiquote)
   (extend.unbound . 12)
   (push.close+
     (1 0 . unquote?)
     (touch.gloc.of denote-unquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 8228))
   (push.close+
     (1 0 . quasiquote?)
     (touch.gloc.of denote-quasiquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 9255))
   (push.close+
     (1 0 . unquote-splicing?)
     (touch.gloc.of denote-unquote-splicing?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 10285))
   (push.close+
     (1 0 . quoted?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 15381)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/quasi.scm" . 16405)
     (if.not.null?.ret.const . #f)
     (touch.gloc.of denote-quote?)
     (push.iloc 2 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 17441)
     (apply.gloc.of denote-quote? "./boot/macro/quasi.scm" . 17422))
   (push.close+
     (1 0 . constant?)
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/quasi.scm" . 21517)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/quasi.scm" . 22541)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/quasi.scm" . 23565)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/quasi.scm" . 24589)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of bytevector? 1 "./boot/macro/quasi.scm" . 25613)
     (if.true.ret)
     (push.iloc.0 . 0)
     (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 26637))
   (push.close+
     (1 0 . constant-value)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 30736))
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cadr "./boot/macro/quasi.scm" . 30748))
     (ret.iloc 0 . 0))
   (push.close+
     (1 0 . null-constant?)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 35854))
     (if.false.ret)
     (cadr.iloc (0 . 0) "./boot/macro/quasi.scm" . 36885)
     (ret.null? "./boot/macro/quasi.scm" . 36878))
   (push.close+
     (2 0 . emit-append)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 42000))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 43031)
       (push.const . 1)
       (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 43028)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/macro/quasi.scm" . 43048))
       (push.const . |.APPEND|)
       (iloc.0 . 0)
       (ret.cons "./boot/macro/quasi.scm" . 43024))
     (push.const . |.APPEND|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of |.list| 1 "./boot/macro/quasi.scm" . 44047)
     (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 44047)
     (ret.cons "./boot/macro/quasi.scm" . 44047))
   (push.close+
     (2 0 . emit-cons*)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 49168)
     (push.const . 1)
     (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 49165)
     (if.true
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 50200)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 9) "./boot/macro/quasi.scm" . 50189))
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 52244))
     (if.true (push.const . |.LIST|) (iloc.0 . 0) (ret.cons "./boot/macro/quasi.scm" . 52243))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 54315)
       (const . |.LIST|)
       (ret.eq? "./boot/macro/quasi.scm" . 54310))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 55333)
       (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 54291)
       (ret.cons "./boot/macro/quasi.scm" . 54291))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56367)
       (const . |.CONS|)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56391)
       (const . |.CONS*|)
       (ret.eq? "./boot/macro/quasi.scm" . 56386))
     (if.true
       (push.const . |.CONS*|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 57382)
       (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 56339)
       (ret.cons "./boot/macro/quasi.scm" . 56339))
     (push.const . |.CONS*|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of |.list| 1 "./boot/macro/quasi.scm" . 58387)
     (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 58387)
     (ret.cons "./boot/macro/quasi.scm" . 58387))
   (push.close+
     (2 0 . emit-cons)
     (call
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63506))
       (if.false.ret)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63523))
     (if.true
       (push.const . |.QUOTE|)
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64545))
       (push)
       (call (push.iloc.0 . 1) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64567))
       (push.cons)
       (ret.subr.gloc.of list "./boot/macro/quasi.scm" . 64525))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 65556))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 65555))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 67627)
       (const . |.LIST|)
       (ret.eq? "./boot/macro/quasi.scm" . 67622))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 68644)
       (ret.subr.gloc.of |.cons*| "./boot/macro/quasi.scm" . 67603))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69679)
       (const . |.CONS|)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69703)
       (const . |.CONS*|)
       (ret.eq? "./boot/macro/quasi.scm" . 69698))
     (if.true
       (push.const . |.CONS*|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 70693)
       (ret.subr.gloc.of |.cons*| "./boot/macro/quasi.scm" . 69651))
     (push.const . |.CONS|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 71699))
   (push.close
     (2 0 . expand-vector)
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/quasi.scm" . 76828)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 11) "./boot/macro/quasi.scm" . 76820))
     (push)
     (extend . 1)
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 6) "./boot/macro/quasi.scm" . 77842))
     (if.true.ret.const |.QUOTE| #())
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 4) "./boot/macro/quasi.scm" . 79890))
     (if.true
       (push.const . |.QUOTE|)
       (call
         (call (push.iloc.0 . 0) (apply.iloc+ (2 . 5) "./boot/macro/quasi.scm" . 80938))
         (push)
         (apply.gloc.of list->vector "./boot/macro/quasi.scm" . 80924))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 79889))
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 81943)
     (const . |.LIST|)
     (if.eq?
       (push.const . |.VECTOR|)
       (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 82974)
       (ret.cons "./boot/macro/quasi.scm" . 81937))
     (push.const . |.LIST->VECTOR|)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 83985))
   (push.close
     (2 0 . expand)
     (iloc.0 . 0)
     (if.pair?
       (=n.iloc (0 . 1) 0 "./boot/macro/quasi.scm" . 90132)
       (if.true
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (ret.subr.gloc.of |.list?| "./boot/macro/quasi.scm" . 90128))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 8) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 7) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (subr.gloc.of |.list?| 1 "./boot/macro/quasi.scm" . 90128)
           (if.false.ret)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (call
             (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.null?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.cadr| "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "nested quasiquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote-splicing appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 108575)
       (extend . 1)
       (call
         (call
           (touch.gloc.of denote-unquote?)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 109601))
         (if.true.ret)
         (touch.gloc.of denote-unquote-splicing?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 109627))
       (if.true
         (push.const . |.QUOTE|)
         (push.iloc.0 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/quasi.scm" . 110621)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 111664)
           (push.n+.iloc (1 . 1) -1 "./boot/macro/quasi.scm" . 111675)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 111656))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 110621))
       (call
         (touch.gloc.of denote-quasiquote?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 112669))
       (if.true
         (push.const . |.QUOTE|)
         (push.iloc.0 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/quasi.scm" . 113693)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 114736)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/quasi.scm" . 114747)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 114728))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 113693))
       (call
         (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 116784)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 116776))
       (push)
       (call
         (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 117808)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 117800))
       (push)
       (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 116765))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/quasi.scm" . 118800)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 10) "./boot/macro/quasi.scm" . 119824))
     (iloc.0 . 0)
     (if.symbol?
       (push.const . |.QUOTE|)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 120847))
     (iloc.0 . 0)
     (if.null?.ret.const |.QUOTE| ())
     (ret.iloc 0 . 0))
   (enclose . 12)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (call
       (push.cadr.iloc (1 . 0) "./boot/macro/quasi.scm" . 127012)
       (push.const . 0)
       (apply.iloc (0 . 11) "./boot/macro/quasi.scm" . 127004))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/quasi.scm" . 126994))
   (push)
   (push.iloc.1 . 1)
   (apply.gloc.of expand-form "./boot/macro/quasi.scm" . 126981))
 (set.gloc.of expand-quasiquote)
 (ret.const.unspec))

;
((close
   (1 0 . ellipsis-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 8209)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 9231)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 9226))
 (set.gloc.of ellipsis-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-splicing-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 14353)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 15375)
   (const . ...)
   (if.not.eq?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 16401)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/macro/synpat.scm" . 17423)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 17418))
 (set.gloc.of ellipsis-splicing-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-quote?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 22545)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 23567)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 23562))
 (set.gloc.of ellipsis-quote?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 29716)
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 30746)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 30740))
     (push)
     (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 29710))
   (push.iloc.0 . 0)
   (const . ...)
   (if.eq? (ret.iloc 0 . 1))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 33810)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/synpat.scm" . 33829))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 34830)
   (if.true
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 35860)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 35854))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . collect-unique-ids)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 27653))
 (set.gloc.of collect-unique-ids)
 (ret.const.unspec))
((close
   (4 0 . collect-vars-ranks)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 3))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 43024)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of acons)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of acons "./boot/macro/synpat.scm" . 45072))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 0)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 46092))
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 47136)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 48173)
       (if.symbol?
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 49195)
         (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 49205)
         (push.iloc.0 . 3)
         (apply.gloc.of acons "./boot/macro/synpat.scm" . 49188))
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 50232)
       (push.iloc.0 . 1)
       (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 50248)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 50212))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 47116))
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of collect-vars-ranks)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 52256)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 53300)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 53280))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 52236))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 54284)
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 55328)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 55308))
   (ret.iloc 0 . 3))
 (set.gloc.of collect-vars-ranks)
 (ret.const.unspec))
((close
   (2 0 . check-duplicate-variable)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 65560)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 66590)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 66584))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 65554))
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq? (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (const . _)
     (if.eq? (ret.iloc 0 . 1))
     (iloc.0 . 0)
     (if.symbol?
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 70678)
       (if.true (ret.iloc 0 . 1))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 72730)
       (if.true
         (push.const . "syntax pattern")
         (push.const . "duplicate pattern variables")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 73754))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/synpat.scm" . 74778))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 75794)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 76824)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 76818))
     (ret.iloc 0 . 1))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 63497))
 (set.gloc.of |check-duplicate-variable`2|)
 (close
   (2 0 . check-misplaced-ellipsis)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq?
       (push.const . "syntax pattern")
       (push.const . "improper use of ellipsis")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 83986))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 85010))
     (if.true
       (call
         (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 86048)
         (if.not.symbol?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 87069)
         (push.iloc 2 . 1)
         (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 87063)
         (if.false.ret)
         (push.const . "syntax pattern")
         (push.const . "ellipsis following literal")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 88087))
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 91170)
         (const . ...)
         (if.eq?
           (push.const . "syntax pattern")
           (push.const . "ambiguous use of ellipsis")
           (push.iloc 4 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 92189))
         (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 93219)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 93213))
       (push.cddr.iloc (1 . 0) "./boot/macro/synpat.scm" . 89122)
       (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 89106))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 95260)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95254))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 95277)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95271))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 96274)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 97304)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 97298))
     (ret.const . #f))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 81929))
 (set.gloc.of |check-misplaced-ellipsis`2|)
 (close
   (2 0 . check-pattern)
   (call
     (touch.gloc.of |check-misplaced-ellipsis`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |check-misplaced-ellipsis`2| "./boot/macro/synpat.scm" . 100357))
   (touch.gloc.of |check-duplicate-variable`2|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of |check-duplicate-variable`2| "./boot/macro/synpat.scm" . 101381))
 (set.gloc.of check-pattern)
 (ret.const.unspec))
((close
   (3 0 . match-ellipsis?)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 107550)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 107561)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 107534))
   (if.false.ret)
   (touch.gloc.of match-ellipsis?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 108575)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 108558))
 (set.gloc.of match-ellipsis?)
 (ret.const.unspec))
((close
   (4 0 . match-ellipsis-n?)
   (=n.iloc (0 . 2) 0 "./boot/macro/synpat.scm" . 112649)
   (if.true.ret)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 114718)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 114729)
     (push.iloc.0 . 3)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 114702))
   (if.false.ret)
   (touch.gloc.of match-ellipsis-n?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 115745)
   (push.iloc.0 . 1)
   (push.n+.iloc (0 . 2) -1 "./boot/macro/synpat.scm" . 115760)
   (push.iloc.0 . 3)
   (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 115726))
 (set.gloc.of match-ellipsis-n?)
 (ret.const.unspec))
((close
   (3 0 . match-pattern?)
   (push.iloc.0 . 1)
   (const . _)
   (if.eq?.ret.const . #t)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 121875)
     (if.true
       (call
         (iloc.0 . 0)
         (if.symbol?.ret.const . #t)
         (push.iloc.0 . 0)
         (apply.gloc.of identifier? "./boot/macro/synpat.scm" . 123932))
       (if.false.ret)
       (touch.gloc.of free-id=?)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of free-id=? "./boot/macro/synpat.scm" . 124952))
     (ret.const . #t))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 126988))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 128028)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 128040))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 129053)
       (if.symbol?.ret.const . #t)
       (touch.gloc.of match-ellipsis?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 130068))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131100))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 131130)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131118))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 131097)
     (extend . 1)
     (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 132118)
     (if.true
       (touch.gloc.of match-pattern?)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 133163)
       (push.iloc.1 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 133142))
     (>n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 134171)
     (if.false.ret)
     (call
       (touch.gloc.of match-ellipsis-n?)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 135195))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 136235)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 136254)
     (push.iloc.1 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 136219))
   (iloc.0 . 1)
   (if.pair?
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of match-pattern?)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 139297)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 139308)
       (push.iloc.0 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 139281))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 140321)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 140332)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 140305))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 141324)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 142353)
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143393)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143413)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 143377))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of equal? "./boot/macro/synpat.scm" . 144401))
 (set.gloc.of match-pattern?)
 (ret.const.unspec))
((close
   (2 0 . union-vars)
   (iloc.0 . 1)
   (if.null? (ret.iloc 0 . 0))
   (touch.gloc.of union-vars)
   (call
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 150560)
     (push.iloc.0 . 1)
     (push.subr.gloc.of cdar 1 "./boot/macro/synpat.scm" . 150582)
     (push.subr.gloc.of reverse 1 "./boot/macro/synpat.scm" . 150573)
     (push.iloc.0 . 0)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 150549))
   (push)
   (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 151573)
   (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 150537))
 (set.gloc.of union-vars)
 (ret.const.unspec))
((close
   (3 0 . bind-var!)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 2))
   (push.iloc.0 . 0)
   (push.iloc.0 . 2)
   (push.subr.gloc.of assq 2 "./boot/macro/synpat.scm" . 157720)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 159795)
     (push.cons)
     (subr.gloc.of set-cdr! 2 "./boot/macro/synpat.scm" . 159769)
     (ret.iloc 1 . 2))
   (touch.gloc.of acons)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of list 1 "./boot/macro/synpat.scm" . 160797)
   (push.iloc.1 . 2)
   (apply.gloc.of acons "./boot/macro/synpat.scm" . 160786))
 (set.gloc.of bind-var!)
 (ret.const.unspec))
((close
   (3 0 . bind-null-ellipsis)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 167953)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 168987)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 168981)
       (if.true (ret.iloc 0 . 1))
       (touch.gloc.of bind-var!)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 171040)
       (push.const)
       (push.iloc.0 . 1)
       (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 171029))
     (push)
     (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 167947))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.car.iloc (1 . 0) "./boot/macro/synpat.scm" . 164905)
     (apply.gloc.of collect-unique-ids "./boot/macro/synpat.scm" . 164885))
   (push)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 164869))
 (set.gloc.of bind-null-ellipsis)
 (ret.const.unspec))
((close
   (5 0 . bind-ellipsis)
   (iloc.0 . 0)
   (if.null?
     (iloc.0 . 4)
     (if.null?
       (touch.gloc.of bind-null-ellipsis)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-null-ellipsis "./boot/macro/synpat.scm" . 177165))
     (touch.gloc.of union-vars)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 178189))
   (touch.gloc.of bind-ellipsis)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 179224)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 180262)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 180273)
     (push.iloc.0 . 2)
     (push.iloc.0 . 4)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 180248))
   (push)
   (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 179209))
 (set.gloc.of bind-ellipsis)
 (ret.const.unspec))
((close
   (6 0 . bind-ellipsis-n)
   (=n.iloc (0 . 3) 0 "./boot/macro/synpat.scm" . 184329)
   (if.true
     (touch.gloc.of union-vars)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 185353))
   (touch.gloc.of bind-ellipsis-n)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 186394)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.n+.iloc (0 . 3) -1 "./boot/macro/synpat.scm" . 186415)
   (push.iloc.0 . 4)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 187432)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 187443)
     (push.iloc.0 . 2)
     (push.iloc.0 . 5)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 187418))
   (push)
   (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 186377))
 (set.gloc.of bind-ellipsis-n)
 (ret.const.unspec))
((close
   (4 0 . bind-pattern)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 192528)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 194576))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 195596))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 196636)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 196648))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 197661)
       (if.symbol?
         (touch.gloc.of bind-var!)
         (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 198687)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 198676))
       (touch.gloc.of bind-ellipsis)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 199700))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 200732))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 200762)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 200750))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 200729)
     (extend . 1)
     (touch.gloc.of bind-pattern)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 201760)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 201779)
     (push.iloc.1 . 2)
     (call
       (call
         (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 202793)
         (if.false.ret)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 202810)
         (ret.subr.gloc.of symbol? "./boot/macro/synpat.scm" . 202801))
       (if.true
         (touch.gloc.of bind-var!)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 203823)
         (push.const)
         (push.iloc.1 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 203812))
       (touch.gloc.of bind-ellipsis-n)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 204836))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 201746))
   (iloc.0 . 1)
   (if.pair?
     (touch.gloc.of bind-pattern)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 206874)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 206885)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of bind-pattern)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 207912)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 207923)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 207898))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 206860))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 208908)
   (if.true
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 209946)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 209966)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 209932))
   (ret.iloc 0 . 3))
 (set.gloc.of bind-pattern)
 (ret.const.unspec))

;
((close
   (2 0 . collect-rename-ids)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 11287)
     (push.iloc 2 . 1)
     (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 11281)
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 12311)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 12305))
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13335)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13351)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 13345))
     (ret.cons "./boot/macro/syntmp.scm" . 13329))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.1 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 7184))
   (push)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 8199))
 (set.gloc.of collect-rename-ids)
 (ret.const.unspec))
((close
   (1 0 . parse-ellipsis-splicing)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 18469)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 18464))
     (if.true
       (push.n+.iloc (0 . 0) 1 "./boot/macro/syntmp.scm" . 19476)
       (push.cdr.iloc (0 . 1) "./boot/macro/syntmp.scm" . 19486)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 19470))
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-head 2 "./boot/macro/syntmp.scm" . 21526)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 21518))
   (push.const . 2)
   (push.iloc.1 . 0)
   (push.subr.gloc.of cdddr 1 "./boot/macro/syntmp.scm" . 17438)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 17413))
 (set.gloc.of parse-ellipsis-splicing)
 (ret.const.unspec))
((close
   (2 0 . check-template)
   (extend.unbound . 2)
   (push.close
     (2 0 . control-patvar-exists?)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 30742))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 30738))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 31762))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 32816))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 33827)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 33816))
           (if.true.ret)
           (call
             (push.iloc.0 . 0)
             (push.const . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 34845))
           (if.false.ret)
           (push.iloc.0 . 1)
           (push.iloc.1 . 1)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 35869))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 28681))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 36882))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 37916)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 37926)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 37910))
         (if.true.ret)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 38945)
           (push.const . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 38939))
         (if.false.ret)
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 39969)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 39963))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 40978))
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of rank-of)
               (push.iloc.0 . 0)
               (push.iloc 5 . 1)
               (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 42029))
             (push)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 42025))
           (call
             (touch.gloc.of collect-unique-ids)
             (push.iloc.0 . 0)
             (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 42056))
           (push)
           (apply.gloc.of any1 "./boot/macro/syntmp.scm" . 42006))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 43036)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 43030))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 45084)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 45078))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 46108)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 46102))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 47122)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 48152)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 48146))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 28681))
   (push.close
     (2 0 . check-escaped)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 55324))
         (push)
         (push.iloc 2 . 1)
         (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 55319)
         (if.false.ret)
         (push.const . "syntax template")
         (push.const . "too few ellipsis following subtemplate")
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 56343))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 58392)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 58386))
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 59416)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 59410))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 60434)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 61464)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 61458))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 53257))
   (enclose . 2)
   (call
     (call
       (touch.gloc.of safe-length)
       (push.iloc.1 . 0)
       (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 63505))
     (push)
     (push.const . 2)
     (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 63502)
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 63532)
     (const . ...)
     (ret.eq? "./boot/macro/syntmp.scm" . 63527))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 64536)
     (push.const . 0)
     (apply.iloc (0 . 1) "./boot/macro/syntmp.scm" . 64521))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (call
         (push.iloc.0 . 0)
         (const . ...)
         (if.not.eq?.ret.const . #f)
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 68631))
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 69658))
       (>.iloc (0 . 1) "./boot/macro/syntmp.scm" . 69655)
       (if.false.ret)
       (push.const . "syntax template")
       (push.const . "too few ellipsis following subtemplate")
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 70679))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 71698))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 72752))
       (push.close
         (3 0)
         (call
           (=n.iloc (1 . 1) 0 "./boot/macro/syntmp.scm" . 73753)
           (if.false.ret)
           (call
             (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 74805)
             (push.iloc.0 . 2)
             (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 74781))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 4 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 75805))
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 76831)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 76820))
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 77844))
       (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 65545))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 78866))
     (if.true
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 79906)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 80942)
           (push.iloc 3 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 80933))
         (push)
         (extend . 1)
         (<n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 81954)
         (if.true
           (push.const . "syntax template")
           (push.const . "misplace ellipsis following literal")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 83057)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 82978))
         (n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 84010)
         (<.iloc (0 . 0) "./boot/macro/syntmp.scm" . 84002)
         (if.true
           (push.const . "syntax template")
           (push.const . "too few ellipsis following subtemplate")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 85108)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 85026))
         (push.cddr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 87080)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 87074))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 88096)
       (if.pair?
         (call
           (=n.iloc (0 . 1) 0 "./boot/macro/syntmp.scm" . 89118)
           (if.false.ret)
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 90170)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 90180)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 90146))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 91276)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 91170))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 92191)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 92201)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 92185))
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 93215)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 93209))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 94240)
       (if.null?
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis following empty list")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 95257))
       (push.const . "syntax template")
       (push.const . "misplaced ellipsis following literal")
       (push.iloc 3 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 97385)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 97305))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 98322))
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 99361)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 99346))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 100376)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 100370))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 102424)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 102418))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 103448)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 103442))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 104466)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 105496)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 105490))
     (ret.const.unspec))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 65545))
 (set.gloc.of check-template)
 (ret.const.unspec))
((close
   (2 0 . rank-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 109585)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 110608))
   (ret.const . -1))
 (set.gloc.of rank-of)
 (ret.const.unspec))
((close
   (2 0 . subform-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 114698)
   (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 114693))
 (set.gloc.of subform-of)
 (ret.const.unspec))
((close
   (4 0 . collect-ellipsis-vars)
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 118800))
   (push)
   (extend . 1)
   (touch.gloc.of filter)
   (push.gloc.of values)
   (call
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 121889)
       (push.iloc.1 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syntmp.scm" . 121883)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 122930)
       (push.iloc 2 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 122924)
       (subr.gloc.of cdr 1 "./boot/macro/syntmp.scm" . 122919)
       (<.iloc (2 . 2) "./boot/macro/syntmp.scm" . 123940)
       (if.true (ret.iloc 0 . 0))
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124975)
       (cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124986)
       (ret.cons "./boot/macro/syntmp.scm" . 124969))
     (push.iloc.1 . 3)
     (apply.gloc.of map "./boot/macro/syntmp.scm" . 118789))
   (push)
   (apply.gloc.of filter "./boot/macro/syntmp.scm" . 118789))
 (set.gloc.of collect-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . consume-ellipsis-vars)
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 139299)
         (push.iloc 3 . 0)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 139290))
       (<.iloc (3 . 1) "./boot/macro/syntmp.scm" . 139287)
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140317)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140333)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 140327))
         (ret.cons "./boot/macro/syntmp.scm" . 140311))
       (push.iloc.0 . 0)
       (subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 141342)
       (if.null?
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 142365)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 142359))
       (push.iloc.0 . 0)
       (subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 143390)
       (if.null?
         (const . #t)
         (set.iloc 2 . 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 145437)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 145431))
       (call
         (call
           (touch.gloc.of circular-list?)
           (push.iloc.0 . 0)
           (push.subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 147499)
           (apply.gloc.of circular-list? "./boot/macro/syntmp.scm" . 147483))
         (if.true.ret)
         (const . #t)
         (set.iloc 2 . 1)
         (ret.const.unspec))
       (touch.gloc.of acons)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 148510)
       (push.iloc.0 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 148521)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 148539)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 148533))
       (push)
       (apply.gloc.of acons "./boot/macro/syntmp.scm" . 148503))
     (push.iloc 2 . 2)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 137230))
   (push)
   (extend . 1)
   (iloc.1 . 1)
   (if.true (iloc.1 . 0) (if.true.ret.const . #f) (ret.iloc 0 . 0))
   (iloc.1 . 0)
   (if.true.ret)
   (ret.const))
 (set.gloc.of consume-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . contain-rank-moved-var?)
   (extend.enclose+
     (2 0 . traverse-escaped)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 160791))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 160786))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 162844)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 162838))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 163868)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 163862))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 164882)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 165912)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 165906))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 158729))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (push.const . 0)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 171027))
       (push)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 171022))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 172046))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 173100))
       (push.close
         (3 0)
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 174111)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 174100))
         (if.true.ret)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 175124))
       (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 168965))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 176142))
     (if.true
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 177176)
         (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 177186)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 177170))
       (if.true.ret)
       (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 178200)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 178194))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 179214))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 180256)
       (push.iloc.0 . 1)
       (apply.iloc+ (2 . 0) "./boot/macro/syntmp.scm" . 180238))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 182296)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 182290))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 183320)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 183314))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 184334)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 185364)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 185358))
     (ret.const . #f))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 168965))
 (set.gloc.of contain-rank-moved-var?)
 (ret.const.unspec))
((close
   (1 0 . make-infinite-list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 197658)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of set-cdr! 2 "./boot/macro/syntmp.scm" . 198680)
   (ret.iloc 0 . 0))
 (set.gloc.of |make-infinite-list`6|)
 (close
   (3 0 . rewrite-template-ranks-vars)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (extend.unbound . 2)
   (push.close
     (2 0 . revealed)
     (push.const . 0)
     (call
       (touch.gloc.of rank-of)
       (push.iloc.0 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 202776))
     (push)
     (push.iloc.0 . 1)
     (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 202771)
     (if.true
       (push.const . "~a:~a")
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syntmp.scm" . 203842))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 3 "./boot/macro/syntmp.scm" . 203826)
       (push.subr.gloc.of string->symbol 1 "./boot/macro/syntmp.scm" . 203810)
       (extend . 1)
       (call
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syntmp.scm" . 204825)
         (if.true.ret)
         (extend.enclose+
           (2 0 . loop)
           (>n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 206882)
           (if.true
             (push.n+.iloc (0 . 0) -1 "./boot/macro/syntmp.scm" . 207912)
             (call
               (touch.gloc.of |make-infinite-list`6|)
               (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 207946)
               (apply.gloc.of |make-infinite-list`6| "./boot/macro/syntmp.scm" . 207926))
             (push)
             (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 207920)
             (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 207906))
           (push.iloc 5 . 0)
           (push.iloc 2 . 0)
           (push.iloc 3 . 1)
           (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syntmp.scm" . 209954)
           (push.iloc 5 . 1)
           (push.iloc 2 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syntmp.scm" . 210978))
         (push.iloc 2 . 1)
         (call
           (touch.gloc.of rank-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 205872))
         (push)
         (push.subr.gloc.of - 2 "./boot/macro/syntmp.scm" . 205863)
         (call
           (touch.gloc.of subform-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of subform-of "./boot/macro/syntmp.scm" . 205900))
         (push)
         (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 205849))
       (ret.iloc 0 . 0))
     (ret.iloc 0 . 0))
   (push.close
     (2 0 . traverse-escaped)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 219160))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 221220)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 221214))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 222244)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 222238))
         (ret.cons "./boot/macro/syntmp.scm" . 221208))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 223256)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 224300)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 224294))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 224280))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 217103))
   (enclose . 2)
   (call
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 230427))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 231451))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 232505))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 233520)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233509))
           (push)
           (push.const . ...)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233544))
           (push.cons)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 233501))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 228370))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 234523))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 235559)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 235569)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 235553))
         (push)
         (push.const . ...)
         (call
           (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 236594)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 236588))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/syntmp.scm" . 236577)
         (ret.cons "./boot/macro/syntmp.scm" . 235547))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 237595))
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 238625)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 239667)
           (push.iloc.0 . 1)
           (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 239649))
         (ret.cons "./boot/macro/syntmp.scm" . 238619))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 241703)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 241697))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 242727)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 242721))
         (ret.cons "./boot/macro/syntmp.scm" . 241691))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 243739)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 244783)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 244777))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 244763))
       (ret.iloc 0 . 0))
     (push.iloc 3 . 0)
     (push.const . 0)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 228370))
   (push)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 247843)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 247829)
   (push.iloc 2 . 2)
   (push.iloc.1 . 1)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 248866)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 248853)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 195595))
 (set.gloc.of |rewrite-template-ranks-vars`2|)
 (close
   (3 0 . adapt-to-rank-moved-vars)
   (call
     (touch.gloc.of contain-rank-moved-var?)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of contain-rank-moved-var? "./boot/macro/syntmp.scm" . 250889))
   (if.true
     (touch.gloc.of |rewrite-template-ranks-vars`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of |rewrite-template-ranks-vars`2| "./boot/macro/syntmp.scm" . 251913))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 252937))
 (set.gloc.of adapt-to-rank-moved-vars)
 (ret.const.unspec))
((close
   (1 0 . remove-duplicates)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 262172)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 262183)
       (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 262166)
       (if.true.ret.const . #f)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 263201)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 263195))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 260109))
   (if.true.ret)
   (touch.gloc.of |loop`13|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 264205))
 (set.gloc.of |remove-duplicates`2|)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 266268)
   (push.iloc.0 . 1)
   (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 266262)
   (if.true
     (touch.gloc.of |loop`13|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 267292)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 267286))
   (touch.gloc.of |loop`13|)
   (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269340)
   (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269356)
   (iloc.0 . 1)
   (push.cons)
   (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 269334))
 (set.gloc.of |loop`13|)
 (close
   (5 0 . transcribe-template)
   (push.close
     (0 0)
     (touch.gloc.of adapt-to-rank-moved-vars)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (call
       (touch.gloc.of |remove-duplicates`2|)
       (push.iloc.1 . 2)
       (apply.gloc.of |remove-duplicates`2| "./boot/macro/syntmp.scm" . 271440))
     (push)
     (apply.gloc.of adapt-to-rank-moved-vars "./boot/macro/syntmp.scm" . 271397))
   (push.close
     (3 0)
     (extend.unbound . 5)
     (push.close+
       (2 0 . expand-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 275474)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 277541)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 278569)
           (apply.iloc (4 . 4) "./boot/macro/syntmp.scm" . 278563))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 279587))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 281618)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 281618))
     (push.close+
       (2 0 . expand-ellipsis-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 286738)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 288805)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.iloc 4 . 4)
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 289837)
           (apply.gloc.of map "./boot/macro/syntmp.scm" . 289827))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 290851))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 292882)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 292882))
     (push.close
       (3 0 . expand-ellipsis-template)
       (extend.enclose+
         (2 0 . loop)
         (iloc.0 . 1)
         (if.pair?
           (call
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.iloc (3 . 4) "./boot/macro/syntmp.scm" . 300064))
           (push)
           (iloc.0 . 0)
           (push.cons)
           (call
             (touch.gloc.of consume-ellipsis-vars)
             (push.iloc 4 . 1)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.gloc.of consume-ellipsis-vars "./boot/macro/syntmp.scm" . 301082))
           (push)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 300052))
         (iloc.0 . 1)
         (if.null?.ret.const)
         (push.iloc.0 . 1)
         (const . #t)
         (if.eq? (push.iloc.0 . 0) (ret.subr.gloc.of reverse "./boot/macro/syntmp.scm" . 303141))
         (push.const . "syntax template")
         (push.const . "subforms have different size of matched input")
         (push.const . template:)
         (push.iloc 5 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 305172)
         (push.const . subforms:)
         (iloc 5 . 2)
         (push.cons)
         (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 305172))
       (push.const)
       (call
         (touch.gloc.of collect-ellipsis-vars)
         (push.iloc.1 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.gloc.of collect-ellipsis-vars "./boot/macro/syntmp.scm" . 298026))
       (push)
       (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 297995))
     (push.close+
       (3 0 . expand-escaped-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 311321))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 311318)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 312349)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 312342))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 313366))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 315441)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 315416))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 316465)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 316440))
         (ret.cons "./boot/macro/syntmp.scm" . 315410))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 317458)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 318521)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 318496))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 318482))
       (ret.iloc 0 . 0))
     (push.close
       (3 0 . expand-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 324633))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 324630)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 325661)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 325654))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 326678))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 327698))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 328752))
         (push.close
           (3 0)
           (call
             (push.gloc.of append)
             (call
               (push.iloc.0 . 0)
               (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 329801)
               (push.iloc.1 . 2)
               (apply.iloc (2 . 2) "./boot/macro/syntmp.scm" . 329770))
             (push)
             (apply.gloc.of apply "./boot/macro/syntmp.scm" . 329756))
           (push)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (push.iloc.1 . 2)
             (apply.iloc (2 . 4) "./boot/macro/syntmp.scm" . 330780))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 329748))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 322569))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 331794))
       (if.true
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 332834)
         (if.symbol?
           (call
             (touch.gloc.of rank-of)
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 333870)
             (push.iloc 2 . 1)
             (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 333861))
           (push)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 334890)
           (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 334882)
           (if.true
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 335935)
               (push.iloc.0 . 2)
               (apply.iloc+ (1 . 1) "./boot/macro/syntmp.scm" . 335914))
             (push)
             (call
               (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 336955)
               (push.iloc.0 . 1)
               (push.iloc.0 . 2)
               (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 336938))
             (push)
             (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 335906))
           (ret.const.unspec))
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 337952)
         (if.pair?
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 339003)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 339014)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 2) "./boot/macro/syntmp.scm" . 338977))
           (push)
           (call
             (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 340018)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 340001))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 338969))
         (ret.const.unspec))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 341010))
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 342065)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 342040))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 343081)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 343064))
         (ret.cons "./boot/macro/syntmp.scm" . 342034))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 345129)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 345112))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 346153)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 346136))
         (ret.cons "./boot/macro/syntmp.scm" . 345106))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 347154)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 348209)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 348192))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 348178))
       (ret.iloc 0 . 0))
     (enclose . 5)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.1 . 0)
         (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 351251))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 351248)
       (if.false.ret)
       (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 351278)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 351273))
     (if.true
       (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 352292)
       (push.const . 0)
       (push.iloc.1 . 2)
       (apply.iloc+ (0 . 3) "./boot/macro/syntmp.scm" . 352267))
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.1 . 2)
     (apply.iloc (0 . 4) "./boot/macro/syntmp.scm" . 353291))
   (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 259079))
 (set.gloc.of transcribe-template)
 (ret.const.unspec))

;
((close
   (2 0 . compiled->source)
   (push.const . syntax-rules)
   (push.iloc.0 . 0)
   (call
     (push.gloc.of |.fn2.1`2|)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 30753))
   (push)
   (ret.subr.gloc.of |.cons*| "./boot/macro/synrule.scm" . 29703))
 (set.gloc.of |compiled->source`2|)
 (close
   (2 0 . transcribe-compiled-templete)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 10265)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 11289)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/synrule.scm" . 13332))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/synrule.scm" . 14359))
   (push)
   (extend . 4)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 21536)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
           (push.iloc 2 . 3)
           (apply.gloc.of rename-id "./boot/macro/synrule.scm" . 21556))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/synrule.scm" . 21546))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synrule.scm" . 21530))
     (push.iloc 2 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/synrule.scm" . 12313)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 17426))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (apply.gloc.of transcribe-template "./boot/macro/synrule.scm" . 23573))
   (push)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 25634)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 25660)
         (apply.gloc.of env-lookup "./boot/macro/synrule.scm" . 25644))
       (ret.cons "./boot/macro/synrule.scm" . 25628))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 24597))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 23565))
 (set.gloc.of |transcribe-compiled-templete`2|)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 30773)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 30782)
   (ret.subr.gloc.of |.list| "./boot/macro/synrule.scm" . 30758))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . transcribe-syntax-rules)
   (call
     (iloc.0 . 0)
     (if.pair?.ret.const . #t)
     (push.iloc.0 . 0)
     (push.const . "misplaced syntactic keyword")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 33801))
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 35858)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 35878)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 1)
       (if.true
         (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 39971)
         (push.const . "invalid syntax")
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of put-annotation)
           (call
             (touch.gloc.of |compiled->source`2|)
             (push.iloc 2 . 0)
             (push.cddr.iloc (3 . 1) "./boot/macro/synrule.scm" . 40044)
             (apply.gloc.of |compiled->source`2| "./boot/macro/synrule.scm" . 40020))
           (push)
           (push.iloc 2 . 1)
           (apply.gloc.of put-annotation "./boot/macro/synrule.scm" . 40004))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 39953))
       (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 40995)
       (push.const . "invalid syntax")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 40977))
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 42010)
     (extend . 1)
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 43037)
     (extend . 1)
     (call
       (call
         (touch.gloc.of match-pattern?)
         (push.iloc 5 . 0)
         (push.iloc.0 . 0)
         (push.iloc 4 . 0)
         (apply.gloc.of match-pattern? "./boot/macro/synrule.scm" . 44063))
       (if.false.ret)
       (touch.gloc.of bind-pattern)
       (push.iloc 5 . 0)
       (push.iloc.0 . 0)
       (push.iloc 4 . 0)
       (push.const)
       (apply.gloc.of bind-pattern "./boot/macro/synrule.scm" . 45087))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (touch.gloc.of |transcribe-compiled-templete`2|)
       (push.cdr.iloc (2 . 0) "./boot/macro/synrule.scm" . 47153)
       (push.iloc.0 . 0)
       (apply.gloc.of |transcribe-compiled-templete`2| "./boot/macro/synrule.scm" . 47123))
     (push.cdr.iloc (3 . 0) "./boot/macro/synrule.scm" . 48153)
     (apply.iloc+ (4 . 0) "./boot/macro/synrule.scm" . 48147))
   (push.cddr.iloc (2 . 1) "./boot/macro/synrule.scm" . 35898)
   (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 36871))
 (set.gloc.of transcribe-syntax-rules)
 (ret.const.unspec))
((close
   (3 0 . parse-syntax-rule)
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 52244)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 52268)
   (extend . 2)
   (call
     (touch.gloc.of check-pattern)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of check-pattern "./boot/macro/synrule.scm" . 53255))
   (call
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.const)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synrule.scm" . 54292))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of check-template)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of check-template "./boot/macro/synrule.scm" . 55305))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of collect-rename-ids)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-rename-ids "./boot/macro/synrule.scm" . 56360))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 56329))
 (set.gloc.of parse-syntax-rule)
 (ret.const.unspec))
((close
   (1 0 . make-remark)
   (call
     (touch.gloc.of get-annotation)
     (push.iloc.0 . 0)
     (apply.gloc.of get-annotation "./boot/macro/synrule.scm" . 63504))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.const . |.&SOURCE-PATH|)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/synrule.scm" . 65563)
     (iloc.0 . 0)
     (ret.cons "./boot/macro/synrule.scm" . 65557))
   (ret.const . #f))
 (set.gloc.of |make-remark`2|)
 (close
   (4 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of list "./boot/macro/synrule.scm" . 73754))
 (set.gloc.of |.fn3.1`3|)
 (close
   (4 0 . compile-syntax-rules)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of |make-remark`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |make-remark`2| "./boot/macro/synrule.scm" . 70673))
   (push)
   (call
     (push.close
       (1 0)
       (push.close
         (0 0)
         (touch.gloc.of parse-syntax-rule)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (push.iloc 2 . 3)
         (apply.gloc.of parse-syntax-rule "./boot/macro/synrule.scm" . 72775))
       (push.gloc.of |.fn3.1`3|)
       (apply.gloc.of |.call-with-values| "./boot/macro/synrule.scm" . 71702))
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 61445))
   (push)
   (subr.gloc.of cons 2 "./boot/macro/synrule.scm" . 61445)
   (ret.cons "./boot/macro/synrule.scm" . 61445))
 (set.gloc.of compile-syntax-rules)
 (ret.const.unspec))

;
((push.const . |.patvars|)
 (push.const)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 14337))
((close
   (3 0 . make-syntax-object)
   (push.const . type:syntax)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 16446))
 (set.gloc.of make-syntax-object)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-expr)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 17453))
 (set.gloc.of syntax-object-expr)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-renames)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 18477))
 (set.gloc.of syntax-object-renames)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-lexname)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 19501))
 (set.gloc.of syntax-object-lexname)
 (ret.const.unspec))
((close
   (1 0 . wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 23562)
   (const . type:syntax)
   (ret.eq? "./boot/macro/syncase.scm" . 23557))
 (set.gloc.of wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (2 0 . lookup-lexical-name)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 27665))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of renamed-id?)
     (push.iloc.0 . 0)
     (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 28686))
   (if.true (ret.iloc 0 . 0))
   (call
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/syncase.scm" . 29715))
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 29729))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 28679))
   (ret.iloc 2 . 0))
 (set.gloc.of lookup-lexical-name)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 36888)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 36882))
     (if.true.ret)
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 36905)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 36899))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 37902)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 39957)
       (if.false.ret)
       (call
         (touch.gloc.of |loop`5|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 40991)
         (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 40985))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 42016)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 42009))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 38944)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 38941)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 38926))
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 44046))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . contain-wrapped-syntax-object?)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 34821))
 (set.gloc.of contain-wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 50200)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 50194))
     (if.true.ret)
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 50217)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 50211))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 51214)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 53269)
       (if.false.ret)
       (call
         (touch.gloc.of |loop`5|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 54303)
         (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 54297))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 55328)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 55321))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 52256)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 52253)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 52238))
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 56334))
   (if.true.ret.const . #f)
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 58382))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . contain-non-id-wrapped-syntax-object?)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 48133))
 (set.gloc.of contain-non-id-wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (1 0 . unwrap-syntax)
   (call
     (touch.gloc.of contain-non-id-wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of contain-non-id-wrapped-syntax-object? "./boot/macro/syncase.scm" . 62476))
   (if.true
     (call
       (subr.gloc.of make-core-hashtable 0)
       (push)
       (extend . 1)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.pair?
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 67620)
               (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 67614))
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 68644)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 68638))
           (push.iloc.0 . 0)
           (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 69662)
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 70701)
             (apply.gloc.of for-each "./boot/macro/syncase.scm" . 70686))
           (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 71710))
           (if.true
             (call
               (touch.gloc.of syntax-object-renames)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 72748))
             (push)
             (extend . 1)
             (iloc.0 . 0)
             (if.null?.ret.const . #t)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 74817)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 74788)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 75836)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 75849)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 75812))
           (call
             (touch.gloc.of wrapped-syntax-object?)
             (push.iloc.0 . 0)
             (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 76830))
           (if.true
             (call
               (push.close
                 (1 0)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 78923)
                 (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 78894)
                 (if.true.ret)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 79942)
                 (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 79950)
                 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 79918))
               (call
                 (touch.gloc.of syntax-object-renames)
                 (push.iloc.0 . 0)
                 (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 80936))
               (push)
               (apply.gloc.of for-each "./boot/macro/syncase.scm" . 77854))
             (call
               (touch.gloc.of syntax-object-expr)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 81956))
             (push)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 81950))
           (ret.const.unspec))
         (push.iloc 2 . 0)
         (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 65557))
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable->alist "./boot/macro/syncase.scm" . 82965))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 86054)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 86048))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 86075)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 86069))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 87084)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 87102)
           (ret.eq? "./boot/macro/syncase.scm" . 87095))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 88101))
       (iloc.0 . 0)
       (if.symbol?
         (touch.gloc.of make-syntax-object)
         (push.iloc.0 . 0)
         (call
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 90163)
           (if.true.ret)
           (ret.const))
         (push)
         (push.const . #f)
         (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 90135))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 91159))
       (if.true
         (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 92190))
         (if.true (ret.iloc 0 . 0))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 93225))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 93219))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 94231)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 95279)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 95269))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 95255))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 83982))
   (ret.iloc 0 . 0))
 (set.gloc.of unwrap-syntax)
 (ret.const.unspec))
((close
   (2 0 . identical-global-macro?)
   (call
     (touch.gloc.of macro?)
     (push.iloc.0 . 0)
     (apply.gloc.of macro? "./boot/macro/syncase.scm" . 104462))
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 105496)
   (ret.eq? "./boot/macro/syncase.scm" . 105486))
 (set.gloc.of |identical-global-macro?`2|)
 (close
   (2 0 . unrename-syntax)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (touch.gloc.of annotated?)
         (push.iloc.0 . 0)
         (apply.gloc.of annotated? "./boot/macro/syncase.scm" . 109586))
       (if.true
         (touch.gloc.of annotate)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 110632)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 110626))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 110649)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 110643))
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 110610))
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 111646)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 111640))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 111663)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 111657))
       (ret.cons "./boot/macro/syncase.scm" . 111634))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 113690))
       (push)
       (call
         (touch.gloc.of original-id)
         (push.iloc.0 . 0)
         (apply.gloc.of original-id "./boot/macro/syncase.scm" . 114712))
       (push)
       (extend . 2)
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/syncase.scm" . 115735))
       (if.true (ret.iloc 0 . 1))
       (call
         (touch.gloc.of |identical-global-macro?`2|)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of |identical-global-macro?`2| "./boot/macro/syncase.scm" . 116759))
       (if.true (ret.iloc 0 . 1))
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 118798)
     (if.true
       (call
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 119846)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 119836))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 119822))
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 107525))
 (set.gloc.of unrename-syntax)
 (ret.const.unspec))
((close
   (1 0)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 129062)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 129056))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 129083)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 129077))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 130092)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 130110)
           (ret.eq? "./boot/macro/syncase.scm" . 130103))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 131109))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 132119)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 133167)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 133157))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 133143))
       (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 134167))
       (if.true
         (call
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 135205))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?.ret.const . #t)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 137278)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 137249)
           (if.true.ret)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 138297)
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 138310)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 138273))
         (touch.gloc.of syntax-object-expr)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 139287))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 140311))
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 142404)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 142375)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 143423)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 143431)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 143399))
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 144417))
           (push)
           (apply.gloc.of for-each "./boot/macro/syncase.scm" . 141335))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 145437))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 145431))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 126990))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 147478)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 124933))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.flatten-syntax|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 123907))
((close
   (3 1)
   (extend.enclose+
     (2 0 . match)
     (call
       (touch.gloc.of match-pattern?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/syncase.scm" . 154638))
     (if.false.ret)
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc 2 . 2)
     (push.const)
     (apply.gloc.of bind-pattern "./boot/macro/syncase.scm" . 155662))
   (call
     (touch.gloc.of unwrap-syntax)
     (push.iloc.1 . 1)
     (apply.gloc.of unwrap-syntax "./boot/macro/syncase.scm" . 157713))
   (push)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (call
         (iloc 2 . 0)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (ret.subr.gloc.of car "./boot/macro/syncase.scm" . 160817))
       (push)
       (push.const . "invalid syntax")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 160781))
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 161819)
     (push.subr.gloc.of cadr 1 "./boot/macro/syncase.scm" . 163869)
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 161819)
     (push.subr.gloc.of caddr 1 "./boot/macro/syncase.scm" . 164891)
     (extend . 2)
     (call
       (push.iloc 3 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 161819)
       (push.subr.gloc.of car 1 "./boot/macro/syncase.scm" . 162842)
       (apply.iloc+ (4 . 0) "./boot/macro/syncase.scm" . 165917))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.1 . 0)
       (if.false.ret.const . #t)
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 169000)
       (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 168992))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 170013)
       (apply.iloc (1 . 1) "./boot/macro/syncase.scm" . 170007))
     (push.cdr.iloc (2 . 0) "./boot/macro/syncase.scm" . 171037)
     (apply.iloc+ (3 . 0) "./boot/macro/syncase.scm" . 171031))
   (push.iloc 3 . 3)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 158727))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax-dispatch|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 149505))
((close
   (1 0 . emit)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 178192))
   (if.true (ret.iloc 0 . 0))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 179221))
 (set.gloc.of |emit`2|)
 (close
   (2 0 . partial-wrap-syntax-object)
   (extend.enclose+
     (1 0 . loop)
     (call
       (touch.gloc.of contain-wrapped-syntax-object?)
       (push.iloc.0 . 0)
       (apply.gloc.of contain-wrapped-syntax-object? "./boot/macro/syncase.scm" . 184338))
     (if.true
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 186408)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 186402))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 186429)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 186423))
         (push)
         (extend . 2)
         (call
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 187436)
           (iloc.0 . 0)
           (if.not.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 187454)
           (iloc.0 . 1)
           (ret.eq? "./boot/macro/syncase.scm" . 187449))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 188455))
       (ret.iloc 0 . 0))
     (iloc.0 . 0)
     (if.symbol?
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 191534)
         (if.true.ret)
         (ret.const))
       (push)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 191506))
     (call
       (iloc.0 . 0)
       (if.pair?.ret.const . #t)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of vector? "./boot/macro/syncase.scm" . 192546))
     (if.true
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 193554))
     (iloc.0 . 0)
     (if.null?.ret.const)
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 196626))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 183305))
 (set.gloc.of |partial-wrap-syntax-object`2|)
 (close
   (5 0)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 199693))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/syncase.scm" . 201741))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of rename-id "./boot/macro/syncase.scm" . 203816))
       (ret.cons "./boot/macro/syncase.scm" . 203807))
     (call
       (touch.gloc.of collect-rename-ids)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 204818))
     (push)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 203789))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 206886)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 206916)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 206896))
       (ret.cons "./boot/macro/syncase.scm" . 206880))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 206861))
   (push)
   (extend . 1)
   (call
     (iloc 4 . 4)
     (if.null? (ret.const))
     (iloc 3 . 0)
     (if.null?.ret.const)
     (touch.gloc.of filter)
     (push.gloc.of values)
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 215085)
         (push.iloc 5 . 4)
         (push.subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 216108)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 215085)
             (push.iloc 5 . 0)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 218173))
           (push)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 218206)
           (if.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 219203)
           (call
             (touch.gloc.of make-out-of-context)
             (push.iloc 6 . 1)
             (apply.gloc.of make-out-of-context "./boot/macro/syncase.scm" . 219211))
           (ret.cons "./boot/macro/syncase.scm" . 219197))
         (ret.const . #f))
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 198661))
     (push)
     (apply.gloc.of filter "./boot/macro/syncase.scm" . 198661))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc 5 . 1)
     (push.iloc 5 . 2)
     (push.iloc 5 . 0)
     (push.iloc 2 . 0)
     (push.gloc.of |emit`2|)
     (apply.gloc.of transcribe-template "./boot/macro/syncase.scm" . 222227))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 225325)
       (if.true.ret)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 225352)
       (if.true.ret)
       (ret.const))
     (push)
     (push.iloc 6 . 3)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 225296))
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 226320))
   (if.true
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 227355))
     (if.null?.ret.const)
     (ret.iloc 0 . 0))
   (touch.gloc.of |partial-wrap-syntax-object`2|)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of extend-env)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 229425))
   (push)
   (apply.gloc.of |partial-wrap-syntax-object`2| "./boot/macro/syncase.scm" . 229392))
 (set.gloc.of |.fn2.1`2|)
 (push.const . |.syntax-transcribe|)
 (push.gloc.of |.fn2.1`2|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 177159))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
   (call
     (touch.gloc.of make-pattern-variable)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (apply.gloc.of make-pattern-variable "./boot/macro/syncase.scm" . 234501))
   (ret.cons "./boot/macro/syncase.scm" . 234501))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 237610)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 237604))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 237627)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 237621))
       (ret.cons "./boot/macro/syncase.scm" . 237598))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 238629))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 237579))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 239634)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 239672)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 239662))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 239648))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 236553))
 (set.gloc.of |rewrite`2|)
 (close
   (2 0 . expand-syntax-case)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 234501)
     (ret.subr.gloc.of |.list?| "./boot/macro/syncase.scm" . 234501))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 234501)
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (extend . 2)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/syncase.scm" . 234501)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 234501))
     (push)
     (extend . 1)
     (call
       (call
         (push.iloc.0 . 0)
         (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 234501)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 0)
         (apply.gloc.of every1 "./boot/macro/syncase.scm" . 234501))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "invalid literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 0)
         (apply.gloc.of unique-id-list? "./boot/macro/syncase.scm" . 234501))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "duplicate literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (push.const . _)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 234501)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "_ in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (push.const . ...)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 234501)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "... in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of lookup-lexical-name)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 234501))
         (ret.cons "./boot/macro/syncase.scm" . 234501))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 234501))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of |rewrite`2|)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of |rewrite`2| "./boot/macro/syncase.scm" . 234501))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . parse-pattern)
       (call
         (touch.gloc.of |rewrite`2|)
         (call
           (touch.gloc.of unrename-syntax)
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 234501))
         (push)
         (push.iloc 3 . 0)
         (apply.gloc.of |rewrite`2| "./boot/macro/syncase.scm" . 234501))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 234501))
       (call
         (touch.gloc.of check-pattern)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of check-pattern "./boot/macro/syncase.scm" . 234501))
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of |.fn1.1`1|)
           (call
             (touch.gloc.of collect-vars-ranks)
             (push.iloc.0 . 0)
             (push.iloc 3 . 0)
             (push.const . 0)
             (push.const)
             (apply.gloc.of collect-vars-ranks "./boot/macro/syncase.scm" . 234501))
           (push)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 234501))
         (push)
         (push.iloc 7 . 1)
         (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 234501))
       (push)
       (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 234501))
     (touch.gloc.of annotate)
     (push.const . |.syntax-dispatch|)
     (call
       (touch.gloc.of expand-form)
       (push.const . |.patvars|)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
     (push)
     (call
       (touch.gloc.of expand-form)
       (push.iloc 4 . 1)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
     (push)
     (push.const . quote)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 234501)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
           (ret.pair? "./boot/macro/syncase.scm" . 234501))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
           (ret.null? "./boot/macro/syncase.scm" . 234501))
         (if.true
           (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
           (extend . 2)
           (push.close
             (0 0)
             (push.iloc.1 . 1)
             (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 234501))
           (push.close
             (2 0)
             (push.const . |.list|)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 234501)
             (push.const . #f)
             (call
               (touch.gloc.of expand-form)
               (push.const . |.LAMBDA|)
               (push.const |.patvars|)
               (push.iloc.1 . 0)
               (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 234501)
               (push.iloc.0 . 1)
               (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/syncase.scm" . 234501))
           (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 234501))
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 234501)
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.caddr| 1 "./boot/macro/syncase.scm" . 234501)
         (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
         (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
         (extend . 3)
         (push.close
           (0 0)
           (push.iloc.1 . 2)
           (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 234501))
         (push.close
           (2 0)
           (push.const . |.list|)
           (push.const . quote)
           (push.iloc.0 . 0)
           (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 234501)
           (call
             (touch.gloc.of expand-form)
             (push.const . |.LAMBDA|)
             (push.const |.patvars|)
             (push.iloc.1 . 1)
             (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 234501)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
           (push)
           (call
             (touch.gloc.of expand-form)
             (push.const . |.LAMBDA|)
             (push.const |.patvars|)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 234501)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
           (push)
           (ret.subr.gloc.of |.list| "./boot/macro/syncase.scm" . 234501))
         (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 234501))
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 234501))
     (push)
     (push.subr.gloc.of |.cons*| 5 "./boot/macro/syncase.scm" . 234501)
     (push.iloc 4 . 1)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 234501))
   (push.const . syntax-case)
   (push.const . "invalid syntax")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
 (set.gloc.of expand-syntax-case)
 (ret.const.unspec))
((close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 299050)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 299044))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 299067)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 299061))
       (ret.cons "./boot/macro/syncase.scm" . 299038))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 300069))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 299019))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 301074)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 301112)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 301102))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 301088))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 297993))
 (set.gloc.of |rewrite`2|)
 (close
   (2 0 . expand-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
     (ret.null? "./boot/macro/syncase.scm" . 295941))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
     (extend . 1)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 295941))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of pattern-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of pattern-variable? "./boot/macro/syncase.scm" . 295941))
           (if.false.ret)
           (push.iloc.1 . 0)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
           (ret.cons "./boot/macro/syncase.scm" . 295941))
         (call
           (touch.gloc.of collect-unique-ids)
           (push.iloc.0 . 0)
           (apply.gloc.of collect-unique-ids "./boot/macro/syncase.scm" . 295941))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 295941))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.iloc.0 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 295941))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of renamed-id?)
             (push.iloc.0 . 0)
             (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 295941))
           (if.false.ret)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (if.eq?.ret.const . #f)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (ret.cons "./boot/macro/syncase.scm" . 295941))
         (call
           (touch.gloc.of collect-rename-ids)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 295941))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 295941))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of check-template)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of check-template "./boot/macro/syncase.scm" . 295941))
     (call
       (iloc 3 . 0)
       (if.not.symbol?.ret.const . #f)
       (touch.gloc.of lookup-lexical-name)
       (push.iloc 3 . 0)
       (push.iloc 4 . 1)
       (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (touch.gloc.of annotate)
     (push.const . |.syntax-transcribe|)
     (call
       (touch.gloc.of expand-form)
       (push.const . |.patvars|)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 295941))
     (push)
     (push.const . quote)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.const . quote)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.const . quote)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.const . quote)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.subr.gloc.of |.list| 6 "./boot/macro/syncase.scm" . 295941)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 295941))
   (push.const . syntax)
   (push.const . "expected exactly one datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 295941))
 (set.gloc.of expand-syntax)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 334878)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 334872))
     (push)
     (call
       (touch.gloc.of |loop`5|)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 334899)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 334893))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 335908)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 335926)
       (ret.eq? "./boot/macro/syncase.scm" . 335919))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 336925))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 337935)
   (if.true
     (call
       (push.gloc.of |loop`5|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 338983)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 338973))
     (push)
     (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 338959))
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 339983))
   (if.true
     (touch.gloc.of |loop`5|)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 341013))
     (push)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 341007))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . syntax->datum)
   (touch.gloc.of strip-rename-suffix)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 332806))
   (push)
   (apply.gloc.of strip-rename-suffix "./boot/macro/syncase.scm" . 332806))
 (set.gloc.of syntax->datum)
 (ret.const.unspec))
((close
   (2 0 . datum->syntax)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 346121))
   (if.false.call
     (push.const . datum->syntax)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 347181)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 347145))
   (call
     (touch.gloc.of retrieve-rename-suffix)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 348203))
     (push)
     (apply.gloc.of retrieve-rename-suffix "./boot/macro/syncase.scm" . 348179))
   (push)
   (call
     (call
       (touch.gloc.of syntax-object-renames)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 349211))
     (if.null?
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 350228))
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 351252))
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 4)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 356391)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 356385))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 356408)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 356402))
         (ret.cons "./boot/macro/syncase.scm" . 356379))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 357403)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 358451)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 358441))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 358427))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 2)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 360482)
         (if.true.ret)
         (push.iloc.0 . 0)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/syncase.scm" . 362572)
         (push.iloc 2 . 0)
         (push.subr.gloc.of string-append 2 "./boot/macro/syncase.scm" . 362557)
         (push.subr.gloc.of string->symbol 1 "./boot/macro/syncase.scm" . 362541)
         (extend . 1)
         (push.iloc 3 . 2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syncase.scm" . 363556)
         (call
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 364598))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc.1 . 0)
           (if.eq?
             (push.iloc 4 . 3)
             (push.iloc.1 . 0)
             (call
               (touch.gloc.of env-lookup)
               (push.iloc 4 . 1)
               (push.iloc 2 . 0)
               (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 367690))
             (push)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 367661))
           (push.iloc 4 . 3)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 370733))
         (ret.iloc 0 . 0))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 354322))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 374835)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 374825)
       (if.true.ret)
       (ret.const))
     (push)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 374797))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.iloc.1 . 3)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 375845)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 375821))
 (set.gloc.of datum->syntax)
 (ret.const.unspec))
((close
   (1 0 . identifier?)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 379914))
   (if.false.ret)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 380947))
   (push)
   (ret.subr.gloc.of symbol? "./boot/macro/syncase.scm" . 380938))
 (set.gloc.of identifier?)
 (ret.const.unspec))
((close
   (2 0 . bound-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 385033))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 386098)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 386057))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 387081))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 388146)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 388105))
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 389130))
   (push)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 389155))
   (ret.eq? "./boot/macro/syncase.scm" . 389125))
 (set.gloc.of bound-identifier=?)
 (ret.const.unspec))
((close
   (2 0 . free-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 393225))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 394289)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 394249))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 395273))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 396337)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 396297))
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 397328))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 398354))
   (push)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 399378))
   (push)
   (call
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 400423))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 400402))
   (push)
   (call
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.1 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 401447))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 401426))
   (push)
   (extend . 4)
   (call (iloc.0 . 0) (if.false.ret) (ret.iloc 0 . 1))
   (if.true (push.iloc.0 . 0) (iloc.0 . 1) (ret.eq? "./boot/macro/syncase.scm" . 403469))
   (push.iloc.0 . 2)
   (iloc.0 . 3)
   (if.eq?.ret.const . #t)
   (push.iloc.0 . 0)
   (iloc.0 . 3)
   (if.eq?.ret.const . #t)
   (push.iloc.0 . 2)
   (iloc.0 . 1)
   (ret.eq? "./boot/macro/syncase.scm" . 406545))
 (set.gloc.of free-identifier=?)
 (ret.const.unspec))
((close
   (1 0)
   (touch.gloc.of make-syntax-object)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syncase.scm" . 412714))
   (push)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 412694))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0 . generate-temporaries)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 410633)
   (if.false.call
     (push.const . generate-temporaries)
     (push.const . "expected list, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 411700)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 411657))
   (push.gloc.of |.fn1.1`1|)
   (push.iloc.0 . 0)
   (apply.gloc.of map "./boot/macro/syncase.scm" . 412677))
 (set.gloc.of generate-temporaries)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer)
   (touch.gloc.of make-variable-transformer-token)
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 418834))
       (if.true (ret.iloc 0 . 0))
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 420882))
     (push)
     (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 418824))
   (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 416773))
 (set.gloc.of make-variable-transformer)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer-token)
   (push.const . type:variable-transformer-token)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 424965))
 (set.gloc.of make-variable-transformer-token)
 (ret.const.unspec))
((close
   (1 0 . variable-transformer-token?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 429066)
   (const . type:variable-transformer-token)
   (ret.eq? "./boot/macro/syncase.scm" . 429061))
 (set.gloc.of variable-transformer-token?)
 (ret.const.unspec))
((close
   (1 0)
   (push.close
     (1 0 . thunk)
     (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (2 . 0) "./boot/macro/syncase.scm" . 435232))
     (push.gloc.of |.fn2.1`2|)
     (apply.gloc.of call-with-values "./boot/macro/syncase.scm" . 434196))
   (extend . 1)
   (push.iloc.1 . 0)
   (subr.gloc.of procedure? 1 "./boot/macro/syncase.scm" . 440334)
   (if.true
     (push.close
       (0 0)
       (touch.gloc.of closure-arity)
       (push.iloc 2 . 0)
       (apply.gloc.of closure-arity "./boot/macro/syncase.scm" . 441384))
     (push.close
       (2 0)
       (=n.iloc (0 . 0) 1 "./boot/macro/syncase.scm" . 442389)
       (if.false.ret)
       (=n.iloc (0 . 1) 0 "./boot/macro/syncase.scm" . 442401)
       (if.false.ret)
       (ret.iloc 1 . 0))
     (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 433157))
   (call
     (touch.gloc.of variable-transformer-token?)
     (push.iloc.1 . 0)
     (apply.gloc.of variable-transformer-token? "./boot/macro/syncase.scm" . 443406))
   (if.true
     (push.iloc.1 . 0)
     (push.const . 1)
     (subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 444441)
     (set.iloc 1 . 0)
     (touch.gloc.of make-variable-transformer-token)
     (push.iloc.0 . 0)
     (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 445454))
   (ret.iloc 1 . 0))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 1)
   (iloc.0 . 1)
   (if.null?
     (push.iloc.0 . 0)
     (apply.gloc.of |.flatten-syntax| "./boot/macro/syncase.scm" . 438299))
   (push.iloc.0 . 0)
   (push.car.iloc (0 . 1) "./boot/macro/syncase.scm" . 439335)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 439323))
 (set.gloc.of |.fn2.1`2|)
 (push.const . |.transformer-thunk|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 432131))

;
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/library.scm" . 5150))
 (set.gloc.of scheme-library-paths)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 6176))
 (set.gloc.of scheme-library-exports)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 7201))
 (set.gloc.of scheme-library-versions)
 (ret.const.unspec))
((close
   (2 0 . symbol-list->string)
   (push.gloc.of string-append)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 14371)
       (if.symbol?
         (push.iloc 2 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 16438)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/library.scm" . 16422)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 17452)
           (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 17446))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/library.scm" . 16416)
         (ret.cons "./boot/macro/library.scm" . 15386))
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 19488)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 19482))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 12305))
   (push)
   (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 10243)
   (apply.gloc.of apply "./boot/macro/library.scm" . 10243))
 (set.gloc.of symbol-list->string)
 (ret.const.unspec))
((close
   (1 0 . generate-library-id)
   (touch.gloc.of library-name->id)
   (push.const . #f)
   (push.iloc.0 . 0)
   (apply.gloc.of library-name->id "./boot/macro/library.scm" . 23557))
 (set.gloc.of generate-library-id)
 (ret.const.unspec))
((close
   (2 0 . library-name->id)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.true
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 31809))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 31757))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 32781))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 34830)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 34848)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 34843))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 35853))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.1 . 1)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 36919))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 36893))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 36877))
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 37932)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 37929)
     (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 37913)
     (extend . 1)
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 38931))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 39997))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 39971))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 39955))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 40979))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 41993))
 (set.gloc.of library-name->id)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 55310)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 55325)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 55338))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (2 0 . library-name->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 50244))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 50189))
     (push.const . library)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 51213))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 57358)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 57376)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 57371))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 58384))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 60468)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 60465)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 60449)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 60444)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?.ret.const . #f)
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 62494)
       (if.false.ret)
       (touch.gloc.of every1)
       (push.gloc.of |exact-nonnegative-integer?`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 62507))
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 63518))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 64521))
 (set.gloc.of library-name->version)
 (ret.const.unspec))
((close
   (2 0 . library-reference->name)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 72769))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 72717))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 73741))
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.1 . 1)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 75788))
   (if.true (ret.iloc 1 . 1))
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 77866)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 77863)
   (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 77848)
   (extend . 1)
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 78869))
   (if.true (ret.iloc 0 . 0))
   (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 79898))
 (set.gloc.of library-reference->name)
 (ret.const.unspec))
((close
   (2 0 . flatten-library-reference)
   (call
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 83982)
       (if.false.ret)
       (push.iloc.0 . 1)
       (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 83999)
       (ret.subr.gloc.of not "./boot/macro/library.scm" . 83994))
     (if.true.ret)
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 85053))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 85001))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 83973)
     (if.false.ret)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (touch.gloc.of flatten-library-reference)
     (push.iloc.0 . 0)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 83973))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 83973))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 83973))
   (ret.iloc 0 . 1))
 (set.gloc.of flatten-library-reference)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 102414)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 102429)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 102442))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (2 0 . library-reference->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . import)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 97347))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 97293))
     (push.const . import)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 98317))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 104462)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 104479)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 104474))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 105488))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 106552)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 106549)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 106534)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 106529)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 107550)
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 108579))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 109577))
 (set.gloc.of library-reference->version)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 116750)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 116765)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 116778))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (4 0 . test-library-versions)
   (call
     (extend.enclose
       (1 0 . loop)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 119819)
         (ret.subr.gloc.of |.list?| "./boot/macro/library.scm" . 119819))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.null?.ret.const . #f)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . not)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (call
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
           (apply.iloc (2 . 0) "./boot/macro/library.scm" . 119819))
         (push)
         (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . or)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . and)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of every1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
       (extend.enclose
         (2 0 . loop)
         (call
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/macro/library.scm" . 119819)
             (if.false.ret)
             (push.iloc.0 . 1)
             (ret.subr.gloc.of list? "./boot/macro/library.scm" . 119819))
           (if.true.ret)
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 5 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (iloc.0 . 1)
         (if.null?.ret.const . #t)
         (push.iloc.0 . 0)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (subr.gloc.of >= 2 "./boot/macro/library.scm" . 119819)
         (if.false.ret)
         (touch.gloc.of every2)
         (push.close
           (2 0)
           (call
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (0 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of |.list?| "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 1)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (ret.null? "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . not)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (call
               (push.iloc 2 . 0)
               (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
               (apply.iloc (4 . 0) "./boot/macro/library.scm" . 119819))
             (push)
             (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . >=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of >= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . <=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of <= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . and)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of every1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . or)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of any1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
           (call
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.iloc 2 . 1)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (ret.subr.gloc.of = "./boot/macro/library.scm" . 119819))
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 8 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 8 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (apply.gloc.of every2 "./boot/macro/library.scm" . 119819))
       (push.iloc 4 . 3)
       (push.iloc 2 . 0)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 119819))
     (push.iloc.1 . 2)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 118793))
   (if.true.ret)
   (push.const . import)
   (push.const . "mismatch between version reference ~a and current version ~a")
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 142363)
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 143387))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 141321))
 (set.gloc.of test-library-versions)
 (ret.const.unspec))
((close
   (1 0 . make-shield-id-table)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (call
     (touch.gloc.of make-unbound)
     (apply.gloc.of make-unbound "./boot/macro/library.scm" . 147500))
   (push)
   (extend . 2)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 150550)
           (apply.iloc (1 . 0) "./boot/macro/library.scm" . 150544))
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 151574)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 151568))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 153616))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/library.scm" . 154640)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/library.scm" . 155670)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 155664))
       (ret.const.unspec))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 148487))
   (ret.iloc 0 . 0))
 (set.gloc.of make-shield-id-table)
 (ret.const.unspec))
((close
   (3 0 . verify-no-unbound-id)
   (extend.enclose
     (1 0 . find-expression)
     (push.close
       (1 0)
       (extend.enclose
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (if.eq?.ret.const . #t)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 167978)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 167972)
         (if.true.ret.const . #f)
         (call
           (touch.gloc.of any1)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 168991))
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 170015))
       (call
         (push.car.iloc (4 . 1) "./boot/macro/library.scm" . 164909)
         (const . begin)
         (if.eq? (push.iloc 4 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 164927))
         (ret.iloc 4 . 1))
       (push)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 164884))
     (apply.gloc.of call/cc "./boot/macro/library.scm" . 162823))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (call
       (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 173088)
       (const . begin)
       (if.eq? (push.iloc 2 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 173106))
       (ret.iloc 2 . 1))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 174110))
       (iloc.0 . 0)
       (if.pair?
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 176154)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 176148)
         (if.true.ret)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of for-each "./boot/macro/library.scm" . 177172))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 173063))
   (call
     (touch.gloc.of every1)
     (push.close
       (1 0)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 179238)
         (call
           (touch.gloc.of current-primitive-prefix)
           (apply.gloc.of current-primitive-prefix "./boot/macro/library.scm" . 179246))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 179221))
       (if.true.ret)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 180262)
         (call
           (touch.gloc.of current-rename-delimiter)
           (apply.gloc.of current-rename-delimiter "./boot/macro/library.scm" . 180270))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 180245))
       (if.true.ret)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 181286)
         (call
           (touch.gloc.of current-library-suffix)
           (apply.gloc.of current-library-suffix "./boot/macro/library.scm" . 181294))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 181269))
       (if.true.ret)
       (push.iloc 3 . 2)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 182327)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 182293)
       (if.true.ret)
       (call
         (touch.gloc.of current-macro-expression)
         (push.const . #f)
         (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 184343))
       (push.const . #f)
       (push.const . "attempt to reference unbound variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 186460)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 186409)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 187433))
       (push)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 188474)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 188457))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 185367))
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 189455)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 178183))
   (ret.iloc 2 . 1))
 (set.gloc.of verify-no-unbound-id)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 195591))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 195591))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
   (cadr.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
   (ret.cons "./boot/macro/library.scm" . 195591))
 (set.gloc.of |.fn3.1`3|)
 (close
   (2 0 . parse-exports)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (push.iloc.0 . 1) (ret.subr.gloc.of reverse "./boot/macro/library.scm" . 195591))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 195591))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 195591))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 195591))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 195591)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 195591))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 195591)
       (extend . 2)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of |.fn2.1`2|)
           (push.iloc.0 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 195591))
         (if.true.ret)
         (push.const . export)
         (push.const . "malformed export spec")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 195591))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 195591)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 195591))
       (push.iloc.0 . 0)
       (call
         (push.gloc.of |.fn3.1`3|)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/library.scm" . 195591))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 195591)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 195591))
     (push.const . export)
     (push.const . "malformed export spec")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 2 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 195591))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 195591)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 195591))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 194565))
 (set.gloc.of parse-exports)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 229383))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 229383))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . parse-imports)
   (extend.unbound . 2)
   (push.close
     (3 0 . check-unbound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 217113)
       (if.true.ret)
       (push.const . import)
       (push.const . "attempt to reference unexported identifier ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 218163)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 218223))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 218137))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 216073))
   (push.close
     (3 0 . check-bound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 224282)
       (if.false.ret)
       (push.const . import)
       (push.const . "duplicate import identifiers ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 225332)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 225378))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 225306))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 223241))
   (enclose . 2)
   (extend.enclose
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 229383)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 229383)
       (ret.pair? "./boot/macro/library.scm" . 229383))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 229383)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 229383))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 229383)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 229383)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 229383)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 229383))
       (push)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 229383))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 229383)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 229383))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 229383)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 229383)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 229383)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 229383)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 229383))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 229383)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 229383))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 229383)
           (push.iloc 2 . 1)
           (ret.subr.gloc.of memq "./boot/macro/library.scm" . 229383))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 229383))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 229383)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 229383))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 229383)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 229383))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 229383)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 229383)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 229383)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 229383)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 229383))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 229383)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 229383))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 229383)
           (push.iloc 2 . 1)
           (push.subr.gloc.of memq 2 "./boot/macro/library.scm" . 229383)
           (ret.subr.gloc.of not "./boot/macro/library.scm" . 229383))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 229383))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 229383)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 229383))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 229383)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 229383))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 229383)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 229383)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 229383)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 229383)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 229383))
       (push)
       (extend . 1)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of |.fn2.1`2|)
           (push.iloc.1 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 229383))
         (if.true.ret)
         (push.const . import)
         (push.const . "malformed import set")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 229383))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 229383)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 229383))
       (call
         (call
           (call
             (touch.gloc.of unique-id-list?)
             (call
               (push.gloc.of car)
               (push.iloc.1 . 1)
               (apply.gloc.of map "./boot/macro/library.scm" . 229383))
             (push)
             (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 229383))
           (if.false.ret)
           (touch.gloc.of unique-id-list?)
           (call
             (push.gloc.of cadr)
             (push.iloc.1 . 1)
             (apply.gloc.of map "./boot/macro/library.scm" . 229383))
           (push)
           (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 229383))
         (if.true.ret)
         (push.const . import)
         (push.const . "duplicate identifers in rename specs")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 229383))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 229383)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 229383))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of cadr)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 229383))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 229383)
         (apply.iloc (5 . 1) "./boot/macro/library.scm" . 229383))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of car)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 229383))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 229383)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 229383))
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 229383)
           (push.iloc 2 . 1)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 229383)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 229383)
             (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 229383)
             (ret.cons "./boot/macro/library.scm" . 229383))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/library.scm" . 229383))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 229383)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 229383))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 229383)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 229383)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 229383)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 229383))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 229383)
       (extend . 1)
       (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 229383)
       (call
         (push.close
           (1 0)
           (push.const . "~a~a")
           (push.iloc.1 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 229383)
           (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 229383)
           (push.subr.gloc.of string->symbol 1 "./boot/macro/library.scm" . 229383)
           (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 229383)
           (ret.cons "./boot/macro/library.scm" . 229383))
         (call
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 229383)
           (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 229383)
           (push.const)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 229383))
         (push)
         (apply.gloc.of map "./boot/macro/library.scm" . 229383))
       (push)
       (push.iloc 2 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 229383)
       (apply.iloc (3 . 0) "./boot/macro/library.scm" . 229383))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 229383)
       (extend . 1)
       (call
         (touch.gloc.of flatten-library-reference)
         (push.iloc 5 . 0)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 229383)
         (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 229383))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 229383))
       (push)
       (call
         (touch.gloc.of library-reference->version)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->version "./boot/macro/library.scm" . 229383))
       (push)
       (extend . 2)
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of |.require-scheme-library| "./boot/macro/library.scm" . 229383))
       (call
         (touch.gloc.of library-name->id)
         (push.iloc 7 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-name->id "./boot/macro/library.scm" . 229383))
       (push)
       (extend . 1)
       (call
         (call
           (iloc.1 . 1)
           (if.false.ret)
           (call
             (touch.gloc.of scheme-library-versions)
             (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 229383))
           (push)
           (push.iloc.0 . 0)
           (push.const . #f)
           (ret.subr.gloc.of core-hashtable-ref "./boot/macro/library.scm" . 229383))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of test-library-versions)
           (push.iloc 9 . 0)
           (push.iloc 3 . 0)
           (push.iloc 2 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of test-library-versions "./boot/macro/library.scm" . 229383))
         (ret.const.unspec))
       (push.iloc 3 . 0)
       (call
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 229383))
         (push)
         (push.iloc.0 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 229383)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (ret.subr.gloc.of append "./boot/macro/library.scm" . 229383))
         (push.const . import)
         (push.const . "attempt to import undefined library")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 9 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 229383))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 229383))
       (push)
       (apply.iloc (6 . 0) "./boot/macro/library.scm" . 229383))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 4 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 229383))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 229383)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 229383))
   (push.iloc 2 . 1)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 228357))
 (set.gloc.of parse-imports)
 (ret.const.unspec))
((close
   (2 0 . parse-depends)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 290823)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 290823)
       (ret.pair? "./boot/macro/library.scm" . 290823))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 290823)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 290823))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 290823)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 290823)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 290823)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 290823))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 290823)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 290823)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 290823)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 290823))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 290823)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 290823)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 290823)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 290823))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 290823)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 290823)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 290823)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 290823)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 290823)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 290823))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 290823)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 290823)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of flatten-library-reference)
           (push.iloc 3 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
           (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 290823))
         (push)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 290823))
       (push)
       (iloc.1 . 1)
       (push.cons)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 290823))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 3 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 290823))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 290823)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 290823))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 289797))
 (set.gloc.of parse-depends)
 (ret.const.unspec))
((close
   (1 0 . permute-env)
   (touch.gloc.of |loop`8|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 315417)
   (push.const)
   (push.const)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 315401))
 (set.gloc.of |permute-env`2|)
 (close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 317458))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 318492)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 318482))
   (if.true
     (touch.gloc.of |loop`8|)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 319512)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 319535)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 319506))
   (touch.gloc.of |loop`8|)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 321560)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 321576)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 321554))
 (set.gloc.of |loop`8|)
 (close
   (2 0 . expand-library)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.caddr| 1 "./boot/macro/library.scm" . 313349)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/library.scm" . 313349)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 313349)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/library.scm" . 313349)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 313349)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 313349)
     (push.subr.gloc.of |.cdr| 1 "./boot/macro/library.scm" . 313349)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 313349)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cddddr| 1 "./boot/macro/library.scm" . 313349)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 313349)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/library.scm" . 313349)
     (const . export)
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 313349)
     (push.subr.gloc.of |.car| 1 "./boot/macro/library.scm" . 313349)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 313349))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cddddr| 1 "./boot/macro/library.scm" . 313349)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 313349)
     (push.subr.gloc.of |.cdr| 1 "./boot/macro/library.scm" . 313349)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/library.scm" . 313349)
     (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
     (extend . 4)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 313349))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 313349))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 313349))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 313349))
     (call
       (touch.gloc.of parse-exports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of parse-exports "./boot/macro/library.scm" . 313349))
     (push)
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 313349))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 313349))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 6)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc.1 . 5)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
           (push.const . #f)
           (subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 313349)
           (if.false.ret)
           (push.const . library)
           (push.const . "duplicate export identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 4 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 313349))
           (push)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 313349))
         (push.iloc.1 . 5)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 313349)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 313349))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 313349))
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 313349)
         (push.iloc.1 . 4)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 313349)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 313349)
           (if.eq?.ret.const . #t)
           (push.const . library)
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 313349))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 313349)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 313349))
         (push.iloc 2 . 4)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 313349)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 313349)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 313349))
       (push.iloc.0 . 1)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 313349))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 313349))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable-copy 1 "./boot/macro/library.scm" . 313349)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 313349)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 313349)
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 313349)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 313349))
       (push.iloc 2 . 4)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 313349)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 313349))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 313349))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 4 . 3)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 313349))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of expand-library-body)
         (push.iloc 7 . 0)
         (push.iloc 5 . 0)
         (push.iloc 5 . 1)
         (push.iloc 6 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (push.iloc 4 . 2)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of |permute-env`2|)
             (push.iloc 3 . 0)
             (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 313349))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 313349))
         (push)
         (call
           (touch.gloc.of |permute-env`2|)
           (push.iloc 2 . 0)
           (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 313349))
         (push)
         (apply.gloc.of expand-library-body "./boot/macro/library.scm" . 313349))
       (push)
       (push.iloc 4 . 4)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 313349))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 313349))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 313349))
   (push.const . library)
   (push.const . "expected library name, export spec, and import spec")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 313349))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 313349))
 (set.gloc.of expand-library)
 (ret.const.unspec))
((close
   (3 0 . check-duplicate-definition)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 398366))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 398349))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 399400))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 399383))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 400406)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 402478)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 402469)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 404526)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 406611)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 406584)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 406584))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 407608))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 405542))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 410678))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 411702))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 409636))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 412694)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 414766)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 414757)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 416814)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 418899)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 418872)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 418872))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 419896))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 417830))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 422993)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 422966)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 422966))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 424017)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 423990)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 423990))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 421924))
   (push.const . library)
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 426006))
 (set.gloc.of |check-duplicate-definition`2|)
 (close
   (1 0)
   (push.const . |.require-scheme-library|)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 433175)
   (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 433175))
 (set.gloc.of |.fn3.1`3|)
 (close
   (9 0 . expand-library-body)
   (extend.unbound . 6)
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/library.scm" . 372757)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/library.scm" . 373783)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 7)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 374826)
       (apply.gloc.of env-lookup "./boot/macro/library.scm" . 374810))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/library.scm" . 375828))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-macro)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/library.scm" . 380948))
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 387086))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 388127))
       (set.iloc 1 . 1)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 389151)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 389139))
     (set.iloc 2 . 7)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 390185)
       (push.iloc 3 . 7)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 390175))
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 390153))
   (push.close
     (2 0 . extend-libenv!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 394274)
       (push.iloc 2 . 8)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 394262))
     (set.iloc 2 . 8)
     (ret.const.unspec))
   (push.close
     (4 0 . rewrite-body)
     (call
       (touch.gloc.of |check-duplicate-definition`2|)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of |check-duplicate-definition`2| "./boot/macro/library.scm" . 430089))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 7)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 431134))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn3.1`3|)
       (push.iloc 3 . 6)
       (apply.gloc.of map "./boot/macro/library.scm" . 433170))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 438340)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 439323))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 439323))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 439345)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 439339)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 439334)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 440371)
             (push.iloc 6 . 7)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 440358))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 441373))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 439323))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 439323))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 439323))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 437266))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 447528))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 451653)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 451643))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 451638)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 452686)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 452694)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 452662))
             (ret.const.unspec))
           (push.iloc 5 . 8)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 453680)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 450598))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 454694))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 447510)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 447510)
       (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 447510)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 456762)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 456756)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 456751)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 458801)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 457777)
           (const . template)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 460841)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 460841)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 460841))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 457777)
           (const . procedure)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 461865)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 461865))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 457777)
           (const . variable)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 462889)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 462889))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 463919))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 447510))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 447510)
       (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 447510))
     (push)
     (push.const . |.intern-scheme-library|)
     (push.const . quote)
     (push.iloc 3 . 1)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 465937)
     (push.const . quote)
     (push.iloc 3 . 2)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 465937)
     (push.const . quote)
     (call
       (push.close
         (1 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 472101)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 473138)
           (push.iloc 2 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 473132)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (touch.gloc.of make-import)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 473183)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 473170))
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 474162)
           (push.iloc 5 . 5)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 474156)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 473125))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 476204))
           (push.const . library)
           (push.const . "attempt to export unbound identifier ~u")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 478320)
           (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 478270)
           (push.iloc 6 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 479294)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 477228))
         (ret.cons "./boot/macro/library.scm" . 471069))
       (push.iloc 3 . 4)
       (apply.gloc.of map "./boot/macro/library.scm" . 432139))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 432139)
     (push.subr.gloc.of |.list| 4 "./boot/macro/library.scm" . 432139)
     (extend . 4)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 481305))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 482336))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 483350))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 485441)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 485449)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 485460))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 485413))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 486429))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 488495)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 490586)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 490556))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 491580))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 489519))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 487453))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 493581)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 493581)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 493581)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 493581)
     (subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 493581)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 493581))
   (enclose . 5)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 501796)
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 5)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 503879)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 503835))
     (push.iloc.1 . 5)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 503813))
   (extend.enclose
     (4 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 505895)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 505916)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 505907))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 7)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 506922)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 506906))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 7)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 508957))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 508951))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 510999)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 510999)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 510999)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 510999)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 510999)
           (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 510999)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 510999)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 510999))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 510999)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 510999)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 510999)
           (extend . 3)
           (call
             (push.iloc 4 . 5)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 510999)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 510999)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 510999))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 510999)
             (push.iloc.1 . 1)
             (push.iloc 6 . 7)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 510999))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 510999))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 510999))
               (push)
               (apply.iloc (6 . 3) "./boot/macro/library.scm" . 510999))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 510999)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 510999))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 510999))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 510999)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 510999)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 510999))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 510999))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 510999))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 510999)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 510999))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 510999))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 510999)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 510999)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 510999))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 510999))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 7)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 510999))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 510999))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 510999)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 510999))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 510999))
           (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 510999))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 510999)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 510999))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 531521)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 531505))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 531500)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 531534)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 531490))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 5)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 532559)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 532510)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 533598)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 533534))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 534564)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 535619)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 535588))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 536603))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 537647))
           (push)
           (apply.iloc (5 . 3) "./boot/macro/library.scm" . 537627))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 538657)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 538691))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 538651))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 540729)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 540707))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 540741)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 540695))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 541723))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 543771))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 544838)
           (push.iloc 5 . 7)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 544816))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 7)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 546873)
             (push.iloc 5 . 7)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 546858))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 548904)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 548898))
           (call (push.iloc.0 . 0) (apply.iloc (5 . 0) "./boot/macro/library.scm" . 549922))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 550970)
             (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 550952)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 550946))
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 553013)
           (push.iloc 3 . 2)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 553028)
           (push.iloc 3 . 3)
           (apply.iloc (5 . 4) "./boot/macro/library.scm" . 552994))
         (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 506894))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 555050)
       (push.iloc.1 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 555065)
       (push.iloc.1 . 3)
       (apply.iloc (3 . 4) "./boot/macro/library.scm" . 555031))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 557089)
     (push.iloc.0 . 2)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 557104)
     (push.iloc.0 . 3)
     (apply.iloc (2 . 4) "./boot/macro/library.scm" . 557070))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 7)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 504854))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 504837))
 (set.gloc.of expand-library-body)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 562207)
   (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 562230)
   (extend . 2)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/library.scm" . 565273)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/library.scm" . 566301)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 566327))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 567328)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 568370))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/macro/library.scm" . 569410)
   (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 569381))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . import-top-level-bindings)
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/macro/library.scm" . 560131))
 (set.gloc.of import-top-level-bindings)
 (ret.const.unspec))
((close
   (2 0 . expand-import)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/library.scm" . 574474))
     (if.false.ret)
     (push.const . import)
     (push.const . "misplaced top-level directive")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 575498))
   (call
     (touch.gloc.of auto-compile-cache-update)
     (apply.gloc.of auto-compile-cache-update "./boot/macro/library.scm" . 576517))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 579642)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 579610)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.iloc.0 . 0)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 581677)
         (if.eq?.ret.const . #t)
         (push.const . import)
         (push.const . "duplicate import identifiers")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 582748))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 582781)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 582691))
       (push.iloc 2 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 584763)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 584771)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 584730))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc.1 . 0)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 577576)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 577556))
     (push)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 577541))
   (touch.gloc.of import-top-level-bindings)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 586786)
   (apply.gloc.of import-top-level-bindings "./boot/macro/library.scm" . 586759))
 (set.gloc.of expand-import)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (call
       (touch.gloc.of generate-library-id)
       (push.iloc.0 . 0)
       (apply.gloc.of generate-library-id "./boot/macro/library.scm" . 590871))
     (push)
     (extend . 1)
     (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 591914))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 591894)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . pending)
     (if.eq?
       (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 593957))
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 593936)
       (push.const . library)
       (push.const . "encountered cyclic dependencies")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 594960))
     (push.iloc.0 . 0)
     (const . #f)
     (if.eq?
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 599080))
         (push)
         (push.iloc 2 . 0)
         (push.const . pending)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 599059))
       (push.close
         (0 0)
         (touch.gloc.of load-scheme-library)
         (push.iloc 3 . 0)
         (push.const . #f)
         (apply.gloc.of load-scheme-library "./boot/macro/library.scm" . 601107))
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 603185))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 603165)
         (const . pending)
         (if.not.eq?.ret.const . #f)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 604205))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 604184))
       (apply.gloc.of dynamic-wind "./boot/macro/library.scm" . 597008))
     (ret.const.unspec))
   (ret.const.unspec))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.require-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 589827))
((call
   (push.const . equal?)
   (push.subr.gloc.of make-core-hashtable 1 "./boot/macro/library.scm" . 608285)
   (extend . 1)
   (ret.close
     (1 0 . unify-import-bindings)
     (push.close
       (1 0)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 611349)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of values "./boot/macro/library.scm" . 611342))
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 613404)
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/library.scm" . 610311)))
 (set.gloc.of unify-import-bindings)
 (ret.const.unspec))
((close
   (3 0)
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of scheme-library-versions)
       (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 618543))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 618522))
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 619546))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of unify-import-bindings)
     (push.iloc.0 . 2)
     (apply.gloc.of unify-import-bindings "./boot/macro/library.scm" . 619582))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 619525))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.intern-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 616449))
((close
   (1 0)
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 623645))
   (push)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of core-hashtable-delete! "./boot/macro/library.scm" . 623621))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.unintern-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 621569))
((close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 637970))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 639004)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 638994))
   (if.true
     (touch.gloc.of |loop`8|)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 640024)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 640047)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 640018))
   (touch.gloc.of |loop`8|)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 642072)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 642088)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 642066))
 (set.gloc.of |loop`8|)
 (close
   (1 0 . permute-env)
   (touch.gloc.of |loop`8|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 635929)
   (push.const)
   (push.const)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 635913))
 (set.gloc.of |permute-env`2|)
 (close
   (2 0 . expand-top-level-program)
   (extend.unbound . 1)
   (push.const |.r6rs-top|)
   (enclose . 1)
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (1 . 0) "./boot/macro/library.scm" . 633861)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 633861)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 633861)
     (if.false.ret)
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 633861)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 633861)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 633861)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 633861))
   (if.true
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 633861)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 633861)
     (extend . 2)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 633861))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 633861))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 633861))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 633861))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 633861))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 633861))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 4)
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 633861)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 633861)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 633861)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 633861)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 633861)
           (if.eq?.ret.const . #t)
           (push.const . "top-level program")
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 6 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 633861))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 633861)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 633861))
         (push.iloc 2 . 3)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 633861)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 633861)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 633861))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 633861))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 633861))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable-copy 1 "./boot/macro/library.scm" . 633861)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 633861)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 633861)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 633861)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 633861)
         (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 633861)
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 633861)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 633861)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 633861))
       (push.iloc 2 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 633861)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 633861))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 633861))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 4 . 2)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 633861))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.const . #f)
       (call
         (touch.gloc.of expand-top-level-program-body)
         (push.iloc 8 . 0)
         (push.iloc 5 . 0)
         (push.iloc 5 . 1)
         (push.iloc 6 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of |permute-env`2|)
             (push.iloc 3 . 0)
             (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 633861))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 633861))
         (push)
         (call
           (touch.gloc.of |permute-env`2|)
           (push.iloc 2 . 0)
           (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 633861))
         (push)
         (apply.gloc.of expand-top-level-program-body "./boot/macro/library.scm" . 633861))
       (push)
       (push.iloc 4 . 3)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 633861))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 633861))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 633861))
   (push.const . "top-level program")
   (push.const . "expected import form and top-level body")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.1 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 633861))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 633861))
 (set.gloc.of expand-top-level-program)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . |.require-scheme-library|)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 747543)
   (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 747543))
 (set.gloc.of |.fn3.1`3|)
 (close
   (3 0 . check-duplicate-definition)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 712734))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 712717))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 713768))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 713751))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 714774)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 716846)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 716837)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 718894)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 720979)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 720952)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 720952))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 721976))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 719910))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 725046))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 726070))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 724004))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 727062)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 729134)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 729125)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 731182)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 733267)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 733240)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 733240))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 734264))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 732198))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 737361)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 737334)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 737334))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 738385)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 738358)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 738358))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 736292))
   (push.const . "top-level program")
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 740374))
 (set.gloc.of |check-duplicate-definition`2|)
 (close
   (8 0 . expand-top-level-program-body)
   (extend.unbound . 6)
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 701454))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/library.scm" . 702495))
       (set.iloc 1 . 0)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 703519)
       (push.iloc 2 . 6)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 703507))
     (set.iloc 2 . 6)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 704553)
       (push.iloc 3 . 6)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 704543))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 704521))
   (push.close
     (2 0 . extend-libenv!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 708642)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 708630))
     (set.iloc 2 . 7)
     (ret.const.unspec))
   (push.close+
     (4 0 . rewrite-body)
     (call
       (touch.gloc.of |check-duplicate-definition`2|)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of |check-duplicate-definition`2| "./boot/macro/library.scm" . 744457))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 6)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 745502))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn3.1`3|)
       (push.iloc 3 . 5)
       (apply.gloc.of map "./boot/macro/library.scm" . 747538))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 752708)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 753691))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 753691))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 753713)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 753707)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 753702)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 754739)
             (push.iloc 6 . 6)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 754726))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 755741))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 753691))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 753691))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 753691))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 751634))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 761896))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 766021)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 766011))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 766006)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 767054)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 767062)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 767030))
             (ret.const.unspec))
           (push.iloc 5 . 7)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 768048)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 764966))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 769062))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 761878)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 761878)
       (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 761878)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 771130)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 771124)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 771119)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 773169)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 772145)
           (const . template)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 775209)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 775209)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 775209))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 772145)
           (const . procedure)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 776233)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 776233))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 772145)
           (const . variable)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 777257)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 777257))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 778287))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 761878))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 761878)
       (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 761878))
     (push)
     (extend . 3)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 780313))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 781344))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 782358))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 784449)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 784457)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 784468))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 784421))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 785437))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 787503)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 789594)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 789564))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 790588))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 788527))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 786461))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 792589)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 792589)
     (subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 792589)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 792589))
   (enclose . 4)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 799780)
   (set.iloc 0 . 4)
   (call
     (push.const . 0)
     (extend . 1)
     (ret.close
       (0 0)
       (n+.iloc (1 . 0) 1 "./boot/macro/library.scm" . 804885)
       (set.iloc 1 . 0)
       (push.const . ".e~a")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 805915)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 805899)))
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 4)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 808007)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 807963))
     (push.iloc.1 . 4)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 807941))
   (extend.enclose
     (4 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 811038)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 811053)
       (push.iloc.0 . 3)
       (apply.iloc+ (2 . 3) "./boot/macro/library.scm" . 811019))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 812075)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 812096)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 812087))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 6)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 813102)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 813086))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 6)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 815137))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 815131))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 817179)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 817179)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 817179)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 817179)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 817179)
           (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 817179)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 817179)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 817179))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 817179)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 817179)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 817179)
           (extend . 3)
           (call
             (push.iloc 4 . 4)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 817179)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 817179)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 817179))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 817179)
             (push.iloc.1 . 1)
             (push.iloc 6 . 6)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 817179))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 817179))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 817179))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 817179))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 817179)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 817179))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 817179))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 817179)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 817179)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 817179))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 817179))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 817179))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 817179)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 817179))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 817179))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 817179)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 817179)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 817179))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 817179))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 6)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 817179))
               (push)
               (apply.iloc (6 . 1) "./boot/macro/library.scm" . 817179))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 817179)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 817179))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 817179))
           (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 817179))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 817179)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 817179))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 837701)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 837685))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 837680)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 837714)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 837670))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 4)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 838739)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 838690)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 839778)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 839714))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 840744)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 841799)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 841768))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 1) "./boot/macro/library.scm" . 842783))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 843827))
           (push)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 843807))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 844837)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 844871))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 844831))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 846909)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 846887))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 846921)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 846875))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 847903))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 849951))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 851018)
           (push.iloc 5 . 6)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 850996))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 6)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 853050)
             (push.iloc 5 . 6)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 853035))
           (push)
           (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 853067)
           (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 853027)
           (push.iloc 2 . 1)
           (push.iloc 2 . 2)
           (push.iloc 2 . 3)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 853021))
         (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 813074))
       (push.const . define)
       (call (apply.iloc (3 . 5) "./boot/macro/library.scm" . 855089))
       (push)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 855107)
       (push.subr.gloc.of |.list| 3 "./boot/macro/library.scm" . 855073)
       (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 855119)
       (push.cons)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 855067))
     (push.const . define)
     (call (apply.iloc (2 . 5) "./boot/macro/library.scm" . 857128))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 857146)
     (push.subr.gloc.of |.list| 3 "./boot/macro/library.scm" . 857112)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 857158)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.iloc (1 . 0) "./boot/macro/library.scm" . 857106))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 6)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 808982))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 808965))
 (set.gloc.of expand-top-level-program-body)
 (ret.const.unspec))

;
((close
   (2 0 . extend-env)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/synenv.scm" . 9225))
 (set.gloc.of extend-env)
 (ret.const.unspec))
((close
   (2 0 . env-lookup)
   (call
     (iloc.0 . 1)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error: env-lookup: expect symbol but got ~s")
     (push.iloc.0 . 1)
     (apply.gloc.of scheme-error "./boot/macro/synenv.scm" . 14345))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 15372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of import?)
       (push.cdr.iloc (0 . 0) "./boot/macro/synenv.scm" . 17441)
       (apply.gloc.of import? "./boot/macro/synenv.scm" . 17432))
     (if.true
       (push.cddr.iloc (0 . 0) "./boot/macro/synenv.scm" . 18470)
       (extend . 1)
       (subr.gloc.of current-macro-environment 0)
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 19482))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of cdr "./boot/macro/synenv.scm" . 21528))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 23564))
 (set.gloc.of env-lookup)
 (ret.const.unspec))
((close
   (2 0 . env-delete!)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 27660)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of set-car! 2 "./boot/macro/synenv.scm" . 29713)
     (push.iloc.0 . 0)
     (push.const . no-use)
     (ret.subr.gloc.of set-cdr! "./boot/macro/synenv.scm" . 30737))
   (ret.const.unspec))
 (set.gloc.of env-delete!)
 (ret.const.unspec))
((close
   (2 0 . free-id=?)
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/synenv.scm" . 34832))
   (push)
   (extend . 1)
   (extend.unbound . 2)
   (push.close+
     (2 0 . free-lexical-name=?)
     (call
       (touch.gloc.of original-id)
       (push.iloc.0 . 0)
       (apply.gloc.of original-id "./boot/macro/synenv.scm" . 38933))
     (push)
     (call
       (touch.gloc.of original-id)
       (push.iloc.0 . 1)
       (apply.gloc.of original-id "./boot/macro/synenv.scm" . 38951))
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #t)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 40993))
     (push)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 42017))
     (push)
     (extend . 2)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #t)
     (call
       (push.iloc.1 . 0)
       (iloc.0 . 0)
       (if.eq?.ret.const . #t)
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 44083))
     (if.false.ret)
     (push.iloc.1 . 1)
     (iloc.0 . 1)
     (if.eq?.ret.const . #t)
     (touch.gloc.of unbound?)
     (push.iloc.0 . 1)
     (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 45107))
   (push.close
     (1 0 . lexical-name)
     (iloc.0 . 0)
     (if.symbol?
       (touch.gloc.of lookup-lexical-name)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 50191))
     (call
       (touch.gloc.of syntax-object-lexname)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-lexname "./boot/macro/synenv.scm" . 51219))
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/synenv.scm" . 52264))
     (push)
     (push.iloc 2 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 52243))
   (enclose . 2)
   (call (push.iloc 2 . 0) (apply.iloc (0 . 1) "./boot/macro/synenv.scm" . 54300))
   (push)
   (call (push.iloc 2 . 1) (apply.iloc (0 . 1) "./boot/macro/synenv.scm" . 54319))
   (push)
   (apply.iloc+ (0 . 0) "./boot/macro/synenv.scm" . 54279))
 (set.gloc.of free-id=?)
 (ret.const.unspec))
((close
   (1 0 . make-import)
   (push.const . import)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 58373))
 (set.gloc.of make-import)
 (ret.const.unspec))
((close (0 0 . make-unbound) (ret.const unbound)) (set.gloc.of make-unbound) (ret.const.unspec))
((close
   (1 0 . make-out-of-context)
   (iloc.0 . 0)
   (if.true (push.const . out-of-context) (iloc.0 . 0) (ret.cons "./boot/macro/synenv.scm" . 67593))
   (ret.const out-of-context . #f))
 (set.gloc.of make-out-of-context)
 (ret.const.unspec))
((close
   (1 0 . make-pattern-variable)
   (push.const . pattern-variable)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 72709))
 (set.gloc.of make-pattern-variable)
 (ret.const.unspec))
((close
   (2 0 . make-macro)
   (push.const . macro)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 76805))
 (set.gloc.of make-macro)
 (ret.const.unspec))
((close
   (2 0 . make-macro-variable)
   (push.const . macro-variable)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 80901))
 (set.gloc.of make-macro-variable)
 (ret.const.unspec))
((close
   (1 0 . make-special)
   (push.const . special)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 84997))
 (set.gloc.of make-special)
 (ret.const.unspec))
((close
   (1 0 . import?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 90127)
   (const . import)
   (ret.eq? "./boot/macro/synenv.scm" . 90122))
 (set.gloc.of import?)
 (ret.const.unspec))
((close
   (1 0 . unbound?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 95247)
   (const . unbound)
   (ret.eq? "./boot/macro/synenv.scm" . 95242))
 (set.gloc.of unbound?)
 (ret.const.unspec))
((close
   (1 0 . out-of-context?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 100367)
   (const . out-of-context)
   (ret.eq? "./boot/macro/synenv.scm" . 100362))
 (set.gloc.of out-of-context?)
 (ret.const.unspec))
((close
   (1 0 . macro?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 105491)
   (const . macro)
   (if.eq?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 106515)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 106510))
 (set.gloc.of macro?)
 (ret.const.unspec))
((close
   (1 0 . macro-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 111631)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 111626))
 (set.gloc.of macro-variable?)
 (ret.const.unspec))
((close
   (1 0 . pattern-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 116751)
   (const . pattern-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 116746))
 (set.gloc.of pattern-variable?)
 (ret.const.unspec))
((close
   (1 0 . special?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 121871)
   (const . special)
   (ret.eq? "./boot/macro/synenv.scm" . 121866))
 (set.gloc.of special?)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 125975)
   (push.const . "unquote appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 125957))
 (set.gloc.of unexpected-unquote)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote-splicing)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 130071)
   (push.const . "unquote-splicing appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 130053))
 (set.gloc.of unexpected-unquote-splicing)
 (ret.const.unspec))
((close
   (2 0 . unexpected-auxiliary-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 134167)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 134149))
 (set.gloc.of unexpected-auxiliary-syntax)
 (ret.const.unspec))
((close
   (2 0 . unexpected-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 138263)
   (push.const . "misplaced syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 138245))
 (set.gloc.of unexpected-syntax)
 (ret.const.unspec))
((subr.gloc.of make-core-hashtable 0 "./boot/macro/synenv.scm" . 140306)
 (set.gloc.of core-env)
 (ret.const.unspec))
((close
   (2 0 . init-core-macro)
   (push.gloc.of core-env)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (subr.gloc.of core-hashtable-set! 3 "./boot/macro/synenv.scm" . 146439)
   (push.gloc.of core-env)
   (call
     (touch.gloc.of core-primitive-name)
     (push.iloc.0 . 0)
     (apply.gloc.of core-primitive-name "./boot/macro/synenv.scm" . 147493))
   (push)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 147463))
 (set.gloc.of |init-core-macro`1|)
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . lambda)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-lambda)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 149543))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 149507))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . quote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 150567))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 150531))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . if)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-if)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 151591))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 151555))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . set!)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-set!)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 152615))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 152579))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . define-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 153639))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 153603))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 154663))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 154627))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . letrec-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 155687))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 155651))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . begin)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-begin)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 156711))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 156675))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . define)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 157735))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 157699))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . quasiquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quasiquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 158759))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 158723))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 159783))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 159747))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . letrec)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 160807))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 160771))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 161831))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 161795))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . cond)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-cond)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 162855))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 162819))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 163879))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 163843))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . do)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-do)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 164903))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 164867))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . and)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-and)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 165927))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 165891))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . or)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-or)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 166951))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 166915))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . letrec*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 167975))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 167939))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . library)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-library)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 168999))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 168963))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . define-macro)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-macro)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 170023))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 169987))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let*-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 171047))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 171011))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 172071))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 172035))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 173095))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 173059))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . syntax-case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 174119))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 174083))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . identifier-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-identifier-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 175143))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 175107))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . assert)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-assert)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 176167))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 176131))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . unquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 177191))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 177155))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . unquote-splicing)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote-splicing)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 178215))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 178179))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . syntax-rules)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 179239))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 179203))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . else)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 180263))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 180227))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . =>)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 181287))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 181251))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . ...)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 182311))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 182275))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . _)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 183335))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 183299))
 (touch.gloc.of |init-core-macro`1|)
 (push.const . import)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-import)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 184359))
 (push)
 (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 184323))
((push.gloc.of core-env)
 (push.const . lambda)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 186401)
 (set.gloc.of denote-lambda)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . begin)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 187425)
 (set.gloc.of denote-begin)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 188449)
 (set.gloc.of denote-define)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 189473)
 (set.gloc.of denote-define-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 190497)
 (set.gloc.of denote-let-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 191521)
 (set.gloc.of denote-letrec-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-macro)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 192545)
 (set.gloc.of denote-define-macro)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . library)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 193569)
 (set.gloc.of denote-library)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quasiquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 194593)
 (set.gloc.of denote-quasiquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 195617)
 (set.gloc.of denote-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . if)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 196641)
 (set.gloc.of denote-if)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . set!)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 197665)
 (set.gloc.of denote-set!)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 198689)
 (set.gloc.of denote-unquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote-splicing)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 199713)
 (set.gloc.of denote-unquote-splicing)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 200737)
 (set.gloc.of denote-let)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 201761)
 (set.gloc.of denote-letrec)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 202785)
 (set.gloc.of denote-let*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . cond)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 203809)
 (set.gloc.of denote-cond)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 204833)
 (set.gloc.of denote-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . do)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 205857)
 (set.gloc.of denote-do)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . and)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 206881)
 (set.gloc.of denote-and)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . or)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 207905)
 (set.gloc.of denote-or)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 208929)
 (set.gloc.of denote-letrec*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 209953)
 (set.gloc.of denote-let*-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 210977)
 (set.gloc.of denote-let-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 212001)
 (set.gloc.of denote-syntax-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 213025)
 (set.gloc.of denote-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 214049)
 (set.gloc.of denote-syntax-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-rules)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 215073)
 (set.gloc.of denote-syntax-rules)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . else)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 216097)
 (set.gloc.of denote-else)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . =>)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 217121)
 (set.gloc.of denote-=>)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . import)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 218145)
 (set.gloc.of denote-import)
 (ret.const.unspec))
((close
   (2 0 . denote-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of macro?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 223250))
   (push)
   (apply.gloc.of macro? "./boot/macro/synenv.scm" . 223242))
 (set.gloc.of denote-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-special?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of special?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 228372))
   (push)
   (apply.gloc.of special? "./boot/macro/synenv.scm" . 228362))
 (set.gloc.of denote-special?)
 (ret.const.unspec))
((close
   (2 0 . denote-lambda?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 233487))
   (push)
   (gloc.of denote-lambda)
   (ret.eq? "./boot/macro/synenv.scm" . 233482))
 (set.gloc.of denote-lambda?)
 (ret.const.unspec))
((close
   (2 0 . denote-begin?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 238607))
   (push)
   (gloc.of denote-begin)
   (ret.eq? "./boot/macro/synenv.scm" . 238602))
 (set.gloc.of denote-begin?)
 (ret.const.unspec))
((close
   (2 0 . denote-let?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 243727))
   (push)
   (gloc.of denote-let)
   (ret.eq? "./boot/macro/synenv.scm" . 243722))
 (set.gloc.of denote-let?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 248847))
   (push)
   (gloc.of denote-define-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 248842))
 (set.gloc.of denote-define-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-let-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 253967))
   (push)
   (gloc.of denote-let-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 253962))
 (set.gloc.of denote-let-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-letrec-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 259087))
   (push)
   (gloc.of denote-letrec-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 259082))
 (set.gloc.of denote-letrec-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-define?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 264207))
   (push)
   (gloc.of denote-define)
   (ret.eq? "./boot/macro/synenv.scm" . 264202))
 (set.gloc.of denote-define?)
 (ret.const.unspec))
((close
   (2 0 . denote-quote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 269327))
   (push)
   (gloc.of denote-quote)
   (ret.eq? "./boot/macro/synenv.scm" . 269322))
 (set.gloc.of denote-quote?)
 (ret.const.unspec))
((close
   (2 0 . denote-quasiquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 274447))
   (push)
   (gloc.of denote-quasiquote)
   (ret.eq? "./boot/macro/synenv.scm" . 274442))
 (set.gloc.of denote-quasiquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 279567))
   (push)
   (gloc.of denote-unquote)
   (ret.eq? "./boot/macro/synenv.scm" . 279562))
 (set.gloc.of denote-unquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote-splicing?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 284687))
   (push)
   (gloc.of denote-unquote-splicing)
   (ret.eq? "./boot/macro/synenv.scm" . 284682))
 (set.gloc.of denote-unquote-splicing?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 289807))
   (push)
   (gloc.of denote-define-macro)
   (ret.eq? "./boot/macro/synenv.scm" . 289802))
 (set.gloc.of denote-define-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-syntax-rules?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 294927))
   (push)
   (gloc.of denote-syntax-rules)
   (ret.eq? "./boot/macro/synenv.scm" . 294922))
 (set.gloc.of denote-syntax-rules?)
 (ret.const.unspec))
((close
   (2 0 . denote-else?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 300047))
   (push)
   (gloc.of denote-else)
   (ret.eq? "./boot/macro/synenv.scm" . 300042))
 (set.gloc.of denote-else?)
 (ret.const.unspec))
((close
   (2 0 . denote-=>?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 305167))
   (push)
   (gloc.of denote-=>)
   (ret.eq? "./boot/macro/synenv.scm" . 305162))
 (set.gloc.of denote-=>?)
 (ret.const.unspec))
((close
   (2 0 . denote-set!?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 310287))
   (push)
   (gloc.of denote-set!)
   (ret.eq? "./boot/macro/synenv.scm" . 310282))
 (set.gloc.of denote-set!?)
 (ret.const.unspec))
((push.const . |.LIST|)
 (const . |.list|)
 (push.cons)
 (push.const . |.CONS|)
 (const . |.cons|)
 (push.cons)
 (push.const . |.CONS*|)
 (const . |.cons*|)
 (push.cons)
 (push.const . |.APPEND|)
 (const . |.append|)
 (push.cons)
 (push.const . |.VECTOR|)
 (const . |.vector|)
 (push.cons)
 (push.const . |.LIST->VECTOR|)
 (const . |.list->vector|)
 (push.cons)
 (push.const . |.EQ?|)
 (const . |.eq?|)
 (push.cons)
 (push.const . |.EQV?|)
 (const . |.eqv?|)
 (push.cons)
 (push.const . |.MEMQ|)
 (const . |.memq|)
 (push.cons)
 (push.const . |.MEMV|)
 (const . |.memv|)
 (push.cons)
 (push.const . |.CALL-WITH-VALUES|)
 (const . |.call-with-values|)
 (push.cons)
 (push.const . |.APPLY|)
 (const . |.apply|)
 (push.cons)
 (push.const . |.CDR|)
 (const . |.cdr|)
 (push.cons)
 (push.const . |.IDENTIFIER?|)
 (const . |.identifier?|)
 (push.cons)
 (push.const . |.MAKE-VARIABLE-TRANSFORMER|)
 (const . |.make-variable-transformer|)
 (push.cons)
 (push.const . |.ASSERTION-VIOLATION|)
 (const . |.assertion-violation|)
 (push.cons)
 (push.const . |.UNSPECIFIED|)
 (const . |.unspecified|)
 (push.cons)
 (push.const . |.QUOTE|)
 (gloc.of denote-quote)
 (push.cons)
 (push.const . |.LET|)
 (gloc.of denote-let)
 (push.cons)
 (push.const . |.LETREC*|)
 (gloc.of denote-letrec*)
 (push.cons)
 (push.const . |.BEGIN|)
 (gloc.of denote-begin)
 (push.cons)
 (push.const . |.LAMBDA|)
 (gloc.of denote-lambda)
 (push.cons)
 (push.const . |.IF|)
 (gloc.of denote-if)
 (push.cons)
 (push.const . |.SET!|)
 (gloc.of denote-set!)
 (push.cons)
 (push.const . |.OR|)
 (gloc.of denote-or)
 (push.cons)
 (push.const . |.COND|)
 (gloc.of denote-cond)
 (push.cons)
 (push.const . |.ELSE|)
 (gloc.of denote-else)
 (push.cons)
 (push.const . |.DEFINE-SYNTAX|)
 (gloc.of denote-define-syntax)
 (push.cons)
 (push.const . |.SYNTAX|)
 (gloc.of denote-syntax)
 (push.cons)
 (push.const . |.SYNTAX-CASE|)
 (gloc.of denote-syntax-case)
 (push.cons)
 (subr.gloc.of list 30 "./boot/macro/synenv.scm" . 313347)
 (set.gloc.of private-primitives-environment)
 (ret.const.unspec))
((push.gloc.of core-env)
 (ret.subr.gloc.of current-macro-environment "./boot/macro/synenv.scm" . 348161))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/compile.scm" . 5147))
 (set.gloc.of ht-local-closures)
 (ret.const.unspec))
((close
   (1 0 . local-closure?)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/compile.scm" . 9248))
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 9228)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 10273)
     (push.const stack)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 10267))
   (ret.const . #f))
 (set.gloc.of local-closure?)
 (ret.const.unspec))
((close
   (1 0)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 16413)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 17435)
   (const . lambda)
   (if.not.eq?.ret.const . #f)
   (call
     (touch.gloc.of local-closure?)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 18470)
     (apply.gloc.of local-closure? "./boot/compile.scm" . 18454))
   (if.false.ret)
   (call
     (touch.gloc.of ht-local-closures)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 19499))
   (push)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 19519)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 19478))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . collect-local-closure)
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/compile.scm" . 15365))
 (set.gloc.of collect-local-closure)
 (ret.const.unspec))
((close
   (1 0 . make-application-comment)
   (subr.gloc.of backtrace 0 "./boot/compile.scm" . 24585)
   (if.true
     (subr.gloc.of current-source-comments 0 "./boot/compile.scm" . 25616)
     (if.true
       (subr.gloc.of current-source-comments 0)
       (push)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 27676)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 29733)
         (if.true
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . |.&SOURCE-PATH|)
           (push.const . #f)
           (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 30766)
           (push.iloc.0 . 0)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 30834)
           (ret.subr.gloc.of |.cons*| "./boot/compile.scm" . 29729))
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . |.&SOURCE-PATH|)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 31784)
         (iloc.0 . 0)
         (ret.cons "./boot/compile.scm" . 29729))
       (push.iloc.1 . 0)
       (ret.subr.gloc.of list "./boot/compile.scm" . 33820))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 35856))
   (ret.const))
 (set.gloc.of make-application-comment)
 (ret.const.unspec))
((close
   (1 0 . make-closure-comment)
   (call
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 40977))
     (if.false.ret)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 42021))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (ret.subr.gloc.of core-hashtable-ref "./boot/compile.scm" . 42001))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/compile.scm" . 40965))
   (ret.const))
 (set.gloc.of make-closure-comment)
 (ret.const.unspec))
((close
   (1 0 . top-level-subr)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 49162)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 50193)
   (subr.gloc.of subr? 1 "./boot/compile.scm" . 50186)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 51210))
 (set.gloc.of top-level-subr)
 (ret.const.unspec))
((close
   (1 0 . top-level-value-or-false)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 56330)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 57354))
 (set.gloc.of top-level-value-or-false)
 (ret.const.unspec))
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 62479)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 62504)
       (apply.gloc.of formals->list "./boot/compile.scm" . 62489))
     (ret.cons "./boot/compile.scm" . 62473))
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/compile.scm" . 64533))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . make-formals-operand)
   (push.iloc.0 . 1)
   (subr.gloc.of list? 1 "./boot/compile.scm" . 68620)
   (if.true
     (push.iloc.0 . 1)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 68642)
     (push.const . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 68636))
   (iloc.0 . 1)
   (if.pair?
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 69669)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/compile.scm" . 69666)
     (push.const . 1)
     (ret.subr.gloc.of list "./boot/compile.scm" . 69660))
   (ret.const 0 1))
 (set.gloc.of make-formals-operand)
 (ret.const.unspec))
((close
   (2 0 . make-iloc-operand)
   (extend.enclose+
     (2 0 . loop1)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 76824)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 76816)
     (if.true
       (push.iloc.0 . 1)
       (call
         (extend.enclose+
           (2 0 . loop2)
           (push.car.iloc (0 . 0) "./boot/compile.scm" . 79905)
           (iloc 4 . 0)
           (if.eq? (ret.iloc 0 . 1))
           (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 81955)
           (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 81966)
           (apply.iloc+ (1 . 0) "./boot/compile.scm" . 81948))
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 78888)
         (push.const . 0)
         (apply.iloc+ (0 . 0) "./boot/compile.scm" . 78870))
       (ret.cons "./boot/compile.scm" . 75783))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 82967)
     (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 82978)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 82960))
   (push.iloc.1 . 1)
   (push.const . 0)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 74757))
 (set.gloc.of make-iloc-operand)
 (ret.const.unspec))
((close
   (3 0 . iloc-iota)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 89102)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/compile.scm" . 90137)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of + 2 "./boot/compile.scm" . 90167)
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 90131))
   (push.n+.iloc (1 . 2) -1 "./boot/compile.scm" . 88087)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 88069))
 (set.gloc.of iloc-iota)
 (ret.const.unspec))
((close
   (2 0 . cte-extend-iloc)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (ret.cons "./boot/compile.scm" . 94213))
 (set.gloc.of cte-extend-iloc)
 (ret.const.unspec))
((close
   (2 0 . iloc?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 101405)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 101397)
     (if.true.ret)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 102427)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 102421))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 99338))
 (set.gloc.of iloc?)
 (ret.const.unspec))
((close
   (1 0 . immediate-literal?)
   (push.iloc.0 . 0)
   (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 106505)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of char? 1 "./boot/compile.scm" . 106517)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of boolean? 1 "./boot/compile.scm" . 106527)
   (if.true.ret)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 107549)
   (const . quote)
   (if.not.eq?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 107574)
   (ret.subr.gloc.of symbol? "./boot/compile.scm" . 107565))
 (set.gloc.of immediate-literal?)
 (ret.const.unspec))
((close
   (2 0 . compile-touch)
   (call
     (iloc.0 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 113686)
     (if.true.ret.const . #f)
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 114710))
     (push)
     (ret.subr.gloc.of not "./boot/compile.scm" . 114705))
   (if.true
     (push.const . touch.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 112651)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 112651))
   (ret.const))
 (set.gloc.of compile-touch)
 (ret.const.unspec))
((close
   (4 0 . compile-lambda-helper)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/compile.scm" . 120849))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of cte-extend-iloc)
     (push.iloc.0 . 0)
     (push.iloc.1 . 3)
     (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 121874))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of make-formals-operand)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of make-formals-operand "./boot/compile.scm" . 122900))
   (push)
   (push.iloc 2 . 2)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 122892)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 123918))
   (ret.cons "./boot/compile.scm" . 121863))
 (set.gloc.of compile-lambda-helper)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 128027))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of cons)
     (push.gloc.of =)
     (push.gloc.of <)
     (push.gloc.of <=)
     (push.gloc.of >)
     (push.gloc.of >=)
     (push.gloc.of eq?)
     (push.gloc.of null?)
     (push.gloc.of pair?)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of eqv?)
     (push.gloc.of equal?)
     (push.subr.gloc.of list 18 "./boot/compile.scm" . 129039)
     (apply.gloc.of for-each "./boot/compile.scm" . 128005))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 130053))
 (set.gloc.of ht-special-subr-expression)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 133123)
 (set.gloc.of alist-special-binary-subr)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 136195)
 (set.gloc.of alist-special-binary-subr-negate)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 139267)
 (set.gloc.of alist-special-binary-subr-iloc)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 142339)
 (set.gloc.of alist-special-binary-subr-iloc-negate)
 (ret.const.unspec))
((close
   (4 0 . compile-anonymous)
   (iloc.0 . 2)
   (if.true
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 150568)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 150545))
     (push)
     (push.const . ret.subr.gloc.of)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 150603)
     (push.iloc.0 . 3)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 149513)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 149513)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 149513))
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151592)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 151569))
   (push)
   (push.const . subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 151623)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151643)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 151635)
   (push.iloc.0 . 3)
   (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 149513)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 149513)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 149513))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (4 0 . compile-subr-expression)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 153620))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 154660)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 154643)
   (extend . 1)
   (push.gloc.of ht-special-subr-expression)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 155661)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 156699)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (iloc 2 . 2)
         (if.true.ret.const)
         (iloc 2 . 3)
         (if.true
           (push.const . ret.const.unspec)
           (push.subr.gloc.of list 1 "./boot/compile.scm" . 159789)
           (ret.subr.gloc.of list "./boot/compile.scm" . 159783))
         (push.const . const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 160813)
         (ret.subr.gloc.of list "./boot/compile.scm" . 160807))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 161824))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 162843)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of pair?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 165943)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 165923))
           (push)
           (push.const . ret.pair?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 164894)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 164894))
         (push.iloc.0 . 0)
         (gloc.of null?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 167991)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 167971))
           (push)
           (push.const . ret.null?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 166942)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 166942))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 170015))
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 171043)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 171036))
       (if.true
         (iloc 2 . 2)
         (if.true.ret.const)
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 175178)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 175159))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 174121)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 174121))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 177226)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 177207))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 176169)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 176169))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 179275)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 179256))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 178217)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 178217))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 181323)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 181304))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 180265)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 180265))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 183338))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 184348))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 185371)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of cons)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 188469)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 188451))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 188508)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 188488))
           (push)
           (push.const . ret.cons)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 187422)
           (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 187422)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 187422))
         (push.iloc.0 . 0)
         (gloc.of eq?)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 190517)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 190499))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 190556)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 190536))
           (push)
           (push.const . ret.eq?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 189470)
           (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 189470)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 189470))
         (push.iloc.0 . 0)
         (gloc.of eqv?)
         (if.eq?
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 192574)
           (extend . 1)
           (call
             (call
               (touch.gloc.of immediate-literal?)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 192555)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193577))
             (if.true.ret)
             (touch.gloc.of immediate-literal?)
             (push.iloc.0 . 0)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193603))
           (if.true
             (call
               (touch.gloc.of compile-argument)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 194619)
               (push.iloc 3 . 1)
               (apply.gloc.of compile-argument "./boot/compile.scm" . 194601))
             (push)
             (call
               (touch.gloc.of compile-expression)
               (push.iloc 3 . 0)
               (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 194658)
               (push.iloc 3 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 194638))
             (push)
             (push.const . ret.eq?)
             (iloc 2 . 0)
             (push.cons)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 193569)
             (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 193569)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 193569))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.iloc 2 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 195621))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 197663))
       (push.iloc.0 . 0)
       (push.gloc.of alist-special-binary-subr)
       (subr.gloc.of assq 2 "./boot/compile.scm" . 198687)
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 199723)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 199742)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 201787)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 201817))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 201858)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 201853)
             (ret.subr.gloc.of values "./boot/compile.scm" . 201835))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 202811)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 202841))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 202882)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 202877)
             (ret.subr.gloc.of values "./boot/compile.scm" . 202859))
           (push.const . #f)
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 203835))
         (push.close
           (3 0)
           (iloc.0 . 2)
           (if.true
             (push.iloc.0 . 2)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 204857))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 204841)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 204841))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 205866))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 206894))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 206937)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 206932)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 206982))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 205865)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 205865)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 205865))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 207914))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 208942))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 208985)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 208980)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 209037))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 207913)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 207913)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 207913))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 209967))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 199711))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 213035)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 213054)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 214085)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 214115))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 214133))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 215109)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 215139))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 215157))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 216133))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 218163))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 217123)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 217123))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 219175))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 213023))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 221227)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 221246)
         (extend . 2)
         (call
           (push.iloc.0 . 1)
           (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 222250)
           (if.false.ret)
           (iloc.0 . 0)
           (if.not.symbol?.ret.const . #f)
           (touch.gloc.of iloc?)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of iloc? "./boot/compile.scm" . 222280))
         (if.true
           (push.const . n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 223281))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 223311)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 222241)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 222241))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 3)
         (push.iloc 2 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 224293))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 227359))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 3)
     (push.iloc.1 . 0)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 229396))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc 2 . 3)
   (push.iloc.1 . 0)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 230413))
 (set.gloc.of compile-subr-expression)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 234523))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of cons)
     (push.subr.gloc.of list 8 "./boot/compile.scm" . 235535)
     (apply.gloc.of for-each "./boot/compile.scm" . 234501))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 236549))
 (set.gloc.of ht-special-subr-argument)
 (ret.const.unspec))
((close
   (3 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243748)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 243725))
   (push)
   (push.const . push.subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 243784)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243804)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 243796)
   (push.iloc.0 . 2)
   (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 242695)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 242695)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 242695))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (2 0 . compile-subr-argument)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 245780))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 246820)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 246803)
   (extend . 1)
   (push.gloc.of ht-special-subr-argument)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 247821)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 248859)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (push.const . push.const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 249912)
         (ret.subr.gloc.of list "./boot/compile.scm" . 249906))
       (push.const . subr.gloc.of)
       (push.car.iloc (2 . 0) "./boot/compile.scm" . 251948)
       (push.const 0)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 250906)
       (push.const . push)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 251963)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 250906))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 252955)
     (if.null?
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 253983)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 253976))
       (if.true
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . push.car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 255059)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 255040))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 255006)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 255006))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . push.cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 256083)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 256064))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 256030)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 256030))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . push.cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 257109)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 257090))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 257054)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 257054))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . push.cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 258133)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 258114))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 258078)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 258078))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 259108))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 260120))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 261147)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of cons)
       (if.eq?
         (call
           (touch.gloc.of compile-argument)
           (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 263217)
           (push.iloc 2 . 1)
           (apply.gloc.of compile-argument "./boot/compile.scm" . 263199))
         (push)
         (call
           (touch.gloc.of compile-expression)
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 263256)
           (push.iloc 2 . 1)
           (push.const . #f)
           (push.const . #f)
           (apply.gloc.of compile-expression "./boot/compile.scm" . 263236))
         (push)
         (push.const . push.cons)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 263281)
         (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 262170)
         (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 262170)
         (ret.subr.gloc.of |.append| "./boot/compile.scm" . 262170))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 265255)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 265274)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 266305))
             (if.false.ret)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 266322))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 266338))
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 267329))
             (if.false.ret)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 267346))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 267362))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 268353))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . push.n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 270388))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 269343)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 269343))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 271395))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 265243))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 273447)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 273466)
         (extend . 2)
         (call
           (call
             (touch.gloc.of iloc?)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 274470))
           (if.false.ret)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 274487))
         (if.true
           (push.const . push.n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 275506))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 275536)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 274461)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 274461))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 2 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 276513))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 278555))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 280596))
   (cdr.iloc (2 . 0) "./boot/compile.scm" . 281624)
   (if.null?
     (push.const . subr.gloc.of)
     (push.car.iloc (2 . 0) "./boot/compile.scm" . 282658)
     (push.const 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 281613)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 282673)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 281613))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 283665))
 (set.gloc.of compile-subr-argument)
 (ret.const.unspec))
((close
   (2 0 . compile-argument-each)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.gloc.of append)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 288808)
       (apply.gloc.of apply "./boot/compile.scm" . 288794))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 291862)
     (call
       (touch.gloc.of compile-argument)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 290857)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 290839))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 291856))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 287749))
 (set.gloc.of compile-argument-each)
 (ret.const.unspec))
((close
   (2 0 . compile-argument)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 296995)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 296979))
     (if.true
       (touch.gloc.of compile-subr-argument)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-subr-argument "./boot/compile.scm" . 298003))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 299032)
     (const . lambda)
     (if.eq?
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 300086)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 300098)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 300110))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 300063))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of local-closure?)
         (push.iloc.1 . 0)
         (apply.gloc.of local-closure? "./boot/compile.scm" . 301081))
       (if.true
         (push.const . push.close+)
         (iloc.0 . 0)
         (push.cons)
         (ret.subr.gloc.of list "./boot/compile.scm" . 302105))
       (push.const . push.close)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 303129))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 304152)
     (const . quote)
     (if.eq?
       (push.const . push.const)
       (cadr.iloc (0 . 0) "./boot/compile.scm" . 305188)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 304146))
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 307223))
     (push)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 307260)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 306194)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 306194))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (const . |.&UNDEF|)
     (if.eq?
       (push.const . push.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 309293)
       (ret.subr.gloc.of list "./boot/compile.scm" . 309287))
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 311319))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 312354))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 313375)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . push.iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 314418)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 314395))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . push.iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 315442)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 315419))
       (push.const . push.iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 316443))
     (push.const . push.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 311315)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 311315))
   (push.const . push.const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 318475))
 (set.gloc.of compile-argument)
 (ret.const.unspec))
((close
   (4 0 . compile-call)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 324624))
     (push)
     (push.const . apply)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 324661)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 323595)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 323595))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of iloc? "./boot/compile.scm" . 326675))
     (if.true
       (call
         (touch.gloc.of ht-local-closures)
         (apply.gloc.of ht-local-closures "./boot/compile.scm" . 327729))
       (push)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 327703)
       (if.true
         (push.const . apply.iloc+)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 3)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 328743))
         (push)
         (push.iloc.0 . 2)
         (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 327699)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 327699))
       (push.const . apply.iloc)
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 329766))
       (push)
       (push.iloc.0 . 2)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 327699)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 327699))
     (call
       (touch.gloc.of top-level-subr)
       (push.iloc.0 . 0)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 330771))
     (if.true
       (push.const . ret.subr.gloc.of)
       (push.iloc.0 . 0)
       (push.iloc.0 . 2)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 330770)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 330770))
     (push.const . apply.gloc.of)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 332818)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 332818))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (push.const . apply)
   (iloc.0 . 2)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 334859))
 (set.gloc.of compile-call)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-begin)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 339985)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?
     (iloc.1 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 342045)
       (ret.subr.gloc.of list "./boot/compile.scm" . 342039))
     (ret.const))
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 343061)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 344098)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 344078))
   (touch.gloc.of compile-expression-seq)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 346126))
 (set.gloc.of compile-expression-begin)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-quote)
   (iloc.0 . 2)
   (if.true.ret.const)
   (iloc.0 . 3)
   (if.true
     (push.const . ret.const)
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 352269))
   (push.const . const)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 353293))
 (set.gloc.of compile-expression-quote)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-define)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 357413)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 357393))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 359454)
   (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 357381)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 358434)
       (ret.subr.gloc.of list "./boot/compile.scm" . 358428))
     (ret.const))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 357381))
 (set.gloc.of compile-expression-define)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-set!)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 363557)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 363537))
   (push)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 364578)
       (ret.subr.gloc.of list "./boot/compile.scm" . 364572))
     (ret.const))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of iloc?)
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 365589)
     (push.iloc.1 . 1)
     (apply.gloc.of iloc? "./boot/compile.scm" . 365582))
   (if.true
     (push.iloc.0 . 0)
     (push.const . set.iloc)
     (call
       (touch.gloc.of make-iloc-operand)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 366646)
       (push.iloc.1 . 1)
       (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 366627))
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 365581))
   (push.iloc.0 . 0)
   (call
     (subr.gloc.of backtrace 0 "./boot/compile.scm" . 368671)
     (if.true
       (touch.gloc.of compile-touch)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 368698)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-touch "./boot/compile.scm" . 368683))
     (ret.const))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 369711)
   (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 368654)
   (iloc.0 . 1)
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 368654)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 368654))
 (set.gloc.of compile-expression-set!)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-lambda)
   (call
     (touch.gloc.of compile-lambda-helper)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 373800)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 373812)
     (call
       (touch.gloc.of make-closure-comment)
       (push.iloc.0 . 0)
       (apply.gloc.of make-closure-comment "./boot/compile.scm" . 373824))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 373777))
   (push)
   (extend . 1)
   (iloc.1 . 2)
   (if.true.ret.const)
   (iloc.1 . 3)
   (if.true
     (push.const . ret.close)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 375821))
   (push.const . close)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 376845))
 (set.gloc.of compile-expression-lambda)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-let)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 380947)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 381988)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 381964))
   (call
     (touch.gloc.of collect-local-closure)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 384035)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 384012))
   (call
     (push.gloc.of car)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 385057)
     (apply.gloc.of map "./boot/compile.scm" . 385048))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of compile-argument-each)
     (call
       (push.gloc.of cadr)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 386111)
       (apply.gloc.of map "./boot/compile.scm" . 386101))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 386078))
   (push)
   (push.const . extend)
   (push.iloc.0 . 0)
   (subr.gloc.of length 1 "./boot/compile.scm" . 387113)
   (push.cons)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (1 . 0) "./boot/compile.scm" . 388152)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 388164))
     (push)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 388128))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 386068)
   (extend . 1)
   (iloc 2 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 389150))
 (set.gloc.of compile-expression-let)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 1)
   (push.const . set.iloc)
   (iloc.0 . 0)
   (push.cons)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 426038)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 426038))
 (set.gloc.of |.fn2.1`2|)
 (close
   (4 0 . compile-expression-letrec*)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 393235)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 394276)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 394252))
   (push.iloc.0 . 0)
   (subr.gloc.of cdadr 1 "./boot/compile.scm" . 395283)
   (if.null?
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 396315)
     (extend . 1)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 397360)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 397354)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 397337))
     (push)
     (extend . 1)
     (call
       (cadr.iloc (1 . 0) "./boot/compile.scm" . 398371)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 398392)
       (const . lambda)
       (ret.eq? "./boot/compile.scm" . 398387))
     (if.true
       (call
         (touch.gloc.of collect-local-closure)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 399406)
         (apply.gloc.of collect-local-closure "./boot/compile.scm" . 399383))
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 400419)
       (extend . 1)
       (call
         (call
           (touch.gloc.of local-closure?)
           (push.iloc.0 . 0)
           (apply.gloc.of local-closure? "./boot/compile.scm" . 403497))
         (if.true (ret.const . extend.enclose+))
         (ret.const . extend.enclose))
       (push)
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 401473)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 401485)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 401497))
         (push)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 401450))
       (push.cons)
       (call
         (touch.gloc.of compile-expression-seq)
         (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 402498)
         (push.iloc.1 . 0)
         (push.const . #f)
         (push.const . #t)
         (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 402474))
       (push.cons)
       (extend . 1)
       (iloc 4 . 3)
       (if.true (ret.iloc 0 . 0))
       (push.const . call)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 405547))
     (push.const . extend.unbound)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-argument)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 408634)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 408616))
     (push)
     (push.const . enclose)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (2 . 0) "./boot/compile.scm" . 410688)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 410664))
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 407581)
     (push.cons)
     (extend . 1)
     (iloc 3 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 411687))
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 413724)
   (extend . 1)
   (call
     (touch.gloc.of collect-local-closure)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 414734))
   (push.close
     (0 0)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (push.iloc 3 . 0)
         (push.const)
         (ret.subr.gloc.of values "./boot/compile.scm" . 418850))
       (push.iloc.0 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 419886)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (push.car.iloc (0 . 0) "./boot/compile.scm" . 420933)
         (push.const quote lambda)
         (ret.subr.gloc.of memq "./boot/compile.scm" . 420927))
       (if.true
         (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 421934)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 421950)
         (iloc.1 . 1)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/compile.scm" . 421928))
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 422960)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/compile.scm" . 422952))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/compile.scm" . 416796))
   (push.close
     (2 0)
     (call
       (touch.gloc.of cte-extend-iloc)
       (call (push.gloc.of car) (push.iloc.1 . 0) (apply.gloc.of map "./boot/compile.scm" . 423980))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 423963))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of compile-argument-each)
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/compile.scm" . 425019))
       (push)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 424996))
     (push)
     (call
       (push.gloc.of append)
       (call
         (push.gloc.of |.fn2.1`2|)
         (call
           (touch.gloc.of iloc-iota)
           (push.const . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427075)
           (push.iloc.1 . 1)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427090)
           (apply.gloc.of iloc-iota "./boot/compile.scm" . 427062))
         (push)
         (call
           (push.close
             (1 0)
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 428123)
             (push.iloc.1 . 0)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 428103))
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/compile.scm" . 428086))
         (push)
         (apply.gloc.of map "./boot/compile.scm" . 426033))
       (push)
       (apply.gloc.of apply "./boot/compile.scm" . 426019))
     (push)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 429115)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 429091))
     (push)
     (extend . 3)
     (call
       (iloc.0 . 0)
       (if.null?
         (push.const . extend.unbound)
         (push.iloc 3 . 0)
         (subr.gloc.of length 1 "./boot/compile.scm" . 431161)
         (push.cons)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
         (ret.cons "./boot/compile.scm" . 430112))
       (push.const . extend.unbound)
       (push.iloc 3 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432185)
       (push.cons)
       (push.iloc.0 . 0)
       (push.const . enclose)
       (push.iloc.0 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432229)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
       (push.cons)
       (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
       (ret.cons "./boot/compile.scm" . 430112))
     (push)
     (extend . 1)
     (iloc 5 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 433188))
   (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 413708))
 (set.gloc.of compile-expression-letrec*)
 (ret.const.unspec))
((close
   (4 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 441390)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 441370))
   (push)
   (extend . 1)
   (call
     (cdr.iloc (0 . 0) "./boot/compile.scm" . 442395)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 442417)
     (const . const)
     (ret.eq? "./boot/compile.scm" . 442412))
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of cdar 1 "./boot/compile.scm" . 443411)
     (if.true
       (touch.gloc.of compile-expression)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 444455)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 444435))
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 445479)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 445459))
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 446517)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 446497))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 447540)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 447520))
   (push)
   (extend . 2)
   (call
     (cadr.iloc (2 . 0) "./boot/compile.scm" . 448547)
     (if.not.symbol?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 448565)
     (push.iloc 2 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 448577)
     (ret.eq? "./boot/compile.scm" . 448560))
   (if.true
     (iloc 2 . 3)
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 449584)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 449563))
     (push.const . call)
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 450587)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 450587))
   (iloc 2 . 3)
   (if.true
     (call
       (cdr.iloc (0 . 1) "./boot/compile.scm" . 452652)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 1)
       (push.subr.gloc.of caar 1 "./boot/compile.scm" . 452674)
       (const . ret.const)
       (ret.eq? "./boot/compile.scm" . 452669))
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret.const)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 453700)
       (push.cons)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 452636))
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 452636))
   (push.const . call)
   (push.iloc.1 . 0)
   (push.const . if.true)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 0)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 455707)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 455707))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (5 0 . compile-binary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cdadr 1 "./boot/compile.scm" . 478229)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 479253)
   (extend . 2)
   (call
     (touch.gloc.of compile-argument)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 480309)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 480291))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 481335)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 481315))
   (push)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 480283)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 482332))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 483377)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 483357))
   (push)
   (extend . 3)
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 484381)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 484404)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 484398))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 485438)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 485399))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 486423)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 486423))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 487447))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 488471)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 488471))
 (set.gloc.of |compile-binary-special`2|)
 (close
   (5 0 . compile-unary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cadadr 1 "./boot/compile.scm" . 460820)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 461845)
   (extend . 2)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 462875))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 463900))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 464945)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 464925))
   (push)
   (extend . 3)
   (call
     (push.iloc 2 . 4)
     (const . if.null?.ret.const)
     (if.not.eq?.ret.const . #f)
     (iloc.1 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (iloc.1 . 1)
     (ret.eq? "./boot/compile.scm" . 466000))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 466970)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 466970))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 4)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 467994)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 467994)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 467994))
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 470052)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 470075)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 470069))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 471109)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 471070))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 472094)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 472094))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 473118))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 474142)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 474142))
 (set.gloc.of |compile-unary-special`2|)
 (close
   (4 0 . compile-expression-if)
   (push.iloc.0 . 0)
   (subr.gloc.of cdddr 1 "./boot/compile.scm" . 492563)
   (if.null?
     (iloc.0 . 2)
     (if.true
       (touch.gloc.of compile-expression)
       (push.const . and)
       (cdr.iloc (0 . 0) "./boot/compile.scm" . 494636)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 494608))
     (touch.gloc.of compile-expression)
     (push.const . if)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 495659)
     (push.const (|.unspecified|))
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 495632)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 495632))
   (call
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 497695)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 497724)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 497708))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 499750)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 499742)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.null?)
         (push.const . if.null?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 502818))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.pair?)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 504866))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.symbol?)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 506914))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 508962))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.eq?)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`2| "./boot/compile.scm" . 512034))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 513078))
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 514127)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 514120)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 514100)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 514094)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515116))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515142))
         (if.true
           (touch.gloc.of |compile-binary-special`2|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.const . if.eq?)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`2| "./boot/compile.scm" . 516136))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc 3 . 3)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 517160))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 519202))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.iloc 2 . 3)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 521243))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 523283))
 (set.gloc.of compile-expression-if)
 (ret.const.unspec))
((close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 537637)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 537617))
   (push)
   (push.const . if.false.ret.const)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 537707)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 537691))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 536587))
 (set.gloc.of |compile-anonymous-negate`4|)
 (close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 541733)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 541713))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 541790)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 541774))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 540683))
 (set.gloc.of |compile-unary-special`4|)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 533541)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 533521))
   (push)
   (push.const . if.true.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 533563)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 533601)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 533585))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 532491))
 (set.gloc.of |compile-anonymous`4|)
 (close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 545827)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 545809))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 545866)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 545846))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 545924)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 545908))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 544779)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 544779))
 (set.gloc.of |compile-binary-special`4|)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 547860)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 548897)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 548877))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 549920)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 549947)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 549931))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 553006)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 553018)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 554034)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 554061)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 554045))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 556089)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 556081)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.null?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 559157))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.pair?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 561205))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.symbol?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 563253))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 565301))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of |compile-binary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.eq?.ret.const)
             (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 568373))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 569417))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 570464)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 570457)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 570439)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 570433)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571455))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571481))
             (if.true
               (touch.gloc.of |compile-binary-special`4|)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.not.eq?.ret.const)
               (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 572475))
             (touch.gloc.of |compile-anonymous-negate`4|)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 573499))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 575541))
         (touch.gloc.of |compile-anonymous-negate`4|)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 577582))
       (touch.gloc.of |compile-anonymous-negate`4|)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 579622))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 580651)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 580643)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.null?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 583719))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 585767))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 587815))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 589863))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 592935))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 593979))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 595026)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 595019)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 595001)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 594995)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596017))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596043))
         (if.true
           (touch.gloc.of |compile-binary-special`4|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 597037))
         (touch.gloc.of |compile-anonymous`4|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 598061))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 600103))
     (touch.gloc.of |compile-anonymous`4|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 602144))
   (touch.gloc.of |compile-anonymous`4|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 604180))
 (set.gloc.of |compile-clause`2|)
 (close
   (4 0 . compile-expression-or)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 606227)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #f)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 608280))
     (push.const . const)
     (const . #f)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 609304))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 610323)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 611360)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 611340))
   (call
     (iloc.0 . 3)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 613400)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 614424)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of top-level-value-or-false)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caaddr 1 "./boot/compile.scm" . 615472)
       (apply.gloc.of top-level-value-or-false "./boot/compile.scm" . 615446))
     (push)
     (gloc.of assertion-violation)
     (ret.eq? "./boot/compile.scm" . 615441))
   (if.true
     (call
       (touch.gloc.of compile-expression)
       (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 616484)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616464))
     (push)
     (push.const . if.false.call)
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 616544)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616524))
     (push.cons)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 612363)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 612363))
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 618536)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 618520))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 619548))
 (set.gloc.of compile-expression-or)
 (ret.const.unspec))
((close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 633893)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 633873))
   (push)
   (push.const . if.true.ret.const)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 633962)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 633946))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 632843))
 (set.gloc.of |compile-anonymous-negate`4|)
 (close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 642083)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 642065))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 642122)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 642102))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 642180)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 642164))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 641035)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 641035))
 (set.gloc.of |compile-binary-special`4|)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 629797)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 629777))
   (push)
   (push.const . if.false.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 629819)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 629858)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 629842))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 628747))
 (set.gloc.of |compile-anonymous`4|)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 644116)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 645153)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 645133))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 646176)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 646203)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 646187))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 649262)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 649274)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 650290)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 650317)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 650301))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 652345)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 652337)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.null?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 655413))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.pair?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 657461))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.symbol?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 659509))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 661557))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of |compile-binary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.eq?.ret.const)
             (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 664629))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 665673))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 666720)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 666713)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 666695)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 666689)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667711))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667737))
             (if.true
               (touch.gloc.of |compile-binary-special`4|)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.eq?.ret.const)
               (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 668731))
             (touch.gloc.of |compile-anonymous-negate`4|)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 669755))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 671797))
         (touch.gloc.of |compile-anonymous-negate`4|)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 673838))
       (touch.gloc.of |compile-anonymous-negate`4|)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 675878))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 676907)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 676899)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.null?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 679975))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 682023))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 684071))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 686119))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 689191))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 690235))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 691282)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 691275)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 691257)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 691251)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692273))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692299))
         (if.true
           (touch.gloc.of |compile-binary-special`4|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.not.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 693293))
         (touch.gloc.of |compile-anonymous`4|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 694317))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 696359))
     (touch.gloc.of |compile-anonymous`4|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 698400))
   (touch.gloc.of |compile-anonymous`4|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 700436))
 (set.gloc.of |compile-clause`2|)
 (close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 637989)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 637969))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 638046)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 638030))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 636939))
 (set.gloc.of |compile-unary-special`4|)
 (close
   (4 0 . compile-expression-and)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 702483)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #t)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 704536))
     (push.const . const)
     (const . #t)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 705560))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 706579)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 707616)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 707596))
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 709672)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 709656))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 710684))
 (set.gloc.of compile-expression-and)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . begin)
   (push.gloc.of compile-expression-begin)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 714757)
   (push.iloc.0 . 0)
   (push.const . quote)
   (push.gloc.of compile-expression-quote)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 715781)
   (push.iloc.0 . 0)
   (push.const . define)
   (push.gloc.of compile-expression-define)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 716805)
   (push.iloc.0 . 0)
   (push.const . set!)
   (push.gloc.of compile-expression-set!)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 717829)
   (push.iloc.0 . 0)
   (push.const . lambda)
   (push.gloc.of compile-expression-lambda)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 718853)
   (push.iloc.0 . 0)
   (push.const . let)
   (push.gloc.of compile-expression-let)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 719877)
   (push.iloc.0 . 0)
   (push.const . letrec*)
   (push.gloc.of compile-expression-letrec*)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 720901)
   (push.iloc.0 . 0)
   (push.const . if)
   (push.gloc.of compile-expression-if)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 721925)
   (push.iloc.0 . 0)
   (push.const . or)
   (push.gloc.of compile-expression-or)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 722949)
   (push.iloc.0 . 0)
   (push.const . and)
   (push.gloc.of compile-expression-and)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 723973)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 724997))
 (set.gloc.of ht-dispatch-expression)
 (ret.const.unspec))
((close
   (1 0 . reverse-append)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/compile.scm" . 732169))
 (set.gloc.of |reverse-append`2|)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (touch.gloc.of |loop`7|)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 735256)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 735274)
   (push.iloc.0 . 1)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 735266)
   (apply.gloc.of |loop`7| "./boot/compile.scm" . 735250))
 (set.gloc.of |loop`7|)
 (close
   (4 0 . compile-expression-seq)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (touch.gloc.of |reverse-append`2|)
       (push.iloc.0 . 1)
       (apply.gloc.of |reverse-append`2| "./boot/compile.scm" . 740378))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 747542)
     (call
       (touch.gloc.of compile-expression)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 743448)
       (push.iloc 2 . 1)
       (call
         (iloc 2 . 2)
         (if.true.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 745515)
         (ret.pair? "./boot/compile.scm" . 745508))
       (push)
       (call
         (iloc 2 . 3)
         (if.false.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 746537)
         (ret.null? "./boot/compile.scm" . 746530))
       (push)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 742423))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 747536))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 739333))
 (set.gloc.of compile-expression-seq)
 (ret.const.unspec))
((close
   (4 0 . compile-expression)
   (iloc.0 . 0)
   (if.pair?
     (push.gloc.of ht-dispatch-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 755774)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 755731)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (0 . 0) "./boot/compile.scm" . 756773))
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 757795)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 757779))
     (if.true
       (touch.gloc.of compile-subr-expression)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-subr-expression "./boot/compile.scm" . 758803))
     (call
       (subr.gloc.of backtrace 0 "./boot/compile.scm" . 762916)
       (if.true
         (touch.gloc.of compile-touch)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 762943)
         (push.iloc.1 . 1)
         (apply.gloc.of compile-touch "./boot/compile.scm" . 762928))
       (ret.const))
     (push)
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 761910)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 761887))
     (push)
     (call
       (touch.gloc.of compile-call)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 760877)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 760896)
       (push.subr.gloc.of length 1 "./boot/compile.scm" . 760888)
       (call
         (touch.gloc.of make-application-comment)
         (push.iloc.1 . 0)
         (apply.gloc.of make-application-comment "./boot/compile.scm" . 760908))
       (push)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-call "./boot/compile.scm" . 760863))
     (push)
     (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 763931)
     (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 763931)
     (extend . 1)
     (iloc 2 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 764965))
   (iloc.0 . 3)
   (if.true
     (push.iloc.0 . 0)
     (const . |.&UNDEF|)
     (if.eq?
       (push.const . ret.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 769053)
       (ret.subr.gloc.of list "./boot/compile.scm" . 769047))
     (push.iloc.0 . 0)
     (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 770071)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 771101)
       (ret.subr.gloc.of list "./boot/compile.scm" . 771095))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of iloc?)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 773147))
       (if.true
         (push.const . ret.iloc)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 774185))
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 773143))
       (push.const . ret.gloc.of)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 773143)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 773143))
     (push.const . ret.const)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 776214))
   (iloc.0 . 2)
   (if.true.ret.const)
   (push.iloc.0 . 0)
   (const . |.&UNDEF|)
   (if.eq?
     (push.const . const.undef)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 780317)
     (ret.subr.gloc.of list "./boot/compile.scm" . 780311))
   (push.iloc.0 . 0)
   (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 781335)
   (if.true
     (push.const . const.unspec)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 782365)
     (ret.subr.gloc.of list "./boot/compile.scm" . 782359))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 784411))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 785446))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 786467)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 787505)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 787487))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 788529)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 788511))
       (push.const . iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 789535))
     (push.const . gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 784407)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 784407))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 791574))
 (set.gloc.of compile-expression)
 (ret.const.unspec))
((close
   (1 0 . compile-coreform)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of ht-local-closures)
       (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
     (set.iloc 1 . 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 1)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of compile-expression)
     (push.iloc 2 . 0)
     (push.const)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 0)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (apply.gloc.of |.dynamic-wind| "./boot/compile.scm" . 797703))
 (set.gloc.of compile-coreform)
 (ret.const.unspec))

;
((close
   (3 0 . dynamic-wind)
   (call (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 11269))
   (call
     (touch.gloc.of current-dynamic-wind-record)
     (push.iloc.0 . 0)
     (iloc.0 . 2)
     (push.cons)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12342))
     (push.cons)
     (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12293))
   (push.iloc.0 . 1)
   (push.close
     (0 1)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16429))
       (push)
       (push.subr.gloc.of cdr 1 "./boot/dynamic-wind.scm" . 16424)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16395))
     (call (apply.iloc (1 . 2) "./boot/dynamic-wind.scm" . 17419))
     (push.gloc.of values)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/dynamic-wind.scm" . 18443))
   (apply.gloc.of call-with-values "./boot/dynamic-wind.scm" . 13317))
 (set.gloc.of dynamic-wind)
 (ret.const.unspec))
((close
   (2 0 . common-tail)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25619)
   (push.iloc.0 . 1)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25635)
   (extend . 2)
   (touch.gloc.of |.L0`9|)
   (call
     (iloc.0 . 0)
     (>.iloc (0 . 1) "./boot/dynamic-wind.scm" . 26647)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 26670)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 26657))
     (ret.iloc 1 . 0))
   (push)
   (call
     (iloc.0 . 1)
     (>.iloc (0 . 0) "./boot/dynamic-wind.scm" . 27671)
     (if.true
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 27694)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 27681))
     (ret.iloc 1 . 1))
   (push)
   (apply.gloc.of |.L0`9| "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of |common-tail`2|)
 (close
   (2 0 . |.L0|)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq? (ret.iloc 0 . 0))
   (touch.gloc.of |.L0`9|)
   (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 26684)
   (push.cdr.iloc (0 . 1) "./boot/dynamic-wind.scm" . 27708)
   (apply.gloc.of |.L0`9| "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of |.L0`9|)
 (close
   (3 0 . perform-dynamic-wind)
   (call
     (call
       (touch.gloc.of |common-tail`2|)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 30754))
       (push)
       (apply.gloc.of |common-tail`2| "./boot/dynamic-wind.scm" . 30737))
     (push)
     (extend . 1)
     (call
       (extend.enclose+
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 2 . 0)
         (if.eq? (ret.const.unspec))
         (call
           (touch.gloc.of current-dynamic-wind-record)
           (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 33837)
           (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 33808))
         (call (push.iloc.0 . 0) (subr.gloc.of cdar 1 "./boot/dynamic-wind.scm" . 34833) (apply))
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 35862)
         (apply.iloc+ (1 . 0) "./boot/dynamic-wind.scm" . 35856))
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 31767))
       (push)
       (apply.iloc+ (0 . 0) "./boot/dynamic-wind.scm" . 31751))
     (extend.enclose
       (1 0 . loop)
       (push.iloc.0 . 0)
       (iloc 2 . 0)
       (if.eq? (ret.const.unspec))
       (call
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 38934)
         (apply.iloc (1 . 0) "./boot/dynamic-wind.scm" . 38928))
       (call (push.iloc.0 . 0) (subr.gloc.of caar 1 "./boot/dynamic-wind.scm" . 39953) (apply))
       (touch.gloc.of current-dynamic-wind-record)
       (push.iloc.0 . 0)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 40976))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 36871))
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of apply "./boot/dynamic-wind.scm" . 41989))
 (set.gloc.of perform-dynamic-wind)
 (ret.const.unspec))
((close (0 0) (ret.const . #f))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . call-with-port)
   (push.gloc.of |.fn2.1`2|)
   (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (1 . 1) "./boot/dynamic-wind.scm" . 48145))
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of close-port "./boot/dynamic-wind.scm" . 49169))
   (apply.gloc.of dynamic-wind "./boot/dynamic-wind.scm" . 46085))
 (set.gloc.of call-with-port)
 (ret.const.unspec))

;
((close
   (1 0 . raise)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 7180))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 9233))
     (call
       (call (apply.gloc.of make-non-continuable-violation "./boot/exception.scm" . 10274))
       (push)
       (call (push.const . raise) (apply.gloc.of make-who-condition "./boot/exception.scm" . 11298))
       (push)
       (call
         (push.const . "returned from non-continuable exception")
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 12322))
       (push)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of list 1 "./boot/exception.scm" . 13372)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 13346))
       (push)
       (apply.gloc.of condition "./boot/exception.scm" . 10263))
     (push)
     (apply.iloc (0 . 0) "./boot/exception.scm" . 10257))
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 15372))
   (push.const . "error in raise: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 16479))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 16396))
 (set.gloc.of raise)
 (ret.const.unspec))
((close
   (1 0 . raise-continuable)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 20492))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 21534))
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 23564))
   (push.const . "error in raise-continuable: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 24683))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 24588))
 (set.gloc.of raise-continuable)
 (ret.const.unspec))
((close
   (2 0 . with-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 28691))
   (push)
   (extend . 1)
   (push.const . #f)
   (push.close
     (1 0 . tmp2)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-exception-handler)
         (apply.gloc.of current-exception-handler "./boot/exception.scm" . 33809))
       (set.iloc 1 . 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc 3 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 33809))
     (push.close (0 0) (push.iloc 2 . 0) (apply.iloc (4 . 0) "./boot/exception.scm" . 33809))
     (push.close
       (0 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc.1 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 33809))
     (apply.gloc.of |.dynamic-wind| "./boot/exception.scm" . 33809))
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-exception-handler)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 34825))
     (set.iloc 1 . 0)
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 1)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 34825))
   (push.close (0 0) (apply.iloc (3 . 1) "./boot/exception.scm" . 34825))
   (push.close
     (0 0)
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 0)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 34825))
   (apply.gloc.of |.dynamic-wind| "./boot/exception.scm" . 34825))
 (set.gloc.of with-exception-handler)
 (ret.const.unspec))
((close
   (2 1 . assertion-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-assertion-violation "./boot/exception.scm" . 42011))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 43044))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 44059))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 45106))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 42005)
       (apply.gloc.of filter "./boot/exception.scm" . 40973))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 39942))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 38917))
 (set.gloc.of assertion-violation)
 (ret.const.unspec))
((close
   (1 1 . undefined-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 52251))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 53284))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 54344)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 54320))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 52245)
       (apply.gloc.of filter "./boot/exception.scm" . 51213))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 50182))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 49157))
 (set.gloc.of undefined-violation)
 (ret.const.unspec))
((close
   (1 1 . lexical-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-lexical-violation "./boot/exception.scm" . 61467))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 62500))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 63560)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 63536))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 61461)
       (apply.gloc.of filter "./boot/exception.scm" . 60429))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 59398))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 58373))
 (set.gloc.of lexical-violation)
 (ret.const.unspec))
((close
   (3 1 . syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 70732))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 70683))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 71716))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 72731))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 70677)
       (apply.gloc.of filter "./boot/exception.scm" . 69645))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 68614))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 67589))
 (set.gloc.of syntax-violation)
 (ret.const.unspec))
((close
   (2 1 . error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-error "./boot/exception.scm" . 79899))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 80932))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 81947))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 82994))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 79893)
       (apply.gloc.of filter "./boot/exception.scm" . 78861))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 77830))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 76805))
 (set.gloc.of error)
 (ret.const.unspec))
((close
   (2 1 . implementation-restriction-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (apply.gloc.of make-implementation-restriction-violation "./boot/exception.scm" . 90139))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 91172))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 92187))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 93234))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 90133)
       (apply.gloc.of filter "./boot/exception.scm" . 89101))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 88070))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 87045))
 (set.gloc.of implementation-restriction-violation)
 (ret.const.unspec))
((close
   (3 1 . undefined/syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 100428))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 100379))
       (push)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 101403))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 102436))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 103451))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 100373)
       (apply.gloc.of filter "./boot/exception.scm" . 99341))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 98310))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 97285))
 (set.gloc.of undefined/syntax-violation)
 (ret.const.unspec))
((close
   (0 1 . scheme-error)
   (push.const . #t)
   (push.const . "~!")
   (subr.gloc.of format 2 "./boot/exception.scm" . 107525)
   (subr.gloc.of current-error-port 0)
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 108589))
   (if.true
     (call
       (push.gloc.of format)
       (push.iloc.1 . 0)
       (apply.gloc.of apply "./boot/exception.scm" . 109594))
     (push)
     (apply.gloc.of raise "./boot/exception.scm" . 109587))
   (push.iloc.0 . 0)
   (push.const . "~&~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 111630)
   (call
     (push.gloc.of format)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of apply "./boot/exception.scm" . 112654))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 113678)
   (subr.gloc.of display-backtrace 0 "./boot/exception.scm" . 114702)
   (push.iloc.0 . 0)
   (push.const . "~%[exit]~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 115726)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/exception.scm" . 116750))
 (set.gloc.of scheme-error)
 (ret.const.unspec))
((close
   (3 1 . raise-i/o-filename-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-i/o-filename-error "./boot/exception.scm" . 123931))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 124964))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 125979))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 127026))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 123925)
       (apply.gloc.of filter "./boot/exception.scm" . 122893))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 121862))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 120837))
 (set.gloc.of raise-i/o-filename-error)
 (ret.const.unspec))
((close
   (2 1 . raise-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-i/o-error "./boot/exception.scm" . 134171))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 135204))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 136219))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 137266))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 134165)
       (apply.gloc.of filter "./boot/exception.scm" . 133133))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 132102))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 131077))
 (set.gloc.of raise-i/o-error)
 (ret.const.unspec))
((close
   (4 1 . raise-misc-i/o-error-with-port)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 4)
         (apply.gloc.of apply "./boot/exception.scm" . 145435))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 146468))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 147483))
       (push)
       (call
         (iloc.0 . 3)
         (if.false.ret)
         (push.iloc.0 . 3)
         (apply.gloc.of make-i/o-port-error "./boot/exception.scm" . 148517))
       (push)
       (call
         (push.iloc.0 . 3)
         (push.iloc.0 . 4)
         (push.subr.gloc.of cons* 2 "./boot/exception.scm" . 149557)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 149531))
       (push)
       (push.subr.gloc.of list 5 "./boot/exception.scm" . 145429)
       (apply.gloc.of filter "./boot/exception.scm" . 144397))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 143366))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 142341))
 (set.gloc.of raise-misc-i/o-error-with-port)
 (ret.const.unspec))
((close
   (3 1 . raise-misc-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of apply "./boot/exception.scm" . 156699))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 157732))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 158747))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 160800))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 156693)
       (apply.gloc.of filter "./boot/exception.scm" . 155661))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 154630))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 153605))
 (set.gloc.of raise-misc-i/o-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-read-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-read-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 164869))
 (set.gloc.of raise-i/o-read-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-write-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-write-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 168965))
 (set.gloc.of raise-i/o-write-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-protection-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-protection-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 173061))
 (set.gloc.of raise-i/o-file-protection-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-is-read-only-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-file-is-read-only-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 177157))
 (set.gloc.of raise-i/o-file-is-read-only-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-already-exists-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-already-exists-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 181253))
 (set.gloc.of raise-i/o-file-already-exists-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-does-not-exist-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-does-not-exist-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 185349))
 (set.gloc.of raise-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-invalid-position-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-invalid-position-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 189445))
 (set.gloc.of raise-i/o-invalid-position-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-decoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-decoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 193541))
 (set.gloc.of raise-i/o-decoding-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-encoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-encoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 197637))
 (set.gloc.of raise-i/o-encoding-error)
 (ret.const.unspec))

;
((subr.gloc.of make-weak-core-hashtable 0 "./boot/record.scm" . 5156)
 (set.gloc.of nongenerative-record-types)
 (ret.const.unspec))
((close
   (6 0 . make-rtd)
   (push.const . type:record-type-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.iloc.0 . 5)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 9221))
 (set.gloc.of make-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 13322)
   (const . type:record-type-descriptor)
   (ret.eq? "./boot/record.scm" . 13317))
 (set.gloc.of record-type-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rtd-name)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 15395))
 (set.gloc.of rtd-name)
 (ret.const.unspec))
((close
   (1 0 . rtd-parent)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 16419))
 (set.gloc.of rtd-parent)
 (ret.const.unspec))
((close
   (1 0 . rtd-uid)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 17443))
 (set.gloc.of rtd-uid)
 (ret.const.unspec))
((close
   (1 0 . rtd-sealed?)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 18467))
 (set.gloc.of rtd-sealed?)
 (ret.const.unspec))
((close
   (1 0 . rtd-opaque?)
   (push.iloc.0 . 0)
   (push.const . 5)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 19491))
 (set.gloc.of rtd-opaque?)
 (ret.const.unspec))
((close
   (1 0 . rtd-fields)
   (push.iloc.0 . 0)
   (push.const . 6)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 20515))
 (set.gloc.of rtd-fields)
 (ret.const.unspec))
((close
   (2 0 . rtd-ancestor?)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc 2 . 0)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (iloc.0 . 0)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 27670))
     (push)
     (apply.iloc+ (1 . 0) "./boot/record.scm" . 27664))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/record.scm" . 24581))
 (set.gloc.of rtd-ancestor?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |loop`5|)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 33812))
     (push)
     (push.iloc.0 . 1)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 34853))
     (push)
     (push.subr.gloc.of length 1 "./boot/record.scm" . 34845)
     (push.subr.gloc.of + 2 "./boot/record.scm" . 34836)
     (apply.gloc.of |loop`5| "./boot/record.scm" . 33806))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . rtd-inherited-field-count)
   (touch.gloc.of |loop`5|)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 31765))
   (push)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/record.scm" . 31749))
 (set.gloc.of rtd-inherited-field-count)
 (ret.const.unspec))
((close
   (1 0 . rtd-total-field-count)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 40968))
   (push)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 41008))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 41000)
   (ret.subr.gloc.of + "./boot/record.scm" . 40965))
 (set.gloc.of rtd-total-field-count)
 (ret.const.unspec))
((close
   (1 0 . record-type-name)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 45065))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 46128))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 46089))
   (touch.gloc.of rtd-name)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-name "./boot/record.scm" . 47109))
 (set.gloc.of record-type-name)
 (ret.const.unspec))
((close
   (1 0 . record-type-parent)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 51209))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 52272))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 52233))
   (touch.gloc.of rtd-parent)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-parent "./boot/record.scm" . 53253))
 (set.gloc.of record-type-parent)
 (ret.const.unspec))
((close
   (1 0 . record-type-uid)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 57353))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 58416))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 58377))
   (touch.gloc.of rtd-uid)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-uid "./boot/record.scm" . 59397))
 (set.gloc.of record-type-uid)
 (ret.const.unspec))
((close
   (1 0 . record-type-generative?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 63497))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 64560))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 64521))
   (call
     (touch.gloc.of rtd-uid)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-uid "./boot/record.scm" . 65546))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 65541))
 (set.gloc.of record-type-generative?)
 (ret.const.unspec))
((close
   (1 0 . record-type-sealed?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 69641))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 70704))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 70665))
   (touch.gloc.of rtd-sealed?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-sealed? "./boot/record.scm" . 71685))
 (set.gloc.of record-type-sealed?)
 (ret.const.unspec))
((close
   (1 0 . record-type-opaque?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 75785))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 76848))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 76809))
   (touch.gloc.of rtd-opaque?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-opaque? "./boot/record.scm" . 77829))
 (set.gloc.of record-type-opaque?)
 (ret.const.unspec))
((close
   (1 0 . record-type-field-names)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 81929))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 82992))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 82953))
   (call
     (push.gloc.of cdr)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 83996))
     (push)
     (apply.gloc.of map "./boot/record.scm" . 83987))
   (push)
   (apply.gloc.of list->vector "./boot/record.scm" . 83973))
 (set.gloc.of record-type-field-names)
 (ret.const.unspec))
((close
   (2 0 . record-field-mutable?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 88073))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 89136))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 89197)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 89097))
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 90132))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-ref 2 "./boot/record.scm" . 90122)
   (ret.subr.gloc.of car "./boot/record.scm" . 90117))
 (set.gloc.of record-field-mutable?)
 (ret.const.unspec))
((close
   (6 0 . make-record-type-descriptor)
   (push.iloc.0 . 0)
   (subr.gloc.of symbol? 1 "./boot/record.scm" . 94217)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "symbol")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 96286))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 97310)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 95241))
   (push.iloc.0 . 5)
   (subr.gloc.of vector? 1 "./boot/record.scm" . 98313)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "vector")
       (push.iloc.0 . 5)
       (push.const . 6)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 100382))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 101406)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 99337))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call (push.iloc.0 . 1) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 103438))
     (if.false.call
       (push.const . make-record-type-descriptor)
       (call
         (touch.gloc.of wrong-type-argument-message)
         (push.const . "record-type descriptor or #f")
         (push.iloc.0 . 1)
         (push.const . 2)
         (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 105507))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.iloc.0 . 4)
       (push.iloc.0 . 5)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 106531)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 104462))
     (if.false.ret)
     (call
       (touch.gloc.of rtd-sealed?)
       (push.iloc.0 . 1)
       (apply.gloc.of rtd-sealed? "./boot/record.scm" . 107535))
     (if.false.ret)
     (push.const . make-record-type-descriptor)
     (push.const . "attempt to extend a sealed record-type")
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 108559))
   (call
     (iloc.0 . 4)
     (if.true.ret)
     (iloc.0 . 1)
     (if.false.ret)
     (touch.gloc.of rtd-opaque?)
     (push.iloc.0 . 1)
     (apply.gloc.of rtd-opaque? "./boot/record.scm" . 111645))
   (push)
   (call
     (push.close
       (1 0)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (ret.null? "./boot/record.scm" . 113690))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . mutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #t)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . immutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #f)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (push.const . make-record-type-descriptor)
       (push.const . "malformed field specifiers")
       (push.iloc 2 . 5)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 113690))
     (push.iloc.0 . 5)
     (push.subr.gloc.of vector->list 1 "./boot/record.scm" . 120856)
     (apply.gloc.of map "./boot/record.scm" . 109573))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of make-rtd)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of make-rtd "./boot/record.scm" . 121874))
   (push)
   (extend . 1)
   (iloc 2 . 2)
   (if.true
     (push.gloc.of nongenerative-record-types)
     (push.iloc 2 . 2)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/record.scm" . 123920)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 125988))
         (push)
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 126002))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 125982)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127012))
         (push)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127029))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 127006)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128038))
         (push)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128055))
         (push)
         (ret.subr.gloc.of equal? "./boot/record.scm" . 128030))
       (if.true (ret.iloc 0 . 0))
       (push.const . make-record-type-descriptor)
       (push.const . "mismatched subsequent call for nongenerative record-type")
       (push.iloc 3 . 0)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (push.iloc 3 . 3)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 132142)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 130073))
     (push.gloc.of nongenerative-record-types)
     (push.iloc 3 . 2)
     (push.iloc.1 . 0)
     (subr.gloc.of core-hashtable-set! 3 "./boot/record.scm" . 134167)
     (ret.iloc 1 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of make-record-type-descriptor)
 (ret.const.unspec))
((close
   (4 0 . make-rcd)
   (push.const . type:record-constructor-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 138245))
 (set.gloc.of make-rcd)
 (ret.const.unspec))
((close
   (1 0 . record-constructor-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 142346)
   (const . type:record-constructor-descriptor)
   (ret.eq? "./boot/record.scm" . 142341))
 (set.gloc.of record-constructor-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rcd-rtd)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 144428))
 (set.gloc.of rcd-rtd)
 (ret.const.unspec))
((close
   (1 0 . rcd-protocol)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 145452))
 (set.gloc.of rcd-protocol)
 (ret.const.unspec))
((close
   (1 0 . rcd-custom-protocol?)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 146476))
 (set.gloc.of rcd-custom-protocol?)
 (ret.const.unspec))
((close
   (1 0 . rcd-parent)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 147500))
 (set.gloc.of rcd-parent)
 (ret.const.unspec))
((close
   (1 0)
   (ret.close
     (0 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/record.scm" . 160783)))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . default-protocol)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 151571))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 153637))
     (push)
     (extend . 1)
     (ret.close
       (1 0)
       (ret.close
         (0 1)
         (push.close
           (0 0)
           (touch.gloc.of split-at)
           (push.iloc.1 . 0)
           (push.iloc 3 . 0)
           (apply.gloc.of split-at "./boot/record.scm" . 156743))
         (push.close
           (2 0)
           (call
             (push.iloc 2 . 0)
             (push.iloc.0 . 0)
             (apply.gloc.of apply "./boot/record.scm" . 157722))
           (push)
           (push.iloc.0 . 1)
           (apply.gloc.of apply "./boot/record.scm" . 157715))
         (apply.gloc.of |.call-with-values| "./boot/record.scm" . 155663))))
   (ret.gloc.of |.fn2.1`2|))
 (set.gloc.of default-protocol)
 (ret.const.unspec))
((close
   (3 0 . make-record-constructor-descriptor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 164873))
   (if.false.call
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 166942))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 167966)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 165897))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of record-constructor-descriptor?)
       (push.iloc.0 . 1)
       (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 169998))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor or #f")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 172067))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 173091)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 171022))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (push.iloc.0 . 2)
     (subr.gloc.of procedure? 1 "./boot/record.scm" . 175118)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "procedure or #f")
       (push.iloc.0 . 2)
       (push.const . 3)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 177187))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 178211)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 176142))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 180238))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 181262))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 186378))
     (if.false.ret)
     (call
       (touch.gloc.of rcd-rtd)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-rtd "./boot/record.scm" . 187411))
     (push)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 187428))
     (if.eq?.ret.const . #t)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 188430))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 193546))
     (if.false.ret)
     (iloc.0 . 1)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "expected #f for protocol since no parent constructor descriptor is provided")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 195598))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rcd-custom-protocol?)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-custom-protocol? "./boot/record.scm" . 200714))
     (if.false.ret)
     (iloc.0 . 2)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const
       .
       "expected procedure for protocol since parent constructor descriptor have custom one")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 202766))
   (touch.gloc.of make-rcd)
   (push.iloc.0 . 0)
   (call
     (iloc.0 . 2)
     (if.true.ret)
     (touch.gloc.of default-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of default-protocol "./boot/record.scm" . 208930))
   (push)
   (call (iloc.0 . 2) (if.false.ret) (ret.const . #t))
   (push)
   (call
     (iloc.0 . 1)
     (if.true.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 210974))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of make-record-constructor-descriptor "./boot/record.scm" . 213027))
     (ret.const . #f))
   (push)
   (apply.gloc.of make-rcd "./boot/record.scm" . 215047))
 (set.gloc.of make-record-constructor-descriptor)
 (ret.const.unspec))
((close
   (1 0 . record?)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 219171)
     (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 219146))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 220196)
     (apply.gloc.of record-type-opaque? "./boot/record.scm" . 220175))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 220170))
 (set.gloc.of record?)
 (ret.const.unspec))
((close
   (1 0 . record-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/record.scm" . 224265))
   (if.true
     (push.iloc.0 . 0)
     (push.const . 0)
     (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 225289))
   (push.const . record-rtd)
   (call
     (touch.gloc.of wrong-type-argument-message)
     (push.const . "non-opaque record")
     (push.iloc.0 . 0)
     (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 226346))
   (push)
   (apply.gloc.of assertion-violation "./boot/record.scm" . 226313))
 (set.gloc.of record-rtd)
 (ret.const.unspec))
((close
   (3 0 . make-nested-conser)
   (call
     (call
       (extend.enclose
         (1 0 . loop)
         (call
           (touch.gloc.of rcd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rcd-parent "./boot/record.scm" . 232464))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (ret.close
             (0 1)
             (ret.close
               (0 1)
               (ret.close
                 (0 1)
                 (call
                   (call
                     (call (push.iloc 3 . 0) (apply.iloc (5 . 0) "./boot/record.scm" . 238634))
                     (push)
                     (push.iloc.0 . 0)
                     (push.iloc 2 . 0)
                     (push.subr.gloc.of append 2 "./boot/record.scm" . 239658)
                     (apply.gloc.of apply "./boot/record.scm" . 238627))
                   (push)
                   (call
                     (touch.gloc.of rcd-protocol)
                     (push.iloc 3 . 0)
                     (apply.gloc.of rcd-protocol "./boot/record.scm" . 237603))
                   (apply))
                 (push)
                 (push.iloc.1 . 0)
                 (apply.gloc.of apply "./boot/record.scm" . 237595)))))
         (ret.close
           (0 1)
           (ret.close
             (0 1)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.subr.gloc.of append 2 "./boot/record.scm" . 244776)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of length 1 "./boot/record.scm" . 245789)
             (=.iloc (6 . 2) "./boot/record.scm" . 245786)
             (if.true
               (push.gloc.of tuple)
               (push.iloc 6 . 1)
               (push.iloc.0 . 0)
               (apply.gloc.of apply "./boot/record.scm" . 246810))
             (push.const . "record constructor")
             (push.const . "wrong number of arguments")
             (push.iloc.0 . 0)
             (apply.gloc.of assertion-violation "./boot/record.scm" . 247834))))
       (push.iloc.1 . 0)
       (apply.iloc (0 . 0) "./boot/record.scm" . 231431))
     (apply))
   (push)
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 230406))
   (apply))
 (set.gloc.of make-nested-conser)
 (ret.const.unspec))
((close
   (3 0 . make-simple-conser)
   (push.close
     (0 1)
     (push.iloc.0 . 0)
     (subr.gloc.of length 1 "./boot/record.scm" . 253967)
     (=.iloc (1 . 2) "./boot/record.scm" . 253964)
     (if.true
       (push.gloc.of tuple)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of apply "./boot/record.scm" . 254988))
     (push.const . "record constructor")
     (push.const . "wrong number of arguments")
     (push.iloc.0 . 0)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 256012))
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 251910))
   (apply))
 (set.gloc.of make-simple-conser)
 (ret.const.unspec))
((close
   (2 0 . flat-field-offset)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 260104))
   (push)
   (push.iloc.0 . 1)
   (push.const . 1)
   (ret.subr.gloc.of + "./boot/record.scm" . 260101))
 (set.gloc.of flat-field-offset)
 (ret.const.unspec))
((close
   (2 0 . make-accessor)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 265239)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 265258))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 266273)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 266254))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 266292))
     (push.const . "record accessor")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 268398))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 268370)
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 268341))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 268302)))
 (set.gloc.of make-accessor)
 (ret.const.unspec))
((close
   (2 0 . make-mutator)
   (ret.close
     (2 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 273431)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 273450))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 274465)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 274446))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 274484))
     (push.const . "record mutator")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 276589))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 276561)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of list 2 "./boot/record.scm" . 276605)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 276532))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 276494)))
 (set.gloc.of make-mutator)
 (ret.const.unspec))
((close
   (1 0 . make-predicate)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 281620)
     (if.eq?.ret.const . #t)
     (touch.gloc.of rtd-ancestor?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 282654)
     (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 282635)))
 (set.gloc.of make-predicate)
 (ret.const.unspec))
((close
   (1 0 . record-constructor)
   (call
     (touch.gloc.of record-constructor-descriptor?)
     (push.iloc.0 . 0)
     (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 286729))
   (if.false.call
     (push.const . record-constructor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 287794))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 287753))
   (call
     (touch.gloc.of rcd-rtd)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-rtd "./boot/record.scm" . 288784))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of rcd-parent)
     (push.iloc.1 . 0)
     (apply.gloc.of rcd-parent "./boot/record.scm" . 289803))
   (if.true
     (touch.gloc.of make-nested-conser)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 290856))
     (push)
     (apply.gloc.of make-nested-conser "./boot/record.scm" . 290827))
   (touch.gloc.of make-simple-conser)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 291888))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 291880)
   (apply.gloc.of make-simple-conser "./boot/record.scm" . 291851))
 (set.gloc.of record-constructor)
 (ret.const.unspec))
((close
   (1 0 . record-predicate)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 295945))
   (if.false.call
     (push.const . record-predicate)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 297008))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 296969))
   (touch.gloc.of make-predicate)
   (push.iloc.0 . 0)
   (apply.gloc.of make-predicate "./boot/record.scm" . 297989))
 (set.gloc.of record-predicate)
 (ret.const.unspec))
((close
   (2 0 . record-accessor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 302089))
   (if.false.call
     (push.const . record-accssor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 303150))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 303209)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 303113))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 304153))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 304145)
   (subr.gloc.of < 3 "./boot/record.scm" . 304137)
   (if.false.call
     (push.const . record-accssor)
     (push.const . "field index out of range")
     (apply.gloc.of assertion-violation "./boot/record.scm" . 305161))
   (touch.gloc.of make-accessor)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 306200))
   (push)
   (apply.gloc.of make-accessor "./boot/record.scm" . 306181))
 (set.gloc.of record-accessor)
 (ret.const.unspec))
((close
   (2 0 . record-mutator)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 310281))
   (if.false.call
     (push.const . record-mutator)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 311342))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 311401)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 311305))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 312345))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 312337)
   (subr.gloc.of < 3 "./boot/record.scm" . 312329)
   (if.false.call
     (push.const . record-mutator)
     (push.const . "field index out of range")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 313417)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 313353))
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of record-field-mutable? "./boot/record.scm" . 314377))
   (if.false.call
     (push.const . record-mutator)
     (push.const . "specified field is immutable")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 315469)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 315401))
   (touch.gloc.of make-mutator)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 316439))
   (push)
   (apply.gloc.of make-mutator "./boot/record.scm" . 316421))
 (set.gloc.of record-mutator)
 (ret.const.unspec))
((close
   (3 0 . make-record-type)
   (push.const . type:record-type)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 320517))
 (set.gloc.of make-record-type)
 (ret.const.unspec))
((close
   (1 0 . record-type?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 324618)
   (const . type:record-type)
   (ret.eq? "./boot/record.scm" . 324613))
 (set.gloc.of record-type?)
 (ret.const.unspec))
((close
   (1 0 . record-type-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 328713))
   (if.false.call
     (push.const . record-type-rtd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 329775))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 329737))
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 330757))
 (set.gloc.of record-type-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-rcd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 334857))
   (if.false.call
     (push.const . record-type-rcd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 335919))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 335881))
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 336901))
 (set.gloc.of record-type-rcd)
 (ret.const.unspec))

;
((call
   (call
     (push.const . &condition)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 6159))
   (push)
   (extend . 1)
   (push.const . &condition)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 7183))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 8197))
 (set.gloc.of &condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition-component)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/condition.scm" . 10292))
 (set.gloc.of compound-condition-component)
 (ret.const.unspec))
((close
   (0 1 . condition)
   (push.const . type:condition)
   (call
     (push.gloc.of append)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of condition? "./boot/condition.scm" . 17438))
         (if.false.call
           (push.const . condition)
           (push.const . "expected condition, but got ~r")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/condition.scm" . 18494)
           (push.iloc.1 . 0)
           (apply.gloc.of assertion-violation "./boot/condition.scm" . 18462))
         (push.iloc.0 . 0)
         (apply.gloc.of simple-conditions "./boot/condition.scm" . 19482))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/condition.scm" . 16403))
     (push)
     (apply.gloc.of apply "./boot/condition.scm" . 15372))
   (push)
   (ret.subr.gloc.of tuple "./boot/condition.scm" . 14341))
 (set.gloc.of condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition?)
   (push.iloc.0 . 0)
   (subr.gloc.of tuple? 1 "./boot/condition.scm" . 24586)
   (if.false.ret)
   (push.const . type:condition)
   (push.iloc.0 . 0)
   (push.const . 0)
   (subr.gloc.of tuple-ref 2 "./boot/condition.scm" . 25631)
   (ret.eq? "./boot/condition.scm" . 25610))
 (set.gloc.of compound-condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-condition?)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/condition.scm" . 29706))
   (if.false.ret)
   (touch.gloc.of rtd-ancestor?)
   (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 30745))
   (push)
   (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 30774))
   (push)
   (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 30730))
 (set.gloc.of simple-condition?)
 (ret.const.unspec))
((close
   (1 0 . condition?)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 34825))
   (if.true.ret)
   (touch.gloc.of compound-condition?)
   (push.iloc.0 . 0)
   (apply.gloc.of compound-condition? "./boot/condition.scm" . 35849))
 (set.gloc.of condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-conditions)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 39948))
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of list "./boot/condition.scm" . 39970))
   (call
     (touch.gloc.of compound-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition? "./boot/condition.scm" . 40972))
   (if.true
     (touch.gloc.of compound-condition-component)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition-component "./boot/condition.scm" . 40996))
   (push.const . simple-conditions)
   (push.const . "expected condition, but got ~r")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/condition.scm" . 43060)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 43020))
 (set.gloc.of simple-conditions)
 (ret.const.unspec))
((close
   (1 0 . condition-predicate)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 47128))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 47113))
   (if.false.call
     (push.const . condition-predicate)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 48179)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 48137))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 50190))
     (if.true
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 51233))
       (push)
       (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 51214))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 52238))
     (if.true
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of rtd-ancestor?)
         (push.iloc 2 . 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 53307))
         (push)
         (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 53288))
       (call
         (touch.gloc.of compound-condition-component)
         (push.iloc.0 . 0)
         (apply.gloc.of compound-condition-component "./boot/condition.scm" . 54292))
       (push)
       (apply.gloc.of any1 "./boot/condition.scm" . 53262))
     (ret.const . #f)))
 (set.gloc.of condition-predicate)
 (ret.const.unspec))
((close
   (2 0 . wrong-type)
   (push.const . "condition accessor")
   (push.const . "expected condition of a subtype of ~s, but got ~r")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 3 "./boot/condition.scm" . 62515)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 62473))
 (set.gloc.of |wrong-type`2|)
 (close
   (2 0 . condition-accessor)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 64536))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 64521))
   (if.false.call
     (push.const . condition-accessor)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 65586)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 65545))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 68622))
     (if.true
       (call
         (call
           (touch.gloc.of rtd-ancestor?)
           (push.iloc.1 . 0)
           (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 69669))
           (push)
           (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 69650))
         (if.true.ret)
         (touch.gloc.of |wrong-type`2|)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 69687))
       (push.iloc.0 . 0)
       (apply.iloc (1 . 1) "./boot/condition.scm" . 70670))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 71694))
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of rtd-ancestor?)
             (push.iloc 2 . 0)
             (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 72775))
             (push)
             (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 72756))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call
           (touch.gloc.of compound-condition-component)
           (push.iloc.0 . 0)
           (apply.gloc.of compound-condition-component "./boot/condition.scm" . 73755))
         (push)
         (apply.gloc.of any1 "./boot/condition.scm" . 72725))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (apply.iloc (2 . 1) "./boot/condition.scm" . 72718))
       (touch.gloc.of |wrong-type`2|)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 76821))
     (touch.gloc.of |wrong-type`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 78862)))
 (set.gloc.of condition-accessor)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-parent "./boot/condition.scm" . 87058))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |loop`7|)
     (push.iloc.0 . 0)
     (call (push.iloc.0 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 88111))
     (push)
     (iloc.1 . 1)
     (push.cons)
     (apply.gloc.of |loop`7| "./boot/condition.scm" . 88097))
   (push.cdr.iloc (1 . 1) "./boot/condition.scm" . 89120)
   (ret.subr.gloc.of reverse "./boot/condition.scm" . 89111))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . list-parents)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/condition.scm" . 86025))
 (set.gloc.of |list-parents`2|)
 (close
   (2 0 . describe-condition)
   (call (push.iloc.0 . 1) (apply.gloc.of condition? "./boot/condition.scm" . 91148))
   (if.true
     (subr.gloc.of make-string-output-port 0)
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . "  #<condition~!")
     (subr.gloc.of format 2 "./boot/condition.scm" . 93198)
     (call
       (call (push.iloc.1 . 1) (apply.gloc.of simple-conditions "./boot/condition.scm" . 94233))
       (push)
       (extend . 1)
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 96295))
         (push)
         (extend . 1)
         (call (push.iloc.0 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 97322))
         (push)
         (call
           (touch.gloc.of |list-parents`2|)
           (push.iloc.0 . 0)
           (apply.gloc.of |list-parents`2| "./boot/condition.scm" . 98349))
         (push)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of record-type-field-names "./boot/condition.scm" . 99386))
         (push)
         (push.subr.gloc.of vector-length 1 "./boot/condition.scm" . 99371)
         (extend . 3)
         (call
           (call
             (push.iloc 3 . 0)
             (push.subr.gloc.of length 1 "./boot/condition.scm" . 100396)
             (push.const . 1)
             (subr.gloc.of > 2 "./boot/condition.scm" . 100393)
             (if.true.ret)
             (push.iloc.0 . 2)
             (push.const . 1)
             (ret.subr.gloc.of > "./boot/condition.scm" . 100412))
           (if.false.ret)
           (push.iloc 4 . 0)
           (push.const . "~%   ")
           (ret.subr.gloc.of format "./boot/condition.scm" . 101413))
         (push.iloc 4 . 0)
         (push.const . " ~a")
         (push.iloc.0 . 0)
         (subr.gloc.of format 3 "./boot/condition.scm" . 102432)
         (call
           (iloc.0 . 1)
           (if.not.pair?.ret.const . #f)
           (push.iloc 4 . 0)
           (push.const . " ~s")
           (push.iloc.0 . 1)
           (ret.subr.gloc.of format "./boot/condition.scm" . 103477))
         (=n.iloc (0 . 2) 1 "./boot/condition.scm" . 104487)
         (if.true
           (push.iloc 4 . 0)
           (push.const . ": ~s")
           (call
             (push.iloc 2 . 0)
             (call
               (push.iloc.1 . 0)
               (push.const . 0)
               (apply.gloc.of record-accessor "./boot/condition.scm" . 105531))
             (apply))
           (push)
           (ret.subr.gloc.of format "./boot/condition.scm" . 105511))
         (>n.iloc (0 . 2) 1 "./boot/condition.scm" . 106535)
         (if.true
           (extend.enclose+
             (2 0 . loop)
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.iloc 6 . 0)
             (push.const . "~%     ~a: ~s")
             (push.car.iloc (0 . 1) "./boot/condition.scm" . 111694)
             (call
               (push.iloc 4 . 0)
               (call
                 (push.iloc 3 . 0)
                 (push.iloc.0 . 0)
                 (apply.gloc.of record-accessor "./boot/condition.scm" . 111705))
               (apply))
             (push)
             (subr.gloc.of format 4 "./boot/condition.scm" . 111666)
             (push.n+.iloc (0 . 0) 1 "./boot/condition.scm" . 112696)
             (push.cdr.iloc (0 . 1) "./boot/condition.scm" . 112704)
             (apply.iloc+ (1 . 0) "./boot/condition.scm" . 112690))
           (push.const . 0)
           (call
             (push.iloc 2 . 0)
             (apply.gloc.of record-type-field-names "./boot/condition.scm" . 107584))
           (push)
           (push.subr.gloc.of vector->list 1 "./boot/condition.scm" . 107570)
           (apply.iloc+ (0 . 0) "./boot/condition.scm" . 108585))
         (ret.const.unspec))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/condition.scm" . 94222))
     (push.iloc.0 . 0)
     (push.const . "~%   >")
     (subr.gloc.of format 2 "./boot/condition.scm" . 114702)
     (push.iloc.1 . 0)
     (push.const . "~a~!")
     (push.iloc.0 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/condition.scm" . 115746)
     (ret.subr.gloc.of format "./boot/condition.scm" . 115726))
   (push.iloc.0 . 0)
   (push.const . "~s~!")
   (push.iloc.0 . 1)
   (ret.subr.gloc.of format "./boot/condition.scm" . 117772))
 (set.gloc.of describe-condition)
 (ret.const.unspec))
((call
   (call
     (push.const . &message)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 120885))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable message)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 120846))
   (push)
   (extend . 1)
   (push.const . &message)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 121912))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 121872))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 122887))
 (set.gloc.of &message)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 123956))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 123936))
 (set.gloc.of make-message-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 124977))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 124956))
 (set.gloc.of message-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 125999))
   (push)
   (call
     (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 126043))
     (push)
     (push.const . 0)
     (apply.gloc.of record-accessor "./boot/condition.scm" . 126026))
   (push)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 125979))
 (set.gloc.of condition-message)
 (ret.const.unspec))
((call
   (call
     (push.const . &warning)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 129077))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 129038))
   (push)
   (extend . 1)
   (push.const . &warning)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 130104))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 130064))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 131079))
 (set.gloc.of &warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 132138))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 132118))
 (set.gloc.of make-warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 133159))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 133138))
 (set.gloc.of warning?)
 (ret.const.unspec))
((call
   (call
     (push.const . &serious)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 136245))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 136206))
   (push)
   (extend . 1)
   (push.const . &serious)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 137272))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 137232))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 138247))
 (set.gloc.of &serious)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 139316))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 139296))
 (set.gloc.of make-serious-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 140337))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 140316))
 (set.gloc.of serious-condition?)
 (ret.const.unspec))
((call
   (call
     (push.const . &error)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 143411))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 143374))
   (push)
   (extend . 1)
   (push.const . &error)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 144440))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 144400))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 145415))
 (set.gloc.of &error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 146472))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 146452))
 (set.gloc.of make-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 147493))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 147472))
 (set.gloc.of error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &violation)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 150583))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 150542))
   (push)
   (extend . 1)
   (push.const . &violation)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 151608))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 151568))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 152583))
 (set.gloc.of &violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 153644))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 153624))
 (set.gloc.of make-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 154665))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 154644))
 (set.gloc.of violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &assertion)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 157751))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 157710))
   (push)
   (extend . 1)
   (push.const . &assertion)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 158776))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 158736))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 159751))
 (set.gloc.of &assertion)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 160822))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 160802))
 (set.gloc.of make-assertion-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 161843))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 161822))
 (set.gloc.of assertion-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &irritants)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 164919))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable irritants)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 164878))
   (push)
   (extend . 1)
   (push.const . &irritants)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 165944))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 165904))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 166919))
 (set.gloc.of &irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 167983))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 167966))
 (set.gloc.of &irritants-irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 169014))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 168994))
 (set.gloc.of make-irritants-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 170035))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 170014))
 (set.gloc.of irritants-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 171057))
   (push)
   (push.gloc.of &irritants-irritants)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 171037))
 (set.gloc.of condition-irritants)
 (ret.const.unspec))
((call
   (call
     (push.const . &who)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 174129))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable who)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 174094))
   (push)
   (extend . 1)
   (push.const . &who)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 175160))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 175120))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 176135))
 (set.gloc.of &who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 177187))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 177170))
 (set.gloc.of &who-who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 178224))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 178204))
 (set.gloc.of make-who-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 179245))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 179224))
 (set.gloc.of who-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 180267))
   (push)
   (push.gloc.of &who-who)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 180247))
 (set.gloc.of condition-who)
 (ret.const.unspec))
((call
   (call
     (push.const . &non-continuable)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 183357))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 183310))
   (push)
   (extend . 1)
   (push.const . &non-continuable)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 184376))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 184336))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 185351))
 (set.gloc.of &non-continuable)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 186428))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 186408))
 (set.gloc.of make-non-continuable-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 187449))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 187428))
 (set.gloc.of non-continuable-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &implementation-restriction)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 190536))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 190478))
   (push)
   (extend . 1)
   (push.const . &implementation-restriction)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 191544))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 191504))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 192519))
 (set.gloc.of &implementation-restriction)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 194583))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 194563))
 (set.gloc.of make-implementation-restriction-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 196632))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 196611))
 (set.gloc.of implementation-restriction-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &lexical)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 199733))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 199694))
   (push)
   (extend . 1)
   (push.const . &lexical)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 200760))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 200720))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 201735))
 (set.gloc.of &lexical)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 202804))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 202784))
 (set.gloc.of make-lexical-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 203825))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 203804))
 (set.gloc.of lexical-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &syntax)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 206900))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable form) (immutable subform)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 206862))
   (push)
   (extend . 1)
   (push.const . &syntax)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 207928))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 207888))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 208903))
 (set.gloc.of &syntax)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 209959))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 209942))
 (set.gloc.of &syntax-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 210986))
   (push)
   (push.const . 1)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 210969))
 (set.gloc.of &syntax-subform)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 212019))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 211999))
 (set.gloc.of make-syntax-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 213040))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 213019))
 (set.gloc.of syntax-violation?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 214067))
   (push)
   (push.gloc.of &syntax-form)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 214047))
 (set.gloc.of syntax-violation-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 215094))
   (push)
   (push.gloc.of &syntax-subform)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 215074))
 (set.gloc.of syntax-violation-subform)
 (ret.const.unspec))
((call
   (call
     (push.const . &undefined)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 218167))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 218126))
   (push)
   (extend . 1)
   (push.const . &undefined)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 219192))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 219152))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 220167))
 (set.gloc.of &undefined)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 221238))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 221218))
 (set.gloc.of make-undefined-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 222259))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 222238))
 (set.gloc.of undefined-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 225329))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 225294))
   (push)
   (extend . 1)
   (push.const . &i/o)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 226360))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 226320))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 227335))
 (set.gloc.of &i/o)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 228396))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 228376))
 (set.gloc.of make-i/o-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 229417))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 229396))
 (set.gloc.of i/o-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-read)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 232502))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 232462))
   (push)
   (extend . 1)
   (push.const . &i/o-read)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 233528))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 233488))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 234503))
 (set.gloc.of &i/o-read)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 235569))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 235549))
 (set.gloc.of make-i/o-read-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 236590))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 236569))
 (set.gloc.of i/o-read-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-write)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 239671))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 239630))
   (push)
   (extend . 1)
   (push.const . &i/o-write)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 240696))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 240656))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 241671))
 (set.gloc.of &i/o-write)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 242738))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 242718))
 (set.gloc.of make-i/o-write-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 243759))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 243738))
 (set.gloc.of i/o-write-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-invalid-position)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 246850))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable position)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 246798))
   (push)
   (extend . 1)
   (push.const . &i/o-invalid-position)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 247864))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 247824))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 248839))
 (set.gloc.of &i/o-invalid-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 250900))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 250883))
 (set.gloc.of &i/o-invalid-position-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 252951))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 252931))
 (set.gloc.of make-i/o-invalid-position-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 254010))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 253989))
 (set.gloc.of i/o-invalid-position-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 256023))
   (push)
   (push.gloc.of &i/o-invalid-position-position)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 256003))
 (set.gloc.of i/o-error-position)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-filename)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 259130))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable filename)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 259086))
   (push)
   (extend . 1)
   (push.const . &i/o-filename)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 260152))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 260112))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 261127))
 (set.gloc.of &i/o-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 262193))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 262176))
 (set.gloc.of &i/o-filename-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 263221))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 263201))
 (set.gloc.of make-i/o-filename-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 264242))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 264221))
 (set.gloc.of i/o-filename-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 265264))
   (push)
   (push.gloc.of &i/o-filename-filename)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 265244))
 (set.gloc.of i/o-error-filename)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-protection)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 268353))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 268302))
   (push)
   (extend . 1)
   (push.const . &i/o-file-protection)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 269368))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 269328))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 270343))
 (set.gloc.of &i/o-file-protection)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 272407))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 272387))
 (set.gloc.of make-i/o-file-protection-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 273465))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 273444))
 (set.gloc.of i/o-file-protection-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-is-read-only)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 276547))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 276494))
   (push)
   (extend . 1)
   (push.const . &i/o-file-is-read-only)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 277560))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 277520))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 278535))
 (set.gloc.of &i/o-file-is-read-only)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 279614))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 279594))
 (set.gloc.of make-i/o-file-is-read-only-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 280635))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 280614))
 (set.gloc.of i/o-file-is-read-only-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-already-exists)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 283717))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 283662))
   (push)
   (extend . 1)
   (push.const . &i/o-file-already-exists)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 284728))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 284688))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 285703))
 (set.gloc.of &i/o-file-already-exists)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 286784))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 286764))
 (set.gloc.of make-i/o-file-already-exists-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 287805))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 287784))
 (set.gloc.of i/o-file-already-exists-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-does-not-exist)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 290885))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 290830))
   (push)
   (extend . 1)
   (push.const . &i/o-file-does-not-exist)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 291896))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 291856))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 292871))
 (set.gloc.of &i/o-file-does-not-exist)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 293952))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 293932))
 (set.gloc.of make-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 294973))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 294952))
 (set.gloc.of i/o-file-does-not-exist-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-port)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 298038))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable port)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 297998))
   (push)
   (extend . 1)
   (push.const . &i/o-port)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 299064))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 299024))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 300039))
 (set.gloc.of &i/o-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 301097))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 301080))
 (set.gloc.of &i/o-port-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 302129))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 302109))
 (set.gloc.of make-i/o-port-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 303150))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 303129))
 (set.gloc.of i/o-port-error?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 304172))
   (push)
   (push.gloc.of &i/o-port-port)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 304152))
 (set.gloc.of i/o-error-port)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-decoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 307258))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 307214))
   (push)
   (extend . 1)
   (push.const . &i/o-decoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 308280))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 308240))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 309255))
 (set.gloc.of &i/o-decoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 310325))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 310305))
 (set.gloc.of make-i/o-decoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 311346))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 311325))
 (set.gloc.of i/o-decoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-encoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 314426))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable char)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 314382))
   (push)
   (extend . 1)
   (push.const . &i/o-encoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 315448))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 315408))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 316423))
 (set.gloc.of &i/o-encoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 317485))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 317468))
 (set.gloc.of &i/o-encoding-char)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 318517))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 318497))
 (set.gloc.of make-i/o-encoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 319538))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 319517))
 (set.gloc.of i/o-encoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 320565))
   (push)
   (push.gloc.of &i/o-encoding-char)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 320545))
 (set.gloc.of i/o-encoding-error-char)
 (ret.const.unspec))

;
((call (push.const . 100) (apply.gloc.of make-parameter "./boot/pp.scm" . 62498))
 (set.gloc.of pretty-print-line-length)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/pp.scm" . 63525))
 (set.gloc.of pretty-print-initial-indent)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 64548))
 (set.gloc.of pretty-print-maximum-lines)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 65572))
 (set.gloc.of pretty-print-unwrap-syntax)
 (ret.const.unspec))
((close
   (1 0 . indent-type2?)
   (push.iloc.0 . 0)
   (push.const if cond case and or set! import export cons map for-each exists for-all)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 82955))
 (set.gloc.of |indent-type2?`4|)
 (close
   (1 0 . parse)
   (iloc.0 . 0)
   (if.pair?
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (cddr.iloc (1 . 0) "./boot/pp.scm" . 149522)
       (ret.null? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (cddr.iloc (2 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "'")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quasiquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "`")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote-splicing)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",@")
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . let)
       (if.not.eq?.ret.const . #f)
       (cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (if.not.symbol?.ret.const . #f)
       (push.iloc 3 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(let ~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . 4)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type1?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type1?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type2?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type2?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . 2)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type3?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type3?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (push.iloc 3 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.car.iloc (4 . 0) "./boot/pp.scm" . 149522)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 5 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 3 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of symbol? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . |.&GROUP|)
       (push.const . "(")
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc 3 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
     (push.const . |.&GROUP|)
     (push.const . "(")
     (push.const . |.&NEST|)
     (push.const . 1)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.iloc 3 . 0)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 149522)
     (push.const ")")
     (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/pp.scm" . 184338)
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/pp.scm" . 185369)
     (push.const . 0)
     (subr.gloc.of = 2 "./boot/pp.scm" . 185366)
     (if.true.ret.const . "#()")
     (push.const . |.&GROUP|)
     (push.const . "#(")
     (push.const . |.&NEST|)
     (push.const . 2)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 187453)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 187441))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 185362)
     (push.const ")")
     (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 185362))
   (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/pp.scm" . 188434))
   (if.true
     (push.const . "~u")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/pp.scm" . 189458))
   (push.const . "~s")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/pp.scm" . 191506))
 (set.gloc.of |parse`4|)
 (close
   (1 0 . indent-type3?)
   (push.iloc.0 . 0)
   (push.const do let-optionals)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 87051))
 (set.gloc.of |indent-type3?`4|)
 (close
   (2 0 . fits?)
   (>=n.iloc (0 . 0) 0 "./boot/pp.scm" . 91152)
   (if.false.ret)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 1) "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of |.cdar| 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of |.cddar| 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 2 . 1)
     (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 3 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc 3 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (const . |.&BREAK|)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true.ret.const . #t)
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (const . |.&FLAT|)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.n+.iloc (4 . 0) -1 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (ret.subr.gloc.of string? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of - 2 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (const . |.&GROUP|)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (push.const . |.&FLAT|)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (const . |.&NEST|)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cadr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of + 2 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cddr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (iloc.0 . 0)
   (if.true
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (extend . 2)
     (touch.gloc.of |fits?`4|)
     (push.iloc 5 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (5 . 1) "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (ret.const . #f))
 (set.gloc.of |fits?`4|)
 (close
   (1 0 . parse-list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 139289)
   (if.null?
     (call
       (touch.gloc.of |parse`4|)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 140319)
       (apply.gloc.of |parse`4| "./boot/pp.scm" . 140312))
     (push)
     (ret.subr.gloc.of list "./boot/pp.scm" . 140306))
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 141337)
   (if.pair?
     (call
       (touch.gloc.of |parse`4|)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 142368)
       (apply.gloc.of |parse`4| "./boot/pp.scm" . 142361))
     (push)
     (push.const . #\;)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 142395)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 142383))
     (push)
     (ret.subr.gloc.of cons* "./boot/pp.scm" . 142354))
   (call
     (touch.gloc.of |parse`4|)
     (push.car.iloc (0 . 0) "./boot/pp.scm" . 144415)
     (apply.gloc.of |parse`4| "./boot/pp.scm" . 144408))
   (push)
   (push.const . #\;)
   (push.const . ".")
   (push.const . #\;)
   (call
     (touch.gloc.of |parse`4|)
     (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 144445)
     (apply.gloc.of |parse`4| "./boot/pp.scm" . 144438))
   (push)
   (ret.subr.gloc.of list "./boot/pp.scm" . 144402))
 (set.gloc.of |parse-list`4|)
 (close
   (1 0 . indent-type1?)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     define-macro
     define-inline
     define-constant
     syntax-rules
     syntax-case
     with-syntax
     lambda
     let-syntax
     letrec-syntax
     let
     letrec
     let*
     letrec
     letrec*
     let-values
     let*-values
     destructuring-match
     parameterize)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 74763))
 (set.gloc.of |indent-type1?`4|)
 (close
   (1 0 . symbol->length)
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/pp.scm" . 134170)
   (ret.subr.gloc.of string-length "./boot/pp.scm" . 134155))
 (set.gloc.of |symbol->length`4|)
 (close
   (1 1 . pretty-print)
   (call
     (iloc.0 . 1)
     (if.pair? (push.iloc.0 . 1) (ret.subr.gloc.of car "./boot/pp.scm" . 69666))
     (ret.subr.gloc.of current-output-port "./boot/pp.scm" . 69677))
   (push)
   (call
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70686))
     (if.false.ret)
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70718))
     (push)
     (push.const . 1)
     (ret.subr.gloc.of - "./boot/pp.scm" . 70715))
   (push)
   (extend . 2)
   (extend.enclose
     (3 0 . print)
     (iloc.0 . 2)
     (if.null?.ret.const . #t)
     (push.gloc.of string?)
     (extend . 1)
     (call
       (iloc.1 . 2)
       (if.not.pair?.ret.const . #f)
       (car.iloc (1 . 2) "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of |.cdar| 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of |.cddar| 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 2 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 3 . 2)
       (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 4 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc 3 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (const . |.&BREAK|)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (call
         (push.iloc 8 . 1)
         (const . #f)
         (if.eq?.ret.const . #t)
         (push.iloc 8 . 1)
         (push.const . 0)
         (ret.subr.gloc.of > "./boot/pp.scm" . 104463))
       (if.true
         (call
           (iloc 8 . 1)
           (if.false.ret)
           (n+.iloc (8 . 1) -1 "./boot/pp.scm" . 104463)
           (set.iloc 8 . 1)
           (ret.const.unspec))
         (push.iloc 8 . 0)
         (push.const . #\linefeed)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
         (call
           (extend.enclose+
             (1 0 . loop)
             (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.iloc 10 . 0)
             (push.const . #\space)
             (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 104463)
             (apply.iloc+ (1 . 0) "./boot/pp.scm" . 104463))
           (push.iloc.1 . 1)
           (apply.iloc+ (0 . 0) "./boot/pp.scm" . 104463))
         (push.iloc 6 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
       (ret.const.unspec))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (const . |.&FLAT|)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (extend . 1)
       (push.iloc 8 . 0)
       (push.const . #\space)
       (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.n+.iloc (6 . 1) 1 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (apply.iloc (4 . 0) "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 8 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of put-string 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (const . |.&GROUP|)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 3)
       (push.iloc.0 . 2)
       (push.const . |.&FLAT|)
       (push.iloc.0 . 1)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (iloc.0 . 0)
       (push.cons)
       (extend . 1)
       (call
         (touch.gloc.of |fits?`4|)
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.subr.gloc.of - 2 "./boot/pp.scm" . 104463)
         (push.iloc.0 . 0)
         (apply.gloc.of |fits?`4| "./boot/pp.scm" . 104463))
       (if.true
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
       (push.iloc 7 . 0)
       (push.iloc 7 . 1)
       (push.iloc.1 . 2)
       (push.const . |.&BREAK|)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (iloc.1 . 0)
       (push.cons)
       (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (const . |.&NEST|)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cadr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cddr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.cons)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (iloc.0 . 0)
     (if.true
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (push.cdr.iloc (6 . 2) "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 104463)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (ret.const . #f))
   (call
     (call
       (touch.gloc.of circular-tree?)
       (push.iloc 2 . 0)
       (apply.gloc.of circular-tree? "./boot/pp.scm" . 193547))
     (if.true
       (push.iloc.1 . 0)
       (push.const . "~w")
       (push.iloc 2 . 0)
       (ret.subr.gloc.of format "./boot/pp.scm" . 194571))
     (call (apply.gloc.of pretty-print-line-length "./boot/pp.scm" . 195608))
     (push)
     (extend . 1)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of collect-notify 0 "./boot/pp.scm" . 197647)
       (set.iloc 1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 197647))
     (push.close
       (0 0)
       (push.iloc 2 . 0)
       (push.const . 0)
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 197666))
       (push)
       (push.const . |.&FLAT|)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc 5 . 0)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 197704))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 197647)
       (push.subr.gloc.of |.list| 1 "./boot/pp.scm" . 197647)
       (apply.iloc (3 . 0) "./boot/pp.scm" . 197647))
     (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 197647))
     (apply.gloc.of |.dynamic-wind| "./boot/pp.scm" . 197647))
   (call
     (iloc.1 . 1)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of <= "./boot/pp.scm" . 198688))
   (if.true
     (push.iloc.1 . 0)
     (push.const . #\linefeed)
     (subr.gloc.of put-char 2 "./boot/pp.scm" . 199694)
     (call
       (extend.enclose+
         (1 0 . loop)
         (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 200769)
         (if.false.ret)
         (push.iloc 3 . 0)
         (push.const . #\space)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 200777)
         (if.false.ret)
         (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 200807)
         (apply.iloc+ (1 . 0) "./boot/pp.scm" . 200801))
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 200732))
       (push)
       (apply.iloc+ (0 . 0) "./boot/pp.scm" . 200718))
     (push.iloc.1 . 0)
     (push.const . "  ...")
     (ret.subr.gloc.of put-string "./boot/pp.scm" . 201742))
   (ret.const.unspec))
 (set.gloc.of pretty-print)
 (ret.const.unspec))

;
((close
   (1 0 . core-eval)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of backtrace 0 "./boot/eval.scm" . 8199)
     (set.iloc 1 . 0)
     (push.const . #f)
     (ret.subr.gloc.of backtrace "./boot/eval.scm" . 8199))
   (push.close
     (0 0)
     (touch.gloc.of interpret-coreform)
     (push.iloc 2 . 0)
     (apply.gloc.of interpret-coreform "./boot/eval.scm" . 8199))
   (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of backtrace "./boot/eval.scm" . 8199))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 8199))
 (set.gloc.of core-eval)
 (ret.const.unspec))
((close
   (1 0 . compile)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
     (set.iloc 1 . 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 1)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
   (push.close
     (0 0)
     (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 14361))
     (push)
     (apply.gloc.of compile-coreform "./boot/eval.scm" . 14343))
   (push.close
     (0 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 0)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 14343))
 (set.gloc.of compile)
 (ret.const.unspec))
((close
   (1 0 . interpret)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call
     (push.const . #f)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
       (set.iloc 1 . 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 1)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
     (push.close
       (0 0)
       (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 21536))
       (push)
       (apply.gloc.of compile-coreform "./boot/eval.scm" . 21518))
     (push.close
       (0 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 0)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 21518))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 22535))
 (set.gloc.of interpret)
 (ret.const.unspec))
((close
   (1 0 . interpret-coreform)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call (push.iloc.0 . 0) (apply.gloc.of compile-coreform "./boot/eval.scm" . 26656))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 27655))
 (set.gloc.of interpret-coreform)
 (ret.const.unspec))
((close
   (0 1 . environment)
   (call
     (touch.gloc.of parse-imports)
     (push.const . environment)
     (iloc.0 . 0)
     (push.cons)
     (push.iloc.0 . 0)
     (apply.gloc.of parse-imports "./boot/eval.scm" . 31749))
   (push.const . type:eval-environment)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/eval.scm" . 32773))
 (set.gloc.of environment)
 (ret.const.unspec))
((close
   (2 0 . eval)
   (call
     (touch.gloc.of environment?)
     (push.iloc.0 . 1)
     (apply.gloc.of environment? "./boot/eval.scm" . 36876))
   (if.true
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 38926)
       (set.iloc 1 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 38926))
     (push.close
       (0 0)
       (touch.gloc.of interpret)
       (push.iloc 2 . 0)
       (apply.gloc.of interpret "./boot/eval.scm" . 38926))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 38926))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 38926))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 40981)
   (push.const . type:eval-environment)
   (subr.gloc.of eq? 2 "./boot/eval.scm" . 40976)
   (if.false.call
     (push.const . eval)
     (push.const . "expected environment, but got ~r, as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/eval.scm" . 42027)
     (apply.gloc.of assertion-violation "./boot/eval.scm" . 42000))
   (touch.gloc.of interpret)
   (push.const . begin)
   (push.const . library)
   (push.const |.&ANONYMOUS|)
   (push.const export |.&RESULT|)
   (push.const . import)
   (push.const rename (only (core intrinsics) define) (define |.&DEFINE|))
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 47142)
   (push.subr.gloc.of |.cons*| 3 "./boot/eval.scm" . 43020)
   (push.const . |.&DEFINE|)
   (push.const . |.&RESULT|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 3 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 5 "./boot/eval.scm" . 43020)
   (push.const . let)
   (push.const . result)
   (call
     (touch.gloc.of generate-global-id)
     (call
       (touch.gloc.of generate-library-id)
       (push.const |.&ANONYMOUS|)
       (apply.gloc.of generate-library-id "./boot/eval.scm" . 49213))
     (push)
     (push.const . |.&RESULT|)
     (apply.gloc.of generate-global-id "./boot/eval.scm" . 49193))
   (push)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 1 "./boot/eval.scm" . 43020)
   (push.const . |.unintern-scheme-library|)
   (push.const . quote)
   (call
     (touch.gloc.of generate-library-id)
     (push.const |.&ANONYMOUS|)
     (apply.gloc.of generate-library-id "./boot/eval.scm" . 50232))
   (push)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 43020)
   (push.const result)
   (push.subr.gloc.of |.cons*| 4 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 3 "./boot/eval.scm" . 43020)
   (apply.gloc.of interpret "./boot/eval.scm" . 43020))
 (set.gloc.of eval)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 53277))
 (set.gloc.of scheme-load-verbose)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/eval.scm" . 54299))
 (set.gloc.of scheme-load-paths)
 (ret.const.unspec))
((close
   (1 0 . expand-path)
   (call
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 58396)
     (push.const . 1)
     (subr.gloc.of > 2 "./boot/eval.scm" . 58393)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . 1)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 58426)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 58420))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 59427)
     (push.const . #\~)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 59419))
   (if.true
     (push.const . "~a~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 60445))
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 60480)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 60462)
     (ret.subr.gloc.of format "./boot/eval.scm" . 60430))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 61475)
     (push.const . #\.)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 61467))
   (if.true
     (push.const . "~a~/")
     (subr.gloc.of current-directory 0)
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 62531)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 62513)
     (ret.subr.gloc.of format "./boot/eval.scm" . 62478))
   (push.iloc.1 . 0)
   (push.const . ".")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 63502)
   (if.true
     (push.const . "~/")
     (subr.gloc.of current-directory 0)
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 64526))
   (push.iloc.1 . 0)
   (push.const . "~")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 65550)
   (if.true
     (push.const . "~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 66587))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 66574))
   (push.const . "~/")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 68622))
 (set.gloc.of expand-path)
 (ret.const.unspec))
((close
   (1 0 . confirm-path)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 79886)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of |confirm-path`2|)
 (close
   (1 0 . path-not-found)
   (push.const . load)
   (push.const . "~a~/~a not found")
   (push.const . #\")
   (push.iloc.0 . 0)
   (push.const . #\")
   (push.subr.gloc.of format 4 "./boot/eval.scm" . 75812)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 75785))
 (set.gloc.of |path-not-found`2|)
 (close
   (1 0 . locate-load-file)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 81935)
   (push.const . 0)
   (subr.gloc.of = 2 "./boot/eval.scm" . 81932)
   (if.true
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 82956))
   (call
     (push.iloc.0 . 0)
     (push.const . ":")
     (subr.gloc.of string-contains 2 "./boot/eval.scm" . 83984)
     (if.true.ret)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 84017)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 84011))
   (if.true
     (call
       (touch.gloc.of |confirm-path`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 85008))
     (if.true.ret)
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 85028))
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 86034)
   (push.const #\. #\~)
   (subr.gloc.of memq 2 "./boot/eval.scm" . 86028)
   (if.true
     (call
       (touch.gloc.of |confirm-path`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/eval.scm" . 87070))
       (push)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 87056))
     (if.true.ret)
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 87090))
   (call
     (touch.gloc.of any1)
     (push.close
       (1 0)
       (touch.gloc.of |confirm-path`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (push.const . "/")
         (push.iloc.1 . 0)
         (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 88121)
         (apply.gloc.of expand-path "./boot/eval.scm" . 88108))
       (push)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 88094))
     (push.const . ".")
     (call (apply.gloc.of scheme-load-paths "./boot/eval.scm" . 89116))
     (push.cons)
     (apply.gloc.of any1 "./boot/eval.scm" . 88076))
   (if.true.ret)
   (touch.gloc.of |path-not-found`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 91148))
 (set.gloc.of locate-load-file)
 (ret.const.unspec))
((close
   (1 0 . load-file-has-r6rs-comment?)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 96263)
     (set.iloc 1 . 0)
     (push.const . #t)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 96263))
   (push.close
     (0 0)
     (call
       (touch.gloc.of open-script-input-port)
       (call
         (touch.gloc.of locate-load-file)
         (push.iloc 2 . 0)
         (apply.gloc.of locate-load-file "./boot/eval.scm" . 96299))
       (push)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 96275))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . load)
     (subr.gloc.of core-read 3 "./boot/eval.scm" . 97289)
     (push.iloc.0 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 98313)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (ret.subr.gloc.of not "./boot/eval.scm" . 99337))
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 96263))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 96263))
 (set.gloc.of load-file-has-r6rs-comment?)
 (ret.const.unspec))
((close
   (1 0 . load)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/eval.scm" . 103436)
   (if.true
     (call
       (touch.gloc.of auto-compile-cache-update)
       (apply.gloc.of auto-compile-cache-update "./boot/eval.scm" . 104460))
     (touch.gloc.of load-scheme-library)
     (push.iloc.0 . 0)
     (apply.gloc.of load-scheme-library "./boot/eval.scm" . 105484))
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 107548))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 108563))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 108585))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 109594))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 112666))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 113690)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 114714))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 116762))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 123925)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 123925)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 123925)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 123925)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 123925)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 123925)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 123925)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 123925))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (call
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 124981)
           (if.false.ret)
           (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 124993))
         (push)
         (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 124951)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 125987)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 127008)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 128032))
         (call
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 130080))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 131104))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 123925))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 123925)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 123925)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 123925)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 123925))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 119857))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 109582))
 (set.gloc.of load)
 (ret.const.unspec))
((close
   (1 0 . load-r6rs)
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 135189))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 136204))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 136226))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 137235))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 140307))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 141331)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 142355))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 144403))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 151566)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 151566)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 151566)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 151566)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 151566)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 151566)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 151566)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 151566))
     (push.close
       (0 0)
       (call
         (subr.gloc.of backtrace 0 "./boot/eval.scm" . 151596)
         (if.false.ret)
         (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 151608))
       (push)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 151566)
       (extend.enclose+
         (1 0 . loop)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 153628)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 154649)
         (if.true
           (push.iloc 6 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 155673)
           (call
             (touch.gloc.of expand-top-level-program)
             (push.iloc.1 . 0)
             (push.subr.gloc.of reverse 1 "./boot/eval.scm" . 156738)
             (push.const)
             (apply.gloc.of expand-top-level-program "./boot/eval.scm" . 156712))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/eval.scm" . 157723))
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 158747))
         (push.iloc.0 . 0)
         (iloc.1 . 0)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 160793))
       (push.const)
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 152590))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 151566)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 151566)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 151566)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 151566))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 147498))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 137223))
 (set.gloc.of load-r6rs)
 (ret.const.unspec))
((close
   (1 0 . load-cache)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 164874))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 164896))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 165905))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (push.iloc.1 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 168970)
     (push.iloc.0 . 0)
     (apply.gloc.of raise "./boot/eval.scm" . 169994))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-environment 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 176140)
       (set.iloc 1 . 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 176140)
       (set.iloc 1 . 1)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 176140)
       (set.iloc 1 . 2)
       (push.const . #f)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 176140)
       (push.const . #f)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 176140)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 176140))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (push.iloc 5 . 0)
         (push.const . #f)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 177178)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 178199)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 179223))
         (call
           (touch.gloc.of run-vmi)
           (push.const 1 . 0)
           (iloc.0 . 0)
           (push.cons)
           (apply.gloc.of run-vmi "./boot/eval.scm" . 181271))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 182295))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 176140))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 176140)
       (push.iloc.1 . 1)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 176140)
       (push.iloc.1 . 2)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 176140))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 175140))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 165893))
 (set.gloc.of load-cache)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 184350))
 (set.gloc.of auto-compile-verbose)
 (ret.const.unspec))
((close
   (1 0)
   (iloc.0 . 0)
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of string? 1 "./boot/eval.scm" . 191506)
       (if.false.ret)
       (push.const . "~//.")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/eval.scm" . 191532)
       (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 191518))
     (if.true
       (push.const . "~/")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/eval.scm" . 191552))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const
       .
       "~&;; warning in auto-compile-cache: directory ~s not exist (temporary disable caching)~!~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/eval.scm" . 193549)
     (ret.const . #f))
   (ret.iloc 0 . 0))
 (set.gloc.of |.fn1.1`1|)
 (call
   (push.const . #f)
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 189444))
 (set.gloc.of auto-compile-cache)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 201781)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 202808)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 202840)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 202837)
   (ret.subr.gloc.of = "./boot/eval.scm" . 202805))
 (set.gloc.of |.fn3.1`3|)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 205889))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 205874)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 206902)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 207910)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 207936))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 208934)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 208964))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 209958))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 209981))
 (set.gloc.of |.fn1.1`1|)
 (close
   (0 0 . auto-compile-cache-clean)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 198668))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn1.1`1|)
     (call
       (touch.gloc.of filter)
       (push.gloc.of |.fn3.1`3|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 203818)
       (apply.gloc.of filter "./boot/eval.scm" . 200738))
     (push)
     (apply.gloc.of for-each "./boot/eval.scm" . 200721))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-clean)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 231477)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 232504)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 232536)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 232533)
   (ret.subr.gloc.of = "./boot/eval.scm" . 232501))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0 . inconsistent-cache-state)
   (call
     (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 218126))
     (if.false.ret)
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~&;; reset ~s~%")
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 219197))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 219150))
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/eval.scm" . 217095))
 (set.gloc.of |inconsistent-cache-state`2|)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 221239))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 221224)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 222252)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 223260)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 223286))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 224284)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 224314))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 225308))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 225331))
 (set.gloc.of |.fn2.1`2|)
 (close
   (0 0 . auto-compile-cache-update)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 228364))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of filter)
       (push.gloc.of |.fn1.1`1|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 233514)
       (apply.gloc.of filter "./boot/eval.scm" . 230434))
     (push)
     (extend . 1)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (call
           (iloc.0 . 1)
           (if.false.ret)
           (push.close
             (1 0)
             (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 238671))
             (push)
             (push.const . "/")
             (push.iloc.0 . 0)
             (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 238656)
             (extend . 1)
             (push.iloc.0 . 0)
             (push.const . ".time")
             (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 239684)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 240694)
             (if.true
               (call
                 (touch.gloc.of make-file-input-port)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-file-input-port "./boot/eval.scm" . 242746))
               (push)
               (push.close
                 (1 0)
                 (push.iloc.0 . 0)
                 (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 244819)
                 (extend . 1)
                 (push.iloc.1 . 0)
                 (subr.gloc.of close-port 1 "./boot/eval.scm" . 245822)
                 (iloc.0 . 0)
                 (>=.iloc (5 . 1) "./boot/eval.scm" . 246853)
                 (if.true
                   (push.iloc 2 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 247877)
                   (push.iloc 3 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 248901)
                   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 249930))
                   (if.false.ret)
                   (push.const . #t)
                   (push.const . "~&;; clean ~s~%")
                   (push.iloc 3 . 0)
                   (ret.subr.gloc.of format "./boot/eval.scm" . 249953))
                 (ret.const.unspec))
               (apply.gloc.of call-with-port "./boot/eval.scm" . 241718))
             (touch.gloc.of |inconsistent-cache-state`2|)
             (push.iloc 5 . 0)
             (apply.gloc.of |inconsistent-cache-state`2| "./boot/eval.scm" . 251958))
           (push.iloc 2 . 0)
           (apply.gloc.of for-each "./boot/eval.scm" . 236572))
         (ret.const.unspec))
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 256062))
       (push)
       (push.const . "/")
       (push.car.iloc (0 . 0) "./boot/eval.scm" . 256087)
       (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 256047)
       (extend . 1)
       (push.iloc.0 . 0)
       (push.const . ".time")
       (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 257075)
       (extend . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 258085)
       (if.true
         (call
           (touch.gloc.of make-file-input-port)
           (push.iloc.0 . 0)
           (apply.gloc.of make-file-input-port "./boot/eval.scm" . 260137))
         (push)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 262211)
           (extend . 1)
           (push.iloc.1 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 263236)
           (extend . 1)
           (push.iloc 2 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 264255)
           (extend . 1)
           (push.iloc 3 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 265261)
           (call
             (push.iloc 2 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 266302)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 266328)
             (if.false.ret)
             (push.iloc.0 . 0)
             (subr.gloc.of string? 1 "./boot/eval.scm" . 266355)
             (if.false.ret)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 266377))
           (if.true
             (call
               (touch.gloc.of stat-mtime)
               (push.iloc.0 . 0)
               (apply.gloc.of stat-mtime "./boot/eval.scm" . 268343))
             (=.iloc (1 . 0) "./boot/eval.scm" . 268340)
             (if.true
               (push.cdr.iloc (6 . 0) "./boot/eval.scm" . 269370)
               (push.iloc 6 . 1)
               (apply.iloc (7 . 0) "./boot/eval.scm" . 269364))
             (push.cdr.iloc (6 . 0) "./boot/eval.scm" . 271418)
             (call
               (iloc 6 . 1)
               (if.true
                 (iloc 2 . 0)
                 (<.iloc (6 . 1) "./boot/eval.scm" . 273473)
                 (if.true (ret.iloc 2 . 0))
                 (ret.iloc 6 . 1))
               (ret.iloc 2 . 0))
             (push)
             (apply.iloc (7 . 0) "./boot/eval.scm" . 262187))
           (touch.gloc.of |inconsistent-cache-state`2|)
           (push.iloc 8 . 0)
           (apply.gloc.of |inconsistent-cache-state`2| "./boot/eval.scm" . 267316))
         (apply.gloc.of call-with-port "./boot/eval.scm" . 256028))
       (push.iloc.1 . 0)
       (subr.gloc.of delete-file 1 "./boot/eval.scm" . 276517)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 277546))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; clean ~s~%")
         (push.iloc.1 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 277569))
       (push.cdr.iloc (2 . 0) "./boot/eval.scm" . 278571)
       (push.iloc 2 . 1)
       (apply.iloc (3 . 0) "./boot/eval.scm" . 278565))
     (push.iloc.1 . 0)
     (push.const . #f)
     (apply.iloc (0 . 0) "./boot/eval.scm" . 234515))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-update)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 285726)
     (if.false.ret)
     (touch.gloc.of every1)
     (push.gloc.of string?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/eval.scm" . 285740))
   (if.true (ret.iloc 0 . 0))
   (push.const . library-extensions)
   (push.const . "expected list of strings, but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/eval.scm" . 287810)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 287769))
 (set.gloc.of |.fn1.1`1|)
 (call
   (push.const . ".ypsilon.sls")
   (push.const . ".ypsilon.ss")
   (push.const . ".ypsilon.scm")
   (push.const . ".sls")
   (push.const . ".ss")
   (push.const . ".scm")
   (push.subr.gloc.of list 6 "./boot/eval.scm" . 283667)
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 283651))
 (set.gloc.of library-extensions)
 (ret.const.unspec))
((close
   (4 0 . make-cache)
   (call
     (touch.gloc.of make-file-output-port)
     (push.iloc.0 . 1)
     (apply.gloc.of make-file-output-port "./boot/eval.scm" . 297999))
   (push)
   (push.close
     (1 0)
     (call
       (touch.gloc.of open-script-input-port)
       (push.iloc.1 . 0)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 301077))
     (push)
     (push.close
       (1 0)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 305178)
         (push.iloc 2 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 306202)
         (call
           (iloc 3 . 1)
           (if.false.ret)
           (push.iloc 3 . 1)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 307235)
           (if.false.ret)
           (push.iloc 3 . 1)
           (ret.subr.gloc.of delete-file "./boot/eval.scm" . 307254))
         (push.iloc.0 . 0)
         (apply.gloc.of raise "./boot/eval.scm" . 308250))
       (push.close
         (0 0)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (subr.gloc.of current-source-comments 0)
         (push)
         (subr.gloc.of current-environment 0)
         (push)
         (subr.gloc.of extend-lexical-syntax 0)
         (push)
         (subr.gloc.of backtrace 0)
         (push)
         (extend . 8)
         (push.close
           (0 0)
           (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 315420)
           (set.iloc 1 . 0)
           (subr.gloc.of current-environment 0 "./boot/eval.scm" . 315420)
           (set.iloc 1 . 1)
           (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 315420)
           (set.iloc 1 . 2)
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 315420)
           (set.iloc 1 . 3)
           (push.iloc.1 . 4)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 315420)
           (push.iloc.1 . 5)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 315420)
           (push.iloc.1 . 6)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 315420)
           (push.iloc.1 . 7)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 315420))
         (push.close
           (0 0)
           (extend.enclose+
             (0 0 . loop)
             (call
               (subr.gloc.of backtrace 0 "./boot/eval.scm" . 316476)
               (if.false.ret)
               (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 316488))
             (push)
             (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 316446)
             (push.iloc 5 . 0)
             (subr.gloc.of current-source-comments 0)
             (push)
             (push.const . load)
             (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 317481)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 318503)
             (if.true
               (push.iloc 7 . 0)
               (push.const . "~%")
               (subr.gloc.of format 2 "./boot/eval.scm" . 319527)
               (push.iloc 6 . 0)
               (subr.gloc.of close-port 1 "./boot/eval.scm" . 320551)
               (push.iloc 7 . 0)
               (ret.subr.gloc.of close-port "./boot/eval.scm" . 321575))
             (call
               (push.const . #f)
               (subr.gloc.of make-core-hashtable 0)
               (push)
               (extend . 2)
               (push.close
                 (0 0)
                 (call
                   (touch.gloc.of current-closure-comments)
                   (apply.gloc.of current-closure-comments "./boot/eval.scm" . 326704))
                 (set.iloc 1 . 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 1)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 326704))
               (push.close
                 (0 0)
                 (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 326722))
                 (push)
                 (apply.gloc.of compile-coreform "./boot/eval.scm" . 326704))
               (push.close
                 (0 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 0)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 326704))
               (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 326704))
             (push)
             (extend . 1)
             (push.iloc 8 . 0)
             (push.iloc.0 . 0)
             (subr.gloc.of put-fasl 2 "./boot/eval.scm" . 327721)
             (push.iloc 8 . 0)
             (push.const . "~%")
             (subr.gloc.of format 2 "./boot/eval.scm" . 328745)
             (call
               (touch.gloc.of run-vmi)
               (push.const 1 . 0)
               (iloc.0 . 0)
               (push.cons)
               (apply.gloc.of run-vmi "./boot/eval.scm" . 329769))
             (apply.iloc+ (3 . 0) "./boot/eval.scm" . 330793))
           (apply.iloc+ (0 . 0) "./boot/eval.scm" . 315420))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 315420)
           (push.iloc.1 . 1)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 315420)
           (push.iloc.1 . 2)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 315420)
           (push.iloc.1 . 3)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 315420))
         (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 311352))
       (apply.gloc.of with-exception-handler "./boot/eval.scm" . 302101))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 299023))
   (apply.gloc.of call-with-port "./boot/eval.scm" . 295945))
 (set.gloc.of |make-cache`4|)
 (close
   (2 0 . locate-cache)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 358416))
   (if.false.ret)
   (push.const . "~a/~a.cache")
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 359480))
   (push)
   (call
     (touch.gloc.of symbol-list->string)
     (push.iloc.0 . 0)
     (push.const . ".")
     (apply.gloc.of symbol-list->string "./boot/eval.scm" . 359501))
   (push)
   (push.subr.gloc.of format 3 "./boot/eval.scm" . 359458)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 360471)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . ".time")
     (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 361517)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 362526)
     (if.false.ret)
     (call
       (touch.gloc.of make-file-input-port)
       (push.iloc.0 . 0)
       (apply.gloc.of make-file-input-port "./boot/eval.scm" . 364578))
     (push)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 366628)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 367652)
       (push.iloc 3 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 368703)
       (subr.gloc.of equal? 2 "./boot/eval.scm" . 368683)
       (if.true (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 370731)
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/eval.scm" . 371755))
       (ret.const . #f))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 362521))
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of |locate-cache`4|)
 (close
   (1 1 . load-scheme-library)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #t)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of car "./boot/eval.scm" . 292906))
   (push)
   (extend . 1)
   (extend.enclose
     (1 0 . locate-source)
     (call
       (touch.gloc.of symbol-list->string)
       (push.iloc.0 . 0)
       (push.const . "/")
       (apply.gloc.of symbol-list->string "./boot/eval.scm" . 345111))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.const . "~a/~a~a")
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 4 "./boot/eval.scm" . 348211)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 349224)
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call (apply.gloc.of library-extensions "./boot/eval.scm" . 350239))
         (push)
         (apply.gloc.of any1 "./boot/eval.scm" . 347161))
       (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 351255))
       (push)
       (apply.gloc.of any1 "./boot/eval.scm" . 346129))
     (if.true.ret)
     (iloc 3 . 0)
     (if.false.ret)
     (push.const . load-scheme-library)
     (push.const . "~s not found in scheme-library-paths: ~s")
     (push.iloc.0 . 0)
     (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 353386))
     (push)
     (push.subr.gloc.of format 3 "./boot/eval.scm" . 353330)
     (apply.gloc.of error "./boot/eval.scm" . 353302))
   (call
     (push.iloc 2 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 375819)
     (if.true.ret)
     (push.const . "internal error in load-scheme-library: unrecognized argument: ~s")
     (push.iloc 2 . 0)
     (apply.gloc.of scheme-error "./boot/eval.scm" . 376843))
   (call (push.iloc 2 . 0) (apply.iloc (0 . 0) "./boot/eval.scm" . 378894))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 380951))
     (if.true
       (call
         (touch.gloc.of |locate-cache`4|)
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |locate-cache`4| "./boot/eval.scm" . 381993))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of load-cache)
         (push.iloc.0 . 0)
         (apply.gloc.of load-cache "./boot/eval.scm" . 384029))
       (push.const . "~a/~a.cache")
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 385093))
       (push)
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc 4 . 0)
         (push.const . ".")
         (apply.gloc.of symbol-list->string "./boot/eval.scm" . 385114))
       (push)
       (push.subr.gloc.of format 3 "./boot/eval.scm" . 385071)
       (extend . 1)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 386084))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; compile ~s~%~!")
         (push.iloc 2 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 386107))
       (call
         (touch.gloc.of |make-cache`4|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 5 . 0)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 2 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 387142))
         (push)
         (apply.gloc.of |make-cache`4| "./boot/eval.scm" . 387103))
       (call
         (touch.gloc.of make-file-output-port)
         (push.iloc.0 . 0)
         (push.const . ".time")
         (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 388149)
         (apply.gloc.of make-file-output-port "./boot/eval.scm" . 390181))
       (push)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.const . "~s ~s ~s")
         (subr.gloc.of microsecond 0)
         (push)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 3 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 391262))
         (push)
         (push.iloc 3 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 391222))
       (apply.gloc.of call-with-port "./boot/eval.scm" . 389153))
     (push.iloc.0 . 0)
     (apply.gloc.of load "./boot/eval.scm" . 392215))
   (ret.const.unspec))
 (set.gloc.of load-scheme-library)
 (ret.const.unspec))

;
((close
   (1 0 . add-load-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 7180)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 8208)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 9244))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 10275))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 10262)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 11316))
       (push.cons)
       (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 11286))
     (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 12300))
   (push.const . add-load-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 14384)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 14348))
 (set.gloc.of add-load-path)
 (ret.const.unspec))
((close
   (1 0 . add-library-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 18444)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 19472)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 20508))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 21539))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 21526)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 22583))
       (push.cons)
       (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 22550))
     (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 23564))
   (push.const . add-library-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 25651)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 25612))
 (set.gloc.of add-library-path)
 (ret.const.unspec))
((close
   (0 0 . home-directory)
   (push.const . "~/")
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 31783)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 31766)
     (if.true
       (call
         (push.const . "HOMEDRIVE")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 32809)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (call
         (push.const . "HOMEPATH")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 33833)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (ret.subr.gloc.of string-append "./boot/interaction.scm" . 32790))
     (push.const . "HOME")
     (ret.subr.gloc.of lookup-process-environment "./boot/interaction.scm" . 34838))
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 29713)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/interaction.scm" . 35852)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of home-directory)
 (ret.const.unspec))
((close
   (1 1 . apply-scheme-proc-assistant)
   (push.const . #t)
   (extend . 1)
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.true.ret)
     (push.const . apply-scheme-proc-assistant)
     (push.const . "scheme continuation interleave with c/c++ continuation")
     (apply.gloc.of assertion-violation "./boot/interaction.scm" . 43028))
   (push.close
     (0 0)
     (call
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of apply "./boot/interaction.scm" . 45077))
     (push)
     (extend . 1)
     (const . #f)
     (set.iloc 2 . 0)
     (ret.iloc 0 . 0))
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.false.ret)
     (touch.gloc.of escape)
     (apply.gloc.of escape "./boot/interaction.scm" . 48149))
   (apply.gloc.of dynamic-wind "./boot/interaction.scm" . 40967))
 (set.gloc.of apply-scheme-proc-assistant)
 (ret.const.unspec))
((close
   (0 0 . nonblock-skip-whitespace)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of nonblock-byte-ready? 1 "./boot/interaction.scm" . 52234)
   (if.false.ret)
   (call
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of lookahead-char 1 "./boot/interaction.scm" . 53268)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 54294)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of char-whitespace? "./boot/interaction.scm" . 55313))
   (if.false.ret)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of get-char 1 "./boot/interaction.scm" . 56330)
   (if.false.ret)
   (touch.gloc.of nonblock-skip-whitespace)
   (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 57354))
 (set.gloc.of nonblock-skip-whitespace)
 (ret.const.unspec))
((close
   (0 0 . read-eval-print-loop)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 61464)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 61511)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 61506)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 61501))
   (push)
   (extend . 1)
   (extend.enclose
     (0 0 . loop)
     (call
       (push.close
         (1 0)
         (push.close
           (1 0)
           (subr.gloc.of current-output-port 0)
           (push)
           (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 67599)
           (touch.gloc.of default-exception-handler)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 68623))
         (push.close
           (0 0)
           (call
             (touch.gloc.of nonblock-skip-whitespace)
             (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 70671))
           (call
             (subr.gloc.of current-environment 0)
             (push)
             (subr.gloc.of interaction-environment 0 "./boot/interaction.scm" . 71726)
             (if.eq?
               (push.const . #t)
               (push.const . "~&> ~!")
               (ret.subr.gloc.of format "./boot/interaction.scm" . 72723))
             (push.const . #t)
             (push.const . "~&~a: ~!")
             (subr.gloc.of current-environment 0)
             (push)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 73747))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 74767))
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 75791)
           (call
             (touch.gloc.of set-port-current-line!)
             (subr.gloc.of current-input-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-line! "./boot/interaction.scm" . 76815))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-output-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 77839))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-error-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 78863))
           (subr.gloc.of current-input-port 0)
           (push)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . read)
           (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 79899)
           (extend . 1)
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 80918)
             (if.false.ret)
             (push.const . 0)
             (ret.subr.gloc.of exit "./boot/interaction.scm" . 80937))
           (call
             (iloc 5 . 0)
             (if.false.ret)
             (push.const . #t)
             (push.const . "~%~!")
             (ret.subr.gloc.of format "./boot/interaction.scm" . 81950))
           (call
             (touch.gloc.of interpret)
             (push.iloc.0 . 0)
             (apply.gloc.of interpret "./boot/interaction.scm" . 82972))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of unspecified? 1 "./boot/interaction.scm" . 83994)
           (if.true.ret)
           (call (push.iloc.0 . 0) (apply.gloc.of pretty-print "./boot/interaction.scm" . 86042))
           (subr.gloc.of current-output-port 0)
           (push)
           (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 87066))
         (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 65548))
       (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 63497))
     (apply.iloc (1 . 0) "./boot/interaction.scm" . 88073))
   (apply.iloc (0 . 0) "./boot/interaction.scm" . 62471))
 (set.gloc.of read-eval-print-loop)
 (ret.const.unspec))
((close
   (0 0)
   (call
     (touch.gloc.of nonblock-skip-whitespace)
     (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 100365))
   (call
     (touch.gloc.of current-macro-expression)
     (push.const . #f)
     (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 101389))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 102413)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.const . read)
   (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 103449)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 104470)
   (if.true (push.const . 0) (ret.subr.gloc.of exit "./boot/interaction.scm" . 104489))
   (call
     (touch.gloc.of interpret)
     (push.iloc.0 . 0)
     (apply.gloc.of interpret "./boot/interaction.scm" . 106518))
   (subr.gloc.of current-output-port 0)
   (push)
   (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 107542))
 (set.gloc.of |.fn4.1`4|)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 98357))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (push.gloc.of |.fn6.1`6|)
   (push.gloc.of |.fn4.1`4|)
   (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 94216))
 (set.gloc.of |.fn3.1`3|)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 97293)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 98317))
 (set.gloc.of |.fn6.1`6|)
 (close
   (0 0 . loop)
   (call
     (push.gloc.of |.fn3.1`3|)
     (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 92165))
   (touch.gloc.of |loop`4|)
   (apply.gloc.of |loop`4| "./boot/interaction.scm" . 108551))
 (set.gloc.of |loop`4|)
 (close
   (0 0 . quiet-read-eval-print-loop)
   (touch.gloc.of |loop`4|)
   (apply.gloc.of |loop`4| "./boot/interaction.scm" . 92165))
 (set.gloc.of quiet-read-eval-print-loop)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/interaction.scm" . 145436)
       (apply.gloc.of |loop`7| "./boot/interaction.scm" . 145430))
     (push)
     (call
       (touch.gloc.of |loop`7|)
       (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 145453)
       (apply.gloc.of |loop`7| "./boot/interaction.scm" . 145447))
     (ret.cons "./boot/interaction.scm" . 145424))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.const
       (|.LIST| . |.list|)
       (|.CONS| . |.cons|)
       (|.CONS*| . |.cons*|)
       (|.APPEND| . |.append|)
       (|.VECTOR| . |.vector|)
       (|.LIST->VECTOR| . |.list->vector|)
       (|.EQ?| . |.eq?|)
       (|.EQV?| . |.eqv?|)
       (|.MEMQ| . |.memq|)
       (|.MEMV| . |.memv|)
       (|.CALL-WITH-VALUES| . |.call-with-values|)
       (|.APPLY| . |.apply|)
       (|.CDR| . |.cdr|)
       (|.IDENTIFIER?| . |.identifier?|)
       (|.MAKE-VARIABLE-TRANSFORMER| . |.make-variable-transformer|)
       (|.ASSERTION-VIOLATION| . |.assertion-violation|)
       (|.UNSPECIFIED| . |.unspecified|)
       (|.QUOTE| . quote)
       (|.LET| . let)
       (|.LETREC*| . letrec*)
       (|.BEGIN| . begin)
       (|.LAMBDA| . lambda)
       (|.IF| . if)
       (|.SET!| . set!)
       (|.OR| . or)
       (|.COND| . cond)
       (|.ELSE| . else)
       (|.DEFINE-SYNTAX| . define-syntax)
       (|.SYNTAX| . syntax)
       (|.SYNTAX-CASE| . syntax-case))
     (push.subr.gloc.of assq 2 "./boot/interaction.scm" . 147479)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/interaction.scm" . 147472))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/interaction.scm" . 149520)
   (if.true
     (call
       (push.gloc.of |loop`7|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/interaction.scm" . 150568)
       (apply.gloc.of map "./boot/interaction.scm" . 150558))
     (push)
     (apply.gloc.of list->vector "./boot/interaction.scm" . 150544))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . unrename-private-primitives)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`7| "./boot/interaction.scm" . 143367))
 (set.gloc.of |.fn2.2`2|)
 (gloc.of |.fn2.2`2|)
 (set.gloc.of unrename-private-primitives)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . "~r")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 178248))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . default-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/interaction.scm" . 155653))
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 1)
   (call
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of backtrace-line-length 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (call (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 161801))
       (set.iloc 1 . 0)
       (call (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 161801))
       (set.iloc 1 . 1)
       (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 161801))
       (set.iloc 1 . 2)
       (call
         (push.iloc.1 . 3)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 161801))
       (call
         (push.const . 10)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 161801))
       (push.const . #t)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 161801))
     (push.close
       (0 0)
       (extend.unbound . 3)
       (push.close
         (0 0 . output-who-message)
         (push.iloc 4 . 0)
         (push.const . "error")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 163853)
         (call
           (call (push.iloc 5 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 164882))
           (if.false.ret)
           (push.iloc 4 . 0)
           (push.const . " in ~u")
           (call (push.iloc 5 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 165928))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 165906))
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of message-condition? "./boot/interaction.scm" . 166930))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . ": ~a")
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of condition-message "./boot/interaction.scm" . 167974))
         (push)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 167954))
       (push.close
         (0 0 . output-irritants)
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of irritants-condition? "./boot/interaction.scm" . 172052))
         (if.true
           (push.iloc 4 . 0)
           (push.const . "~%~%irritants:")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 173076)
           (push.close
             (1 0)
             (push.iloc 5 . 0)
             (push.const . "~% ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 175136)
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/interaction.scm" . 176167)
             (if.true
               (push.iloc 5 . 0)
               (push.const . " (")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 177191)
               (extend.enclose+
                 (1 0 . loop)
                 (iloc.0 . 0)
                 (if.pair?
                   (push.iloc 7 . 0)
                   (push.const . "~a")
                   (push.car.iloc (0 . 0) "./boot/interaction.scm" . 180290)
                   (subr.gloc.of format 3 "./boot/interaction.scm" . 180272)
                   (cdr.iloc (0 . 0) "./boot/interaction.scm" . 181310)
                   (if.pair?
                     (push.iloc 7 . 0)
                     (push.const . " ")
                     (subr.gloc.of format 2 "./boot/interaction.scm" . 182327)
                     (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 183357)
                     (apply.iloc+ (1 . 0) "./boot/interaction.scm" . 183351))
                   (push.iloc 7 . 0)
                   (push.const . ")")
                   (ret.subr.gloc.of format "./boot/interaction.scm" . 185399))
                 (ret.const.unspec))
               (call
                 (push.gloc.of |.fn2.1`2|)
                 (push.iloc.1 . 0)
                 (apply.gloc.of map "./boot/interaction.scm" . 178231))
               (push)
               (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 178215))
             (push.iloc 5 . 0)
             (push.const . " ~r")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 186412))
           (call
             (touch.gloc.of condition-irritants)
             (push.iloc 5 . 0)
             (apply.gloc.of condition-irritants "./boot/interaction.scm" . 187422))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 172045))
         (ret.const.unspec))
       (push.close+
         (0 0 . output-expansion)
         (call (apply.gloc.of expansion-backtrace "./boot/interaction.scm" . 191506))
         (if.false.ret)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 192530))
         (if.false.ret)
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 194580))
           (set.iloc 1 . 0)
           (push.const . 7)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 194580))
         (push.close
           (0 0)
           (push.iloc 6 . 0)
           (push.const . "~%~%expanding:~%  >  ")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 194580)
           (call
             (call
               (touch.gloc.of unrename-private-primitives)
               (call
                 (touch.gloc.of current-macro-expression)
                 (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 195647))
               (push)
               (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 195618))
             (push)
             (push.iloc 6 . 0)
             (apply.gloc.of pretty-print "./boot/interaction.scm" . 195604))
           (push.iloc 6 . 0)
           (push.const . "~%  ~n")
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 196650))
           (push)
           (subr.gloc.of format 3 "./boot/interaction.scm" . 196628)
           (push.close
             (1 0)
             (push.iloc 7 . 0)
             (push.const . "~%  *  ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 198688)
             (call
               (call
                 (touch.gloc.of unrename-private-primitives)
                 (push.iloc.0 . 0)
                 (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 199726))
               (push)
               (push.iloc 7 . 0)
               (apply.gloc.of pretty-print "./boot/interaction.scm" . 199712))
             (push.iloc 7 . 0)
             (push.const . "~%  ~n")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 200736))
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 201758))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 197652))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 194580))
         (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 194580))
       (enclose . 3)
       (call (push.iloc 4 . 0) (apply.gloc.of syntax-violation? "./boot/interaction.scm" . 203792))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 204816))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 205847))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 208926))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 208926))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  >  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 208926)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 209964))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 209950))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 210992))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 208926))
             (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 208926))
           (ret.const.unspec))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 211991))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 215070))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 215070))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  @  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 215070)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 216108))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 216094))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 217136))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 215070))
             (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 215070))
           (ret.const.unspec))
         (call
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 218144))
           (if.not.null?.ret.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 219170))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 219197))
           (if.eq?.ret.const . #t)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 220194))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 220221))
           (ret.eq? "./boot/interaction.scm" . 220189))
         (if.true.ret)
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 221204))
       (call
         (push.iloc 4 . 0)
         (apply.gloc.of undefined-violation? "./boot/interaction.scm" . 223248))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unbound variable")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 224272)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 225301))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " ~s")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 226344))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 226325))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 227349))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ", ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 228393))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 228373))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 229392))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 230416))
       (call (push.iloc 4 . 0) (apply.gloc.of error? "./boot/interaction.scm" . 232464))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 233488))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 234512))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 235536))
       (call (push.iloc 4 . 0) (apply.gloc.of violation? "./boot/interaction.scm" . 237584))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 238608))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 239632))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 240656))
       (call (push.iloc 4 . 0) (apply.gloc.of warning? "./boot/interaction.scm" . 242704))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "warning")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 243728)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 244757))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " in ~s")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 245803))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 245781))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 246805))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ": ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 247849))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 247829))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 248848))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 249872))
       (call (push.iloc 4 . 0) (apply.gloc.of condition? "./boot/interaction.scm" . 251920))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unknown exception caught~%~%irritants:~%~a")
         (call
           (touch.gloc.of describe-condition)
           (push.const . #f)
           (push.iloc 4 . 0)
           (apply.gloc.of describe-condition "./boot/interaction.scm" . 253009))
         (push)
         (subr.gloc.of format 3 "./boot/interaction.scm" . 252944)
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 253968))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 254992))
       (push.iloc 3 . 0)
       (push.const . "error: unknown exception caught, ~a")
       (push.iloc 4 . 0)
       (subr.gloc.of format 3 "./boot/interaction.scm" . 258064)
       (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 259088))
       (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 260112))
     (push.close
       (0 0)
       (call
         (push.iloc.1 . 0)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 161801))
       (call
         (push.iloc.1 . 1)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 161801))
       (push.iloc.1 . 2)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 161801))
     (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 157744))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 262151)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 263194)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 263241)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 263236)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 263231))
   (push)
   (extend . 1)
   (call (push.iloc 2 . 0) (apply.gloc.of serious-condition? "./boot/interaction.scm" . 264208))
   (if.true
     (push.iloc.1 . 0)
     (subr.gloc.of display-backtrace 1 "./boot/interaction.scm" . 265232)
     (call
       (iloc.0 . 0)
       (if.true
         (subr.gloc.of current-error-port 0)
         (push)
         (push.const . "~a~!")
         (push.iloc.1 . 0)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 267320)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 267284))
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~%~a~%~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 268348)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 268308))
     (push.const . 10000)
     (subr.gloc.of usleep 1 "./boot/interaction.scm" . 269328)
     (iloc 2 . 1)
     (if.false.ret)
     (apply.iloc (2 . 1) "./boot/interaction.scm" . 270366))
   (call
     (iloc.0 . 0)
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~a~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 273464)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 273428))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~%~a~!")
     (push.iloc.1 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 274490)
     (ret.subr.gloc.of format "./boot/interaction.scm" . 274452))
   (push.const . 10000)
   (ret.subr.gloc.of usleep "./boot/interaction.scm" . 275472))
 (set.gloc.of default-exception-handler)
 (ret.const.unspec))
((close
   (0 0 . init-env-sitelib)
   (push.const . "YPSILON_SITELIB")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 315408)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn9.1`9|)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 323636)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 323619)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 324643))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 325667))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 323606)
     (apply.gloc.of for-each "./boot/interaction.scm" . 315401))
   (ret.const.unspec))
 (set.gloc.of |init-env-sitelib`2|)
 (close
   (0 0 . show-banner)
   (subr.gloc.of current-output-port 0)
   (push)
   (push.const . "Ypsilon 0.9.5-trunk Copyright (c) 2008 Y.Fujita, LittleWing Company Limited.\n")
   (ret.subr.gloc.of put-string "./boot/interaction.scm" . 402441))
 (set.gloc.of |show-banner`2|)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 436285))
 (set.gloc.of |.fn2.1`2|)
 (close
   (0 0 . init-sys-sitelib)
   (push.const . "~a/sitelib")
   (subr.gloc.of system-share-path 0)
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 286741)
   (extend . 1)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 287760))
   (if.false.ret)
   (push.iloc.0 . 0)
   (apply.gloc.of add-library-path "./boot/interaction.scm" . 287785))
 (set.gloc.of |init-sys-sitelib`2|)
 (close
   (1 0 . bad-option)
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '~a'~%")
   (push.iloc.0 . 0)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 376841)
   (call
     (touch.gloc.of |show-usage`2|)
     (apply.gloc.of |show-usage`2| "./boot/interaction.scm" . 377865))
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 378889))
 (set.gloc.of |bad-option`2|)
 (close
   (1 0 . add-opt-loadpath)
   (push.close
     (1 0)
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 357423))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 357404))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 358443))
       (push)
       (apply.gloc.of add-load-path "./boot/interaction.scm" . 358428))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '-loadpath=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 360476)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 361500))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 362545)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 362528)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 363552))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 364576))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 362515)
   (apply.gloc.of for-each "./boot/interaction.scm" . 355335))
 (set.gloc.of |add-opt-loadpath`2|)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 435221)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of |.fn2.1`2|)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 436245))
 (set.gloc.of |.fn8.1`8|)
 (close
   (0 0 . show-info)
   (call
     (touch.gloc.of |show-banner`2|)
     (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 406537))
   (call
     (push.const . "YPSILON_ACC")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 407568)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_ACC=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 408610))
     (push.const . #t)
     (push.const . ";; YPSILON_ACC unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 409621))
   (call
     (push.const . "YPSILON_SITELIB")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 410640)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_SITELIB=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 411682))
     (push.const . #t)
     (push.const . ";; YPSILON_SITELIB unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 412693))
   (call
     (push.const . "YPSILON_LOADPATH")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 413712)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_LOADPATH=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 414754))
     (push.const . #t)
     (push.const . ";; YPSILON_LOADPATH unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 415765))
   (push.const . #t)
   (push.const . ";; (auto-compile-cache) => ~s~%")
   (call (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 416822))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 416777)
   (push.const . #t)
   (push.const . ";; (scheme-library-paths) => ~s~%")
   (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 417848))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 417801)
   (push.const . #t)
   (push.const . ";; (scheme-load-paths) => ~s~%")
   (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 418869))
   (push)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 418825))
 (set.gloc.of |show-info`2|)
 (close
   (1 0)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 319538))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 319519))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 320561))
     (push)
     (apply.gloc.of add-library-path "./boot/interaction.scm" . 320543))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_SITELIB': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 322591))
 (set.gloc.of |.fn9.1`9|)
 (close
   (1 0 . set-opt-acc)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 368675))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 368656))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 369700))
     (push)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 369680))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '-acc=~a': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of format 4 "./boot/interaction.scm" . 371728)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 372752))
 (set.gloc.of |set-opt-acc`2|)
 (close
   (0 0 . init-env-loadpath)
   (push.const . "YPSILON_LOADPATH")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 329744)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn17.1`17|)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 337972)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 337955)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 338979))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 340003))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 337942)
     (apply.gloc.of for-each "./boot/interaction.scm" . 329737))
   (ret.const.unspec))
 (set.gloc.of |init-env-loadpath`2|)
 (close
   (0 0 . show-usage)
   (push.const . #t)
   (push.const . "usage: ypsilon [options] [--] [file] [arguments]~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 382985)
   (push.const . #t)
   (push.const . "options:~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 384009)
   (push.const . #t)
   (push.const . "  --mute (-m)            suppresses greeting~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 385033)
   (push.const . #t)
   (push.const . "  --quiet (-q)           suppresses greeting, repl prompt, and repl output~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 386057)
   (push.const . #t)
   (push.const . "  --verbose (-v)         prints load and compile activities~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 387081)
   (push.const . #t)
   (push.const . "  --interactive (-i)     enters repl after running the script file~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 388105)
   (push.const . #t)
   (push.const . "  --r6rs (-6)            conforms r6rs lexical syntax (default)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 389129)
   (push.const . #t)
   (push.const . "  --compatible (-c)      extends lexical syntax for compatibility~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 390153)
   (push.const . #t)
   (push.const . "  --sitelib=path         adds sitelib path (YPSILON_SITELIB)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 391177)
   (push.const . #t)
   (push.const . "  --loadpath=path        adds load search path (YPSILON_LOADPATH)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 392201)
   (push.const . #t)
   (push.const . "  --acc=dir              sets a auto-compile-cache directory (YPSILON_ACC)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 393225)
   (push.const . #t)
   (push.const . "  --disable-acc          disables auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 394249)
   (push.const . #t)
   (push.const . "  --clean-acc            cleans auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 395273)
   (push.const . #t)
   (push.const . "  --version              prints version and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 396297)
   (push.const . #t)
   (push.const . "  --help                 prints help and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 397321)
   (push.const . #t)
   (push.const . "  --                     indicates no more option to proceed~%")
   (ret.subr.gloc.of format "./boot/interaction.scm" . 398345))
 (set.gloc.of |show-usage`2|)
 (close
   (0 0 . init-sys-acc)
   (push.const . operating-system)
   (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 291873)
   (push.const . "windows")
   (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 291856)
   (if.true
     (push.const . "TEMP")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 292887)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of |directory-exists?`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 294947))
       (if.true
         (call
           (call
             (touch.gloc.of |directory-exists?`2|)
             (push.const . "~//Ypsilon")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/interaction.scm" . 295994)
             (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 295975))
           (if.true.ret)
           (push.const . "~//Ypsilon")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/interaction.scm" . 297017)
           (ret.subr.gloc.of create-directory "./boot/interaction.scm" . 296999))
         (push.const . "~//Ypsilon")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/interaction.scm" . 298039)
         (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 298019))
       (ret.const.unspec))
     (ret.const.unspec))
   (call
     (touch.gloc.of |directory-exists?`2|)
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 300096))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 300074)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 300055))
   (if.true
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 301121))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 301099)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 301079))
   (ret.const.unspec))
 (set.gloc.of |init-sys-acc`2|)
 (close
   (1 0 . directory-exists?)
   (push.const . "~a/.")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 282647)
   (ret.subr.gloc.of file-exists? "./boot/interaction.scm" . 282633))
 (set.gloc.of |directory-exists?`2|)
 (close
   (1 0 . add-opt-sitelib)
   (push.close
     (1 0)
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 345135))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 345116))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 346158))
       (push)
       (apply.gloc.of add-library-path "./boot/interaction.scm" . 346140))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '-sitelib=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 348188)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 349212))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 350257)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 350240)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 351264))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 352288))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 350227)
   (apply.gloc.of for-each "./boot/interaction.scm" . 343047))
 (set.gloc.of |add-opt-sitelib`2|)
 (close
   (1 0)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 333874))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 333855))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 334894))
     (push)
     (apply.gloc.of add-load-path "./boot/interaction.scm" . 334879))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_LOADPATH': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 336927))
 (set.gloc.of |.fn17.1`17|)
 (close
   (0 0 . init-env-acc)
   (push.const . "YPSILON_ACC")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 305168)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 307247))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 307228))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 308272))
       (push)
       (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 308252))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in environment variable 'YPSILON_ACC': directory ~s not exist~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/interaction.scm" . 310300)
     (push.const . #f)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 311324))
   (ret.const.unspec))
 (set.gloc.of |init-env-acc`2|)
 (close
   (0 0 . start-scheme-session)
   (extend.unbound . 8)
   (push.close
     (1 0 . exec-script)
     (subr.gloc.of command-line 0)
     (push)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 422944)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 422968)
     (push.subr.gloc.of - 2 "./boot/interaction.scm" . 422941)
     (subr.gloc.of command-line-shift 1 "./boot/interaction.scm" . 422921)
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 423957)
     (extend . 1)
     (iloc 2 . 4)
     (if.true
       (push.close
         (1 0)
         (subr.gloc.of current-output-port 0)
         (push)
         (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 428053)
         (touch.gloc.of default-exception-handler)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 429077))
       (push.close (0 0) (push.iloc.1 . 0) (apply.gloc.of load "./boot/interaction.scm" . 431125))
       (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 426002))
     (push.gloc.of |.fn8.1`8|)
     (push.close
       (0 0)
       (call
         (call
           (touch.gloc.of load-file-has-r6rs-comment?)
           (push.iloc.1 . 0)
           (apply.gloc.of load-file-has-r6rs-comment? "./boot/interaction.scm" . 438297))
         (if.true
           (touch.gloc.of load-r6rs)
           (push.iloc.1 . 0)
           (apply.gloc.of load-r6rs "./boot/interaction.scm" . 439321))
         (push.iloc.1 . 0)
         (apply.gloc.of load "./boot/interaction.scm" . 440345))
       (subr.gloc.of current-error-port 0)
       (push)
       (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 441365)
       (subr.gloc.of current-output-port 0)
       (push)
       (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 442389))
     (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 433170))
   (push.close
     (0 0 . exec-repl)
     (call
       (iloc.1 . 6)
       (if.true.ret)
       (iloc.1 . 2)
       (if.true
         (touch.gloc.of |show-info`2|)
         (apply.gloc.of |show-info`2| "./boot/interaction.scm" . 447512))
       (touch.gloc.of |show-banner`2|)
       (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 448533))
     (call
       (iloc.1 . 5)
       (if.true.ret)
       (touch.gloc.of interpret)
       (push.const import (core) (rnrs))
       (apply.gloc.of interpret "./boot/interaction.scm" . 449556))
     (iloc.1 . 3)
     (if.true
       (touch.gloc.of quiet-read-eval-print-loop)
       (apply.gloc.of quiet-read-eval-print-loop "./boot/interaction.scm" . 451597))
     (touch.gloc.of read-eval-print-loop)
     (apply.gloc.of read-eval-print-loop "./boot/interaction.scm" . 452621))
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (enclose . 7)
   (subr.gloc.of command-line 0 "./boot/interaction.scm" . 459810)
   (set.iloc 0 . 7)
   (call
     (touch.gloc.of |init-sys-acc`2|)
     (apply.gloc.of |init-sys-acc`2| "./boot/interaction.scm" . 461829))
   (call
     (touch.gloc.of |init-env-acc`2|)
     (apply.gloc.of |init-env-acc`2| "./boot/interaction.scm" . 462853))
   (call
     (touch.gloc.of |init-sys-sitelib`2|)
     (apply.gloc.of |init-sys-sitelib`2| "./boot/interaction.scm" . 463877))
   (call
     (touch.gloc.of |init-env-sitelib`2|)
     (apply.gloc.of |init-env-sitelib`2| "./boot/interaction.scm" . 464901))
   (call
     (touch.gloc.of |init-env-loadpath`2|)
     (apply.gloc.of |init-env-loadpath`2| "./boot/interaction.scm" . 465925))
   (iloc.0 . 7)
   (if.not.pair?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 4)
       (if.true (apply.iloc (2 . 1) "./boot/interaction.scm" . 473113))
       (iloc 2 . 5)
       (if.true.ret)
       (apply.iloc (2 . 1) "./boot/interaction.scm" . 474148))
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 476192)
     (extend . 1)
     (extend.enclose
       (2 0 . opt?)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of string-contains 2 "./boot/interaction.scm" . 480292)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (=n.iloc (0 . 0) 0 "./boot/interaction.scm" . 482345)
         (if.true
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (subr.gloc.of string=? 2 "./boot/interaction.scm" . 483364)
           (if.true.ret.const . "")
           (iloc.1 . 1)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 484422)
           (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 484406)
           (push.const . #\=)
           (subr.gloc.of char=? 2 "./boot/interaction.scm" . 484398)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 485430)
           (push.const . 1)
           (push.subr.gloc.of + 2 "./boot/interaction.scm" . 485427)
           (push.iloc 3 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 485454)
           (ret.subr.gloc.of substring "./boot/interaction.scm" . 485412))
         (ret.const . #f))
       (ret.const . #f))
     (call
       (push.const . "--version")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 488478))
     (if.true
       (call
         (touch.gloc.of |show-banner`2|)
         (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 489502))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 490526))
     (call
       (push.const . "--help")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 491550))
     (if.true
       (call
         (touch.gloc.of |show-usage`2|)
         (apply.gloc.of |show-usage`2| "./boot/interaction.scm" . 492574))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 493598))
     (call
       (call
         (push.const . "--r6rs")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 494626))
       (if.true.ret)
       (push.const . "-6")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 494645))
     (if.true
       (push.const . #f)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 495646)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 496676)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 496670))
     (call
       (call
         (push.const . "--compatible")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 497698))
       (if.true.ret)
       (push.const . "-c")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 497723))
     (if.true
       (push.const . #t)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 498718)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 499748)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 499742))
     (call
       (call
         (push.const . "--verbose")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 500770))
       (if.true.ret)
       (push.const . "-v")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 500792))
     (if.true
       (call
         (push.const . #t)
         (apply.gloc.of scheme-load-verbose "./boot/interaction.scm" . 501790))
       (call
         (push.const . #t)
         (apply.gloc.of auto-compile-verbose "./boot/interaction.scm" . 502814))
       (const . #t)
       (set.iloc 4 . 2)
       (const . #f)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 505892)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 505886))
     (call
       (call
         (push.const . "--mute")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 506914))
       (if.true.ret)
       (push.const . "-m")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 506933))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 509988)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 509982))
     (call
       (call
         (push.const . "--quiet")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 511010))
       (if.true.ret)
       (push.const . "-q")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 511030))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (const . #t)
       (set.iloc 4 . 3)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 515108)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 515102))
     (call
       (call
         (push.const . "--interactive")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 516130))
       (if.true.ret)
       (push.const . "-i")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 516156))
     (if.true
       (const . #t)
       (set.iloc 4 . 4)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 518180)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 518174))
     (call
       (push.const . "--acc")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 519198))
     (if.true
       (call
         (cdr.iloc (2 . 0) "./boot/interaction.scm" . 520233)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc.1 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 520244))
       (call
         (touch.gloc.of |set-opt-acc`2|)
         (push.cadr.iloc (2 . 0) "./boot/interaction.scm" . 521259)
         (apply.gloc.of |set-opt-acc`2| "./boot/interaction.scm" . 521246))
       (push.cddr.iloc (2 . 0) "./boot/interaction.scm" . 522276)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 522270))
     (call
       (push.const . "--acc")
       (push.const . #t)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 523294))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 525354)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 2 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 526378))
       (call
         (touch.gloc.of |set-opt-acc`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |set-opt-acc`2| "./boot/interaction.scm" . 528426))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 529456)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 529450))
     (call
       (push.const . "--disable-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 530462))
     (if.true
       (call (push.const . #f) (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 531486))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 532516)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 532510))
     (call
       (push.const . "--clean-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 533534))
     (if.true
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/interaction.scm" . 534558))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 535588)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 535582))
     (call
       (push.const . "--sitelib")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 536606))
     (if.true
       (call
         (cdr.iloc (3 . 0) "./boot/interaction.scm" . 537641)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc 2 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 537652))
       (call
         (touch.gloc.of |add-opt-sitelib`2|)
         (push.cadr.iloc (3 . 0) "./boot/interaction.scm" . 538671)
         (apply.gloc.of |add-opt-sitelib`2| "./boot/interaction.scm" . 538654))
       (push.cddr.iloc (3 . 0) "./boot/interaction.scm" . 539684)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 539678))
     (call
       (push.const . "--sitelib")
       (push.const . #t)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 540702))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 542762)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 3 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 543786))
       (call
         (touch.gloc.of |add-opt-sitelib`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |add-opt-sitelib`2| "./boot/interaction.scm" . 545834))
       (push.cdr.iloc (4 . 0) "./boot/interaction.scm" . 546864)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 546858))
     (call
       (push.const . "--loadpath")
       (push.const . #f)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 547870))
     (if.true
       (call
         (cdr.iloc (4 . 0) "./boot/interaction.scm" . 548905)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc 3 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 548916))
       (call
         (touch.gloc.of |add-opt-loadpath`2|)
         (push.cadr.iloc (4 . 0) "./boot/interaction.scm" . 549936)
         (apply.gloc.of |add-opt-loadpath`2| "./boot/interaction.scm" . 549918))
       (push.cddr.iloc (4 . 0) "./boot/interaction.scm" . 550948)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 550942))
     (call
       (push.const . "--loadpath")
       (push.const . #t)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 551966))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 554026)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 4 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 555050))
       (call
         (touch.gloc.of |add-opt-loadpath`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |add-opt-loadpath`2| "./boot/interaction.scm" . 557098))
       (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 558128)
       (apply.iloc+ (6 . 0) "./boot/interaction.scm" . 558122))
     (call
       (push.const . "--")
       (push.const . #f)
       (apply.iloc (3 . 0) "./boot/interaction.scm" . 559134))
     (if.true
       (const . #t)
       (set.iloc 7 . 5)
       (call
         (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 561195)
         (apply.iloc (7 . 0) "./boot/interaction.scm" . 561182))
       (iloc 7 . 4)
       (if.false.ret)
       (apply.iloc (7 . 1) "./boot/interaction.scm" . 562223))
     (push.iloc 4 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 563238)
     (push.const . #\-)
     (subr.gloc.of char=? 2 "./boot/interaction.scm" . 563230)
     (if.true
       (touch.gloc.of |bad-option`2|)
       (push.iloc 4 . 0)
       (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 564254))
     (const . #t)
     (set.iloc 7 . 5)
     (call (push.iloc 5 . 0) (apply.iloc (7 . 0) "./boot/interaction.scm" . 567326))
     (iloc 7 . 4)
     (if.false.ret)
     (apply.iloc (7 . 1) "./boot/interaction.scm" . 568367))
   (push.cdr.iloc (1 . 7) "./boot/interaction.scm" . 470044)
   (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 470028))
 (set.gloc.of start-scheme-session)
 (ret.const.unspec))

;
((subr.gloc.of make-core-hashtable 0 "./boot/libraries.scm" . 5150)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 42029)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 42005)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 43029))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 62536))
   (ret.cons "./boot/libraries.scm" . 62528))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . setup-intrinsic-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 26641))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 27665))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 28694))
   (push)
   (extend . 3)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 29705)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 30729)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn6.1`6|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 32813))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 33837)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 32805)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 31780))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 31753))
 (set.gloc.of |setup-intrinsic-macros`1|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 21576))
   (ret.cons "./boot/libraries.scm" . 21568))
 (set.gloc.of |.fn5.1`5|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 32840))
   (ret.cons "./boot/libraries.scm" . 32832))
 (set.gloc.of |.fn6.1`6|)
 (close
   (2 0 . setup-core-primitive-procs)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 37905))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 38929))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 39958))
   (push)
   (extend . 3)
   (call
     (push.gloc.of |.fn1.1`1|)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 40969))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 45065)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn10.1`10|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 47149))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 48173)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 47141)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 46116))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 46089))
 (set.gloc.of |setup-core-primitive-procs`1|)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 16429)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 16405)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 17429))
 (set.gloc.of |.fn9.1`9|)
 (close
   (2 0 . setup-core-primitive-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 52241))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 53265))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 54294))
   (push)
   (extend . 3)
   (call
     (push.gloc.of |.fn11.1`11|)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 52231))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 60425)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn2.1`2|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 62509))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 63533)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 62501)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 61476))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 61449))
 (set.gloc.of |setup-core-primitive-macros`1|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 47176))
   (ret.cons "./boot/libraries.scm" . 47168))
 (set.gloc.of |.fn10.1`10|)
 (close
   (2 0 . compound-exports)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 67601))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 67631))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 68652)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.1 . 1)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 67667))
   (push)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 69676)
   (push.subr.gloc.of append 2 "./boot/libraries.scm" . 68644)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 68617))
 (set.gloc.of |compound-exports`1|)
 (close
   (2 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 56348)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 58401))
   (ret.const.unspec))
 (set.gloc.of |.fn11.1`11|)
 (close
   (2 0 . setup-intrinsic-procs)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 1)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 11271)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 12305))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 13329))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 14358))
   (push)
   (extend . 3)
   (call
     (push.gloc.of |.fn9.1`9|)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 15369))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 19465)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn5.1`5|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 21549))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 22573)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 21541)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 20516))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 20489))
 (set.gloc.of |setup-intrinsic-procs`1|)
 (call
   (touch.gloc.of |setup-intrinsic-macros`1|)
   (push.const core intrinsics)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (apply.gloc.of |setup-intrinsic-macros`1| "./boot/libraries.scm" . 71683))
 (call
   (touch.gloc.of |setup-intrinsic-procs`1|)
   (push.const core intrinsics)
   (push.const
     eq?
     eqv?
     equal?
     procedure?
     number?
     complex?
     real?
     rational?
     integer?
     real-valued?
     rational-valued?
     integer-valued?
     exact?
     inexact?
     inexact
     exact
     =
     <
     >
     <=
     >=
     zero?
     positive?
     negative?
     odd?
     even?
     finite?
     infinite?
     nan?
     max
     min
     +
     *
     -
     /
     abs
     div-and-mod
     div
     mod
     div0-and-mod0
     div0
     mod0
     gcd
     lcm
     numerator
     denominator
     floor
     ceiling
     truncate
     round
     rationalize
     exp
     log
     sin
     cos
     tan
     asin
     acos
     atan
     sqrt
     exact-integer-sqrt
     expt
     make-rectangular
     make-polar
     real-part
     imag-part
     magnitude
     angle
     number->string
     string->number
     not
     boolean?
     boolean=?
     pair?
     cons
     car
     cdr
     caar
     cadr
     cdar
     cddr
     caaar
     caadr
     cadar
     caddr
     cdaar
     cdadr
     cddar
     cdddr
     caaaar
     caaadr
     caadar
     caaddr
     cadaar
     cadadr
     caddar
     cadddr
     cdaaar
     cdaadr
     cdadar
     cdaddr
     cddaar
     cddadr
     cdddar
     cddddr
     null?
     list?
     list
     length
     append
     reverse
     list-tail
     list-ref
     map
     for-each
     symbol?
     symbol=?
     symbol->string
     string->symbol
     char?
     char->integer
     integer->char
     char=?
     char<?
     char>?
     char<=?
     char>=?
     string?
     make-string
     string
     string-length
     string-ref
     string=?
     string<?
     string>?
     string<=?
     string>=?
     substring
     string-append
     string->list
     list->string
     string-copy
     string-for-each
     vector?
     make-vector
     vector
     vector-length
     vector-ref
     vector-set!
     vector->list
     list->vector
     vector-fill!
     vector-map
     vector-for-each
     error
     assertion-violation
     apply
     call-with-current-continuation
     call/cc
     values
     call-with-values
     dynamic-wind)
   (apply.gloc.of |setup-intrinsic-procs`1| "./boot/libraries.scm" . 83971))
 (call
   (touch.gloc.of |setup-core-primitive-macros`1|)
   (push.const core primitives)
   (push.const do syntax-case syntax define-macro)
   (apply.gloc.of |setup-core-primitive-macros`1| "./boot/libraries.scm" . 130051))
 (call
   (touch.gloc.of |setup-core-primitive-procs`1|)
   (push.const core primitives)
   (push.const
     environment
     eval
     flonum?
     real->flonum
     fl=?
     fl<?
     fl>?
     fl<=?
     fl>=?
     flinteger?
     flzero?
     flpositive?
     flnegative?
     flodd?
     fleven?
     flfinite?
     flinfinite?
     flnan?
     flmax
     flmin
     fl+
     fl*
     fl-
     fl/
     fldiv
     fldiv0
     flnumerator
     fldenominator
     flfloor
     flceiling
     fltruncate
     flround
     flexp
     fllog
     flsin
     flcos
     fltan
     flasin
     flacos
     flatan
     flabs
     flsqrt
     fixnum->flonum
     fixnum?
     fixnum-width
     least-fixnum
     greatest-fixnum
     fx=?
     fx<?
     fx>?
     fx<=?
     fx>=?
     fxzero?
     fxpositive?
     fxnegative?
     fxodd?
     fxeven?
     fxmax
     fxmin
     fx+
     fx*
     fx-
     fxdiv
     fxdiv0
     fxnot
     fxand
     fxior
     fxxor
     fxif
     fxbit-count
     fxlength
     fxfirst-bit-set
     fxbit-set?
     fxcopy-bit
     fxarithmetic-shift
     fxarithmetic-shift-left
     fxarithmetic-shift-right
     fxbit-field
     fxcopy-bit-field
     bitwise-not
     bitwise-and
     bitwise-ior
     bitwise-xor
     bitwise-arithmetic-shift
     bitwise-first-bit-set
     bitwise-length
     bitwise-bit-count
     make-variable-transformer
     identifier?
     bound-identifier=?
     free-identifier=?
     datum->syntax
     syntax->datum
     generate-temporaries
     syntax-violation
     memq
     memv
     member
     assq
     assv
     assoc
     cons*
     list-head
     raise
     raise-continuable
     with-exception-handler
     record?
     record-rtd
     record-type-name
     record-type-parent
     record-type-uid
     record-type-generative?
     record-type-sealed?
     record-type-opaque?
     record-type-field-names
     record-field-mutable?
     make-record-type-descriptor
     record-type-descriptor?
     make-record-constructor-descriptor
     record-constructor
     record-predicate
     record-accessor
     record-mutator
     make-record-type
     record-type?
     record-type-rtd
     record-type-rcd
     condition
     simple-conditions
     condition?
     condition-predicate
     condition-accessor
     &condition
     &message
     make-message-condition
     message-condition?
     condition-message
     &warning
     make-warning
     warning?
     &serious
     make-serious-condition
     serious-condition?
     &error
     make-error
     error?
     &violation
     make-violation
     violation?
     &assertion
     make-assertion-violation
     assertion-violation?
     &irritants
     make-irritants-condition
     irritants-condition?
     &who
     make-who-condition
     who-condition?
     condition-who
     &non-continuable
     make-non-continuable-violation
     non-continuable-violation?
     &implementation-restriction
     make-implementation-restriction-violation
     implementation-restriction-violation?
     &lexical
     make-lexical-violation
     lexical-violation?
     &syntax
     make-syntax-violation
     syntax-violation?
     syntax-violation-form
     syntax-violation-subform
     &undefined
     make-undefined-violation
     undefined-violation?
     set-car!
     set-cdr!
     string-set!
     string-fill!
     quotient
     remainder
     modulo
     char-whitespace?
     display
     write
     newline
     read-char
     write-char
     call-with-port
     eof-object
     eof-object?
     standard-input-port
     standard-output-port
     standard-error-port
     current-input-port
     current-output-port
     current-error-port
     input-port?
     output-port?
     port?
     flush-output-port
     output-port-buffer-mode
     close-port
     native-transcoder-descriptor
     port-transcoder-descriptor
     extract-accumulated-bytevector
     extract-accumulated-string
     get-accumulated-string
     open-port
     nonblock-byte-ready?
     lookahead-char
     get-char
     port-has-port-position?
     port-position
     port-has-set-port-position!?
     set-port-position!
     port-eof?
     get-u8
     lookahead-u8
     get-bytevector-n
     get-bytevector-n!
     get-bytevector-all
     get-bytevector-some
     get-string-n
     get-string-n!
     get-string-all
     get-line
     get-datum
     put-u8
     put-bytevector
     put-char
     put-string
     put-datum
     &i/o
     make-i/o-error
     i/o-error?
     &i/o-read
     make-i/o-read-error
     i/o-read-error?
     &i/o-write
     make-i/o-write-error
     i/o-write-error?
     &i/o-invalid-position
     make-i/o-invalid-position-error
     i/o-invalid-position-error?
     i/o-error-position
     &i/o-filename
     make-i/o-filename-error
     i/o-filename-error?
     i/o-error-filename
     &i/o-file-protection
     make-i/o-file-protection-error
     i/o-file-protection-error?
     &i/o-file-is-read-only
     make-i/o-file-is-read-only-error
     i/o-file-is-read-only-error?
     &i/o-file-already-exists
     make-i/o-file-already-exists-error
     i/o-file-already-exists-error?
     &i/o-file-does-not-exist
     make-i/o-file-does-not-exist-error
     i/o-file-does-not-exist-error?
     &i/o-port
     make-i/o-port-error
     i/o-port-error?
     i/o-error-port
     &i/o-decoding
     make-i/o-decoding-error
     i/o-decoding-error?
     &i/o-encoding
     make-i/o-encoding-error
     i/o-encoding-error?
     i/o-encoding-error-char
     file-exists?
     delete-file
     string-hash
     symbol-hash
     equal-hash
     command-line
     exit
     native-endianness
     bytevector?
     make-bytevector
     bytevector-length
     bytevector=?
     bytevector-fill!
     bytevector-copy!
     bytevector-copy
     bytevector-u8-ref
     bytevector-s8-ref
     bytevector-u8-set!
     bytevector-s8-set!
     bytevector->u8-list
     u8-list->bytevector
     bytevector-u16-ref
     bytevector-s16-ref
     bytevector-u16-native-ref
     bytevector-s16-native-ref
     bytevector-u16-set!
     bytevector-s16-set!
     bytevector-u16-native-set!
     bytevector-s16-native-set!
     bytevector-u32-ref
     bytevector-s32-ref
     bytevector-u32-native-ref
     bytevector-s32-native-ref
     bytevector-u32-set!
     bytevector-s32-set!
     bytevector-u32-native-set!
     bytevector-s32-native-set!
     bytevector-u64-ref
     bytevector-s64-ref
     bytevector-u64-native-ref
     bytevector-s64-native-ref
     bytevector-u64-set!
     bytevector-s64-set!
     bytevector-u64-native-set!
     bytevector-s64-native-set!
     bytevector-ieee-single-ref
     bytevector-ieee-single-native-ref
     bytevector-ieee-single-set!
     bytevector-ieee-single-native-set!
     bytevector-ieee-double-ref
     bytevector-ieee-double-native-ref
     bytevector-ieee-double-set!
     bytevector-ieee-double-native-set!
     string->utf8
     utf8->string
     put-fasl
     put-byte
     make-string-output-port
     make-string-input-port
     make-transcoded-port
     make-temporary-file-port
     port-device-subtype
     core-eval
     command-line-shift
     unspecified
     unspecified?
     generate-temporary-symbol
     list-transpose
     list-transpose+
     list-transpose*
     make-parameter
     gensym
     format
     pretty-print
     pretty-print-line-length
     pretty-print-initial-indent
     pretty-print-maximum-lines
     pretty-print-unwrap-syntax
     peek-char
     read
     write-with-shared-structure
     tuple
     tuple?
     make-tuple
     tuple-ref
     tuple-set!
     tuple-length
     tuple-index
     tuple->list
     make-weak-mapping
     weak-mapping?
     weak-mapping-key
     weak-mapping-value
     make-core-hashtable
     core-hashtable?
     make-weak-core-hashtable
     weak-core-hashtable?
     core-hashtable-contains?
     core-hashtable-ref
     core-hashtable-set!
     core-hashtable-delete!
     core-hashtable-clear!
     core-hashtable->alist
     core-hashtable-size
     core-hashtable-copy
     core-hashtable-mutable?
     core-hashtable-equivalence-function
     core-hashtable-hash-function
     usleep
     microsecond
     scheme-error
     architecture-feature
     load-shared-object
     lookup-shared-object
     call-shared-object->void
     call-shared-object->int
     call-shared-object->intptr
     call-shared-object->double
     stdcall-shared-object->void
     stdcall-shared-object->int
     stdcall-shared-object->intptr
     stdcall-shared-object->double
     make-callback
     flonum->float
     string->cstring
     cstring->string
     collect
     collect-notify
     collect-stack-notify
     collect-trip-bytes
     display-heap-statistics
     display-object-statistics
     backtrace
     expansion-backtrace
     backtrace-line-length
     display-backtrace
     restricted-print-line-length
     extend-lexical-syntax
     macro-expand
     compile
     compile-coreform
     closure-code
     current-environment
     current-macro-environment
     current-variable-environment
     current-dynamic-environment
     system-environment
     interaction-environment
     make-environment
     copy-environment-variables!
     copy-environment-macros!
     top-level-bound?
     top-level-value
     set-top-level-value!
     core-read
     current-source-comments
     current-after-expansion-hook
     string-contains
     subr?
     make-bytevector-mapping
     scheme-library-exports
     scheme-library-paths
     scheme-load-paths
     scheme-load-verbose
     add-load-path
     add-library-path
     library-extensions
     auto-compile-verbose
     auto-compile-cache
     directory-list
     current-directory
     create-directory
     home-directory
     time-usage
     load
     system-share-path
     lookup-process-environment
     set-current-input-port!
     set-current-output-port!
     set-current-error-port!
     open-builtin-data-input-port)
   (apply.gloc.of |setup-core-primitive-procs`1| "./boot/libraries.scm" . 136195))
 (touch.gloc.of |compound-exports`1|)
 (push.const core primitives)
 (push.const core intrinsics)
 (apply.gloc.of |compound-exports`1| "./boot/libraries.scm" . 481283))
((gloc.of assertion-violation) (set.gloc.of |.@assertion-violation|) (ret.const.unspec))
((gloc.of undefined-violation) (set.gloc.of |.@undefined-violation|) (ret.const.unspec))
((gloc.of lexical-violation) (set.gloc.of |.@lexical-violation|) (ret.const.unspec))
((gloc.of error) (set.gloc.of |.@error|) (ret.const.unspec))
((gloc.of implementation-restriction-violation)
 (set.gloc.of |.@implementation-restriction-violation|)
 (ret.const.unspec))
((gloc.of raise-i/o-read-error) (set.gloc.of |.@raise-i/o-read-error|) (ret.const.unspec))
((gloc.of raise-i/o-write-error) (set.gloc.of |.@raise-i/o-write-error|) (ret.const.unspec))
((gloc.of raise-i/o-file-protection-error)
 (set.gloc.of |.@raise-i/o-file-protection-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-is-read-only-error)
 (set.gloc.of |.@raise-i/o-file-is-read-only-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-already-exists-error)
 (set.gloc.of |.@raise-i/o-file-already-exists-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-does-not-exist-error)
 (set.gloc.of |.@raise-i/o-file-does-not-exist-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-decoding-error) (set.gloc.of |.@raise-i/o-decoding-error|) (ret.const.unspec))
((gloc.of raise-i/o-encoding-error) (set.gloc.of |.@raise-i/o-encoding-error|) (ret.const.unspec))
((gloc.of raise-i/o-invalid-position-error)
 (set.gloc.of |.@raise-i/o-invalid-position-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-filename-error) (set.gloc.of |.@raise-i/o-filename-error|) (ret.const.unspec))
((gloc.of raise-i/o-error) (set.gloc.of |.@raise-i/o-error|) (ret.const.unspec))
((gloc.of perform-dynamic-wind) (set.gloc.of |.@perform-dynamic-wind|) (ret.const.unspec))
((gloc.of start-scheme-session) (set.gloc.of |.@start-scheme-session|) (ret.const.unspec))
((gloc.of apply-scheme-proc-assistant)
 (set.gloc.of |.@apply-scheme-proc-assistant|)
 (ret.const.unspec))
((gloc.of pretty-print) (set.gloc.of |.@pretty-print|) (ret.const.unspec))
((push.const . |.run-vmi|)
 (push.gloc.of run-vmi)
 (ret.subr.gloc.of set-top-level-value! "./boot/libraries.scm" . 506881))
((close
   (1 0)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 515097))
 (set.gloc.of |.fn1.1`1|)
 (push.const
   |.set-top-level-macro!|
   |.require-scheme-library|
   |.intern-scheme-library|
   |.unintern-scheme-library|
   |.patvars|
   |.syntax-dispatch|
   |.syntax-transcribe|
   |.flatten-syntax|
   |.transformer-thunk|
   |.run-vmi|)
 (extend . 1)
 (call
   (push.gloc.of |.fn1.1`1|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/libraries.scm" . 515075))
 (subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.iloc.0 . 0)
 (ret.subr.gloc.of copy-environment-variables! "./boot/libraries.scm" . 516099))
((subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.const import)
 (ret.subr.gloc.of copy-environment-macros! "./boot/libraries.scm" . 520193))
((push.gloc.of immutable-primitives)
 (push.const . #f)
 (subr.gloc.of core-hashtable-copy 2 "./boot/libraries.scm" . 521244)
 (touch.gloc.of immutable-primitives)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))

;
