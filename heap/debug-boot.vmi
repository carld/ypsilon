((push.const . |.list?|)
 (push.gloc.of list?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 7171)
 (push.const . |.null?|)
 (push.gloc.of null?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 8195)
 (push.const . |.pair?|)
 (push.gloc.of pair?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 9219)
 (push.const . |.car|)
 (push.gloc.of car)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 10243)
 (push.const . |.cdr|)
 (push.gloc.of cdr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 11267)
 (push.const . |.caar|)
 (push.gloc.of caar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 12291)
 (push.const . |.cadr|)
 (push.gloc.of cadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 13315)
 (push.const . |.cdar|)
 (push.gloc.of cdar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 14339)
 (push.const . |.cddr|)
 (push.gloc.of cddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 15363)
 (push.const . |.caaar|)
 (push.gloc.of caaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 16387)
 (push.const . |.caadr|)
 (push.gloc.of caadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 17411)
 (push.const . |.cadar|)
 (push.gloc.of cadar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 18435)
 (push.const . |.caddr|)
 (push.gloc.of caddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 19459)
 (push.const . |.cdaar|)
 (push.gloc.of cdaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 20483)
 (push.const . |.cdadr|)
 (push.gloc.of cdadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 21507)
 (push.const . |.cddar|)
 (push.gloc.of cddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 22531)
 (push.const . |.cdddr|)
 (push.gloc.of cdddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 23555)
 (push.const . |.cdddar|)
 (push.gloc.of cdddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 24579)
 (push.const . |.caddar|)
 (push.gloc.of caddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 25603)
 (push.const . |.cddadr|)
 (push.gloc.of cddadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 26627)
 (push.const . |.cadadr|)
 (push.gloc.of cadadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 27651)
 (push.const . |.caaadr|)
 (push.gloc.of caaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 28675)
 (push.const . |.cddddr|)
 (push.gloc.of cddddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 29699)
 (push.const . |.cadddr|)
 (push.gloc.of cadddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 30723)
 (push.const . |.cdaadr|)
 (push.gloc.of cdaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 31747)
 (push.const . |.cdaddr|)
 (push.gloc.of cdaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 32771)
 (push.const . |.caaddr|)
 (push.gloc.of caaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 33795)
 (push.const . |.list|)
 (push.gloc.of list)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 34819)
 (push.const . |.cons*|)
 (push.gloc.of cons*)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 35843)
 (push.const . |.memq|)
 (push.gloc.of memq)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 36867)
 (push.const . |.append|)
 (push.gloc.of append)
 (ret.subr.gloc.of set-top-level-value! "./boot/first-load.scm" . 37891))

;
((close
   (0 1 . max)
   (iloc.0 . 0)
   (if.null?
     (push.const . max)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 8204))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 9242)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 9228)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 12316))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 13347)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 13333)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 14370)
           (>.iloc (0 . 0) "./boot/r6rs-aux.scm" . 14367)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 14387))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 15404)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 15394))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 16411)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 14357))
       (push.const . max)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 18515)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 18479)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 18453))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10270)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10296)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 10286)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10314)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 10252))
   (push.const . max)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 20554)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 20518)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 20492))
 (set.gloc.of max)
 (ret.const.unspec))
((close
   (0 1 . min)
   (iloc.0 . 0)
   (if.null?
     (push.const . min)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 25612))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 26650)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 26636)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 29724))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 30755)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 30741)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 31778)
           (<.iloc (0 . 0) "./boot/r6rs-aux.scm" . 31775)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 31795))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 32812)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 32802))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 33819)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 31765))
       (push.const . min)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 35923)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 35887)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 35861))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27678)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27704)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 27694)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27722)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 27660))
   (push.const . min)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 37962)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 37926)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 37900))
 (set.gloc.of min)
 (ret.const.unspec))
((close
   (2 0 . gcd2)
   (=n.iloc (0 . 1) 0 "./boot/r6rs-aux.scm" . 41993)
   (if.true
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 43026)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 43039))
       (ret.iloc 0 . 0))
     (push)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 43017))
   (touch.gloc.of gcd2)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of remainder 2 "./boot/r6rs-aux.scm" . 44049)
   (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 44041))
 (set.gloc.of gcd2)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 53261)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54292)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54302)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 54286))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 55315)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 55310))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 0)
   (touch.gloc.of |loop`7|)
   (call
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57377)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57387)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 57371))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57399)
   (push.cons)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 57359))
 (set.gloc.of |loop`7|)
 (close
   (0 1 . gcd)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 49173)
       (if.true.ret)
       (push.const . gcd)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 50223)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 50197))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 48133))
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 52229))
 (set.gloc.of gcd)
 (ret.const.unspec))
((close
   (2 0 . lcm2)
   (call
     (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 64529)
     (if.true.ret)
     (push.iloc.0 . 1)
     (push.const . 0)
     (ret.subr.gloc.of = "./boot/r6rs-aux.scm" . 64537))
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of exact? 1 "./boot/r6rs-aux.scm" . 65558)
       (if.false.ret)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of exact? "./boot/r6rs-aux.scm" . 65569))
     (if.true.ret.const . 0)
     (ret.const . 0.0))
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of gcd2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 66593))
   (push)
   (push.subr.gloc.of quotient 2 "./boot/r6rs-aux.scm" . 66581)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 66578)
   (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 66573))
 (set.gloc.of |lcm2`2|)
 (close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 73741)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of |lcm2`2|)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74772)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74782)
     (apply.gloc.of |lcm2`2| "./boot/r6rs-aux.scm" . 74766))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 75795)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 75790))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 1)
   (touch.gloc.of |loop`9|)
   (call
     (touch.gloc.of |lcm2`2|)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77857)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77867)
     (apply.gloc.of |lcm2`2| "./boot/r6rs-aux.scm" . 77851))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77879)
   (push.cons)
   (apply.gloc.of |loop`9| "./boot/r6rs-aux.scm" . 77839))
 (set.gloc.of |loop`9|)
 (close
   (0 1 . lcm)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 69653)
       (if.true.ret)
       (push.const . lcm)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 70703)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 70677))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 68613))
   (touch.gloc.of |loop`9|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`9| "./boot/r6rs-aux.scm" . 72709))
 (set.gloc.of lcm)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (=.iloc (0 . 1) "./boot/r6rs-aux.scm" . 92183)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.subr.gloc.of ceiling 1 "./boot/r6rs-aux.scm" . 94240)
   (extend . 1)
   (iloc.0 . 0)
   (<.iloc (1 . 1) "./boot/r6rs-aux.scm" . 95264)
   (if.true (ret.iloc 0 . 0))
   (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 97321)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . 1)
   (call
     (touch.gloc.of |loop`7|)
     (push.const . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98359)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98354)
     (push.const . 1)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98375)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98370)
     (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 98348))
   (push)
   (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98343)
   (ret.subr.gloc.of + "./boot/r6rs-aux.scm" . 98338))
 (set.gloc.of |loop`7|)
 (close
   (2 0 . rationalize)
   (push.iloc.0 . 0)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 81929)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 81973)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 82026)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 81939))
   (push.iloc.0 . 1)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 82953)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 82997)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 83050)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 82963))
   (push.iloc.0 . 1)
   (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 83980)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 85008)
     (if.true.ret.const . +nan.0)
     (ret.const . 0.0))
   (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 86028)
   (if.true.ret.const . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of negative? 1 "./boot/r6rs-aux.scm" . 87052)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 1 "./boot/r6rs-aux.scm" . 88092)
       (push.iloc.0 . 1)
       (apply.gloc.of rationalize "./boot/r6rs-aux.scm" . 88079))
     (push)
     (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 88076))
   (push.iloc.0 . 1)
   (push.subr.gloc.of abs 1 "./boot/r6rs-aux.scm" . 90133)
   (extend . 1)
   (touch.gloc.of |loop`7|)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 91169)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of + 2 "./boot/r6rs-aux.scm" . 91183)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 91150))
 (set.gloc.of rationalize)
 (ret.const.unspec))
((close
   (1 0 . list->string)
   (push.gloc.of string)
   (push.iloc.0 . 0)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 101393))
 (set.gloc.of list->string)
 (ret.const.unspec))
((close
   (1 0 . list->vector)
   (push.gloc.of vector)
   (push.iloc.0 . 0)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 104465))
 (set.gloc.of list->vector)
 (ret.const.unspec))
((close
   (1 0 . string->list)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 109579)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 111633)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-ref 2 "./boot/r6rs-aux.scm" . 111647)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 111627))
   (push.iloc.1 . 0)
   (push.subr.gloc.of string-length 1 "./boot/r6rs-aux.scm" . 108566)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 108563)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 108549))
 (set.gloc.of string->list)
 (ret.const.unspec))
((close
   (2 0 . map-1)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 120860)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 120854))
   (push)
   (call
     (touch.gloc.of |map-1`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 121890)
     (apply.gloc.of |map-1`2| "./boot/r6rs-aux.scm" . 121878))
   (ret.cons "./boot/r6rs-aux.scm" . 120848))
 (set.gloc.of |map-1`2|)
 (close
   (2 0 . map-n)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 128034)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 128022))
   (push)
   (call
     (touch.gloc.of |map-n`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 129058)
     (apply.gloc.of |map-n`2| "./boot/r6rs-aux.scm" . 129046))
   (ret.cons "./boot/r6rs-aux.scm" . 128016))
 (set.gloc.of |map-n`2|)
 (close
   (2 1 . map)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 132109)
     (if.true
       (touch.gloc.of |map-1`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |map-1`2| "./boot/r6rs-aux.scm" . 133133))
     (push.const . map)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 134183))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 134234)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 134157))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 135184))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |map-n`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |map-n`2| "./boot/r6rs-aux.scm" . 136225))
   (push.const . map)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 138318)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 138256))
 (set.gloc.of map)
 (ret.const.unspec))
((close
   (2 0 . for-each-n)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 151597)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 151585))
   (touch.gloc.of |for-each-n`2|)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 152626)
   (apply.gloc.of |for-each-n`2| "./boot/r6rs-aux.scm" . 152609))
 (set.gloc.of |for-each-n`2|)
 (close
   (2 0 . for-each-1)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 146470)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 146464))
   (touch.gloc.of |for-each-1`2|)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 147505)
   (apply.gloc.of |for-each-1`2| "./boot/r6rs-aux.scm" . 147488))
 (set.gloc.of |for-each-1`2|)
 (close
   (2 1 . for-each)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 154637)
     (if.true
       (touch.gloc.of |for-each-1`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |for-each-1`2| "./boot/r6rs-aux.scm" . 155661))
     (push.const . for-each)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 156716))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 156767)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 156685))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 157712))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |for-each-n`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |for-each-n`2| "./boot/r6rs-aux.scm" . 158753))
   (push.const . for-each)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 160851)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 160784))
 (set.gloc.of for-each)
 (ret.const.unspec))
((close
   (2 1 . vector-map)
   (call
     (push.gloc.of map)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 165910)
     (call
       (push.gloc.of vector->list)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/r6rs-aux.scm" . 166925))
     (push)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 165894))
   (push)
   (apply.gloc.of list->vector "./boot/r6rs-aux.scm" . 164869))
 (set.gloc.of vector-map)
 (ret.const.unspec))
((close
   (2 1 . vector-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 171034)
   (call
     (push.gloc.of vector->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 172044))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 171013))
 (set.gloc.of vector-for-each)
 (ret.const.unspec))
((close
   (2 1 . string-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/r6rs-aux.scm" . 176154))
   (push)
   (call
     (push.gloc.of string->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 177164))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 176133))
 (set.gloc.of string-for-each)
 (ret.const.unspec))
((close
   (2 0 . call-with-values)
   (touch.gloc.of apply-values)
   (push.iloc.0 . 1)
   (call (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 181276))
   (push)
   (apply.gloc.of apply-values "./boot/r6rs-aux.scm" . 181253))
 (set.gloc.of call-with-values)
 (ret.const.unspec))
((close
   (2 0 . mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 185357)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 185354)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 185349))
 (set.gloc.of mod)
 (ret.const.unspec))
((close
   (2 0 . div-and-mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 189454)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 190486)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 190481)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 190471))
 (set.gloc.of div-and-mod)
 (ret.const.unspec))
((close
   (2 0 . mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 194573)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 194570)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 194565))
 (set.gloc.of mod0)
 (ret.const.unspec))
((close
   (2 0 . div0-and-mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 198671)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 199703)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 199698)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 199687))
 (set.gloc.of div0-and-mod0)
 (ret.const.unspec))

;
((close
   (1 0 . top-level-unbound?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-bound? 1 "./boot/common.scm" . 7178)
   (ret.subr.gloc.of not "./boot/common.scm" . 7173))
 (set.gloc.of top-level-unbound?)
 (ret.const.unspec))
((close
   (3 0 . acons)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (ret.cons "./boot/common.scm" . 11269))
 (set.gloc.of acons)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 16413)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 16423)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 16407))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . count-pair)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 15365))
 (set.gloc.of count-pair)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/common.scm" . 22547)
   (if.not.pair?.ret.const . #f)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 23573)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (touch.gloc.of |loop`5|)
   (push.cddr.iloc (0 . 0) "./boot/common.scm" . 24598)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 24610)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 24592))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . circular-list?)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 20485))
 (set.gloc.of circular-list?)
 (ret.const.unspec))
((close
   (1 0 . circular-tree?)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (2 0 . loop)
       (call
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/common.scm" . 30743)
         (if.false.ret)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/common.scm" . 31767))
       (if.true.ret)
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 33817)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/common.scm" . 35877)
           (push.iloc.0 . 0)
           (apply.iloc (2 . 0) "./boot/common.scm" . 35871))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/common.scm" . 36901)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/common.scm" . 36895))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/common.scm" . 37913)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 38937)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 41005))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/common.scm" . 41024)
         (apply.gloc.of any1 "./boot/common.scm" . 40987))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/common.scm" . 42009)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 43033)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 45101))
         (push.iloc.1 . 0)
         (push.subr.gloc.of tuple->list 1 "./boot/common.scm" . 45120)
         (apply.gloc.of any1 "./boot/common.scm" . 45083))
       (ret.const . #f))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc (0 . 0) "./boot/common.scm" . 29708))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of circular-tree?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 53265)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 53275)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 53259))
   (call (iloc.0 . 0) (if.not.null?.ret.const . #f) (ret.iloc 0 . 1))
   (if.true.ret)
   (ret.const . -1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . safe-length)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 51205))
 (set.gloc.of safe-length)
 (ret.const.unspec))
((close
   (2 0 . split-at)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-head 2 "./boot/common.scm" . 58383)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-tail 2 "./boot/common.scm" . 58401)
   (ret.subr.gloc.of values "./boot/common.scm" . 58375))
 (set.gloc.of split-at)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/common.scm" . 65576)
   (if.not.symbol?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 66592)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 66602)
   (subr.gloc.of memq 2 "./boot/common.scm" . 66586)
   (if.true.ret)
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 67616)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 67610))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . unique-id-list?)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 62474)
   (if.false.ret)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 63503))
   (push)
   (ret.subr.gloc.of not "./boot/common.scm" . 62469))
 (set.gloc.of unique-id-list?)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 74779)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 74789)
   (subr.gloc.of memq 2 "./boot/common.scm" . 74773)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/common.scm" . 75797))
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 76827)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 76821))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . find-duplicates)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 71690)
   (if.false.ret)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 72714))
 (set.gloc.of find-duplicates)
 (ret.const.unspec))
((close
   (2 0 . every1)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (2 0 . loop)
     (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "./boot/common.scm" . 82960))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 85018)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 85029)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 85012))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 81946)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 81963)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 81929))
 (set.gloc.of every1)
 (ret.const.unspec))
((close
   (3 0 . every2)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (iloc.0 . 2)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (4 0 . loop)
     (call (push.iloc.0 . 0) (push.iloc.0 . 2) (apply.iloc (2 . 0) "./boot/common.scm" . 92176))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (iloc.0 . 3)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 95258)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 95270)
     (push.car.iloc (0 . 3) "./boot/common.scm" . 95282)
     (push.cdr.iloc (0 . 3) "./boot/common.scm" . 95294)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 95252))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 91163)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 91182)
   (push.car.iloc (1 . 2) "./boot/common.scm" . 91201)
   (push.cdr.iloc (1 . 2) "./boot/common.scm" . 91220)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 91145))
 (set.gloc.of every2)
 (ret.const.unspec))
((close
   (2 0 . any1)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 100372)
     (apply.iloc (0 . 0) "./boot/common.scm" . 100366))
   (if.true.ret)
   (touch.gloc.of any1)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 100394)
   (apply.gloc.of any1 "./boot/common.scm" . 100383))
 (set.gloc.of any1)
 (ret.const.unspec))
((close
   (3 0 . any2)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (iloc.0 . 2)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 106516)
     (push.car.iloc (0 . 2) "./boot/common.scm" . 106527)
     (apply.iloc (0 . 0) "./boot/common.scm" . 106510))
   (if.true.ret)
   (touch.gloc.of any2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 107545)
   (push.cdr.iloc (0 . 2) "./boot/common.scm" . 107556)
   (apply.gloc.of any2 "./boot/common.scm" . 107534))
 (set.gloc.of any2)
 (ret.const.unspec))
((close
   (2 0 . filter)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 113684)
       (apply.iloc (2 . 0) "./boot/common.scm" . 113678))
     (if.true
       (push.car.iloc (0 . 0) "./boot/common.scm" . 113701)
       (call
         (push.cdr.iloc (0 . 0) "./boot/common.scm" . 113717)
         (apply.iloc+ (1 . 0) "./boot/common.scm" . 113711))
       (ret.cons "./boot/common.scm" . 113695))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 114713)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 114707))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 111621))
 (set.gloc.of filter)
 (ret.const.unspec))
((close
   (2 0 . partition)
   (extend.enclose+
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 119842)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 119857)
       (ret.subr.gloc.of values "./boot/common.scm" . 119834))
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 120852)
       (apply.iloc (2 . 0) "./boot/common.scm" . 120846))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/common.scm" . 120869)
       (push.car.iloc (0 . 0) "./boot/common.scm" . 120885)
       (iloc.0 . 1)
       (push.cons)
       (push.iloc.0 . 2)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 120863))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 121881)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/common.scm" . 121902)
     (iloc.0 . 2)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 121875))
   (push.iloc.1 . 1)
   (push.const)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 118789))
 (set.gloc.of partition)
 (ret.const.unspec))
((close
   (2 0 . split->list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of make-string-input-port 1 "./boot/common.scm" . 129043)
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop1)
     (extend.enclose+
       (1 0 . loop2)
       (push.iloc.0 . 0)
       (subr.gloc.of eof-object? 1 "./boot/common.scm" . 133142)
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 134175)
         (extend . 1)
         (push.iloc.0 . 0)
         (push.const . "")
         (subr.gloc.of string=? 2 "./boot/common.scm" . 135196)
         (if.true (push.iloc 3 . 0) (ret.subr.gloc.of reverse "./boot/common.scm" . 136220))
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (push.cons)
         (ret.subr.gloc.of reverse "./boot/common.scm" . 137244))
       (call (push.iloc.0 . 0) (apply.iloc (5 . 1) "./boot/common.scm" . 138262))
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 139299)
         (iloc 2 . 0)
         (push.cons)
         (apply.iloc+ (3 . 0) "./boot/common.scm" . 139286))
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of put-char 2 "./boot/common.scm" . 141334)
       (push.iloc 4 . 0)
       (push.subr.gloc.of get-char 1 "./boot/common.scm" . 142365)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 142358))
     (push.iloc 3 . 0)
     (push.subr.gloc.of get-char 1 "./boot/common.scm" . 132124)
     (apply.iloc+ (0 . 0) "./boot/common.scm" . 132109))
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 131083))
 (set.gloc.of |split->list`2|)
 (close
   (2 0 . string-split)
   (push.iloc.0 . 1)
   (subr.gloc.of char? 1 "./boot/common.scm" . 144396)
   (if.true
     (touch.gloc.of |split->list`2|)
     (push.iloc.0 . 0)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of char=? "./boot/common.scm" . 145449))
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 145420))
   (push.iloc.0 . 1)
   (subr.gloc.of string? 1 "./boot/common.scm" . 146444)
   (if.true
     (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/common.scm" . 147479))
     (push)
     (extend . 1)
     (touch.gloc.of |split->list`2|)
     (push.iloc.1 . 0)
     (push.close
       (1 0)
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (ret.subr.gloc.of char=? "./boot/common.scm" . 148541))
       (push.iloc.1 . 0)
       (apply.gloc.of any1 "./boot/common.scm" . 148523))
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 148494))
   (push.iloc.0 . 1)
   (subr.gloc.of procedure? 1 "./boot/common.scm" . 149516)
   (if.true
     (touch.gloc.of |split->list`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 150540))
   (ret.const.unspec))
 (set.gloc.of string-split)
 (ret.const.unspec))
((close
   (2 1 . wrong-type-argument-message)
   (iloc.0 . 2)
   (if.null?
     (push.const . "expected ~a, but got ~a")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of format "./boot/common.scm" . 155657))
   (push.const . "expected ~a, but got ~a, as argument ~a")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.car.iloc (0 . 2) "./boot/common.scm" . 156742)
   (ret.subr.gloc.of format "./boot/common.scm" . 156681))
 (set.gloc.of wrong-type-argument-message)
 (ret.const.unspec))

;
((close
   (1 1 . make-parameter)
   (call
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of parameter-proc-0)
       (subr.gloc.of gensym 0)
       (push)
       (apply.gloc.of parameter-proc-0 "./boot/parameter.scm" . 8218))
     (touch.gloc.of parameter-proc-1)
     (subr.gloc.of gensym 0)
     (push)
     (push.car.iloc (0 . 1) "./boot/parameter.scm" . 9269)
     (apply.gloc.of parameter-proc-1 "./boot/parameter.scm" . 9242))
   (push)
   (extend . 1)
   (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/parameter.scm" . 10254))
   (ret.iloc 0 . 0))
 (set.gloc.of make-parameter)
 (ret.const.unspec))
((close
   (1 0 . parameter-proc-0)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 16395))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (0 . 0) "./boot/parameter.scm" . 17474)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 17419)))
 (set.gloc.of parameter-proc-0)
 (ret.const.unspec))
((close
   (2 0 . parameter-proc-1)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 23563))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (call
       (push.car.iloc (0 . 0) "./boot/parameter.scm" . 24648)
       (apply.iloc (1 . 1) "./boot/parameter.scm" . 24642))
     (push)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 24587)))
 (set.gloc.of parameter-proc-1)
 (ret.const.unspec))

;
((call (push.const . "") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 5152))
 (set.gloc.of current-library-prefix)
 (ret.const.unspec))
((call (push.const . ".") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 6175))
 (set.gloc.of current-library-infix)
 (ret.const.unspec))
((call (push.const . "'") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 7200))
 (set.gloc.of current-library-suffix)
 (ret.const.unspec))
((call (push.const . "`") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 9250))
 (set.gloc.of current-rename-delimiter)
 (ret.const.unspec))
((call (push.const . 5) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 10269))
 (set.gloc.of expansion-backtrace)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 11295))
 (set.gloc.of expansion-trace-stack)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 12319))
 (set.gloc.of expansion-trace-level)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 13351))
 (set.gloc.of current-immutable-identifiers)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 14368))
 (set.gloc.of current-expansion-mode)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 15399))
 (set.gloc.of current-expansion-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 16418))
 (set.gloc.of current-macro-expression)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 17449))
 (set.gloc.of current-transformer-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 18465))
 (set.gloc.of unexpect-top-level-form)
 (ret.const.unspec))
((close (3 0) (ret.iloc 0 . 0))
 (set.gloc.of |.fn1.1`1|)
 (call (push.gloc.of |.fn1.1`1|) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 19494))
 (set.gloc.of current-after-expansion-hook)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 20513))
 (set.gloc.of current-temporary-count)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 21534))
 (set.gloc.of current-rename-count)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 22562))
 (set.gloc.of current-closure-comments)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 23588))
 (set.gloc.of current-top-level-exterior)
 (ret.const.unspec))
((close
   (4 0)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/initial.scm" . 27658)
     (if.false.ret)
     (push.iloc.0 . 1)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 28682))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (call
     (push.iloc.0 . 0)
     (const . syntax)
     (if.eq?
       (touch.gloc.of make-macro)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of make-macro "./boot/macro/initial.scm" . 33821))
     (push.iloc.0 . 0)
     (const . variable)
     (if.eq?
       (push.iloc.0 . 2)
       (subr.gloc.of procedure? 1 "./boot/macro/initial.scm" . 35876)
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 36900))
       (call
         (touch.gloc.of variable-transformer-token?)
         (push.iloc.0 . 2)
         (apply.gloc.of variable-transformer-token? "./boot/macro/initial.scm" . 37924))
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/initial.scm" . 38969)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 38948))
       (push.const
         .
         "internal error in .set-top-level-macro!: bad transformer type:~s keyword:~s datum:~s")
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 40996))
     (ret.const.unspec))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 26627))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.set-top-level-macro!|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 26627))
((close
   (0 0 . generate-temporary-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 45074))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 46112)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 46087))
   (push.const . ".L~a")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/initial.scm" . 47127)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 47111))
 (set.gloc.of generate-temporary-symbol)
 (ret.const.unspec))
((close
   (1 0 . generate-local-macro-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 51218))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 52256)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 52231))
   (push.const . ".local-macro-~a.~a~a~a")
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 53313))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 53340))
   (push)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 53271)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 53255))
 (set.gloc.of generate-local-macro-symbol)
 (ret.const.unspec))
((close
   (0 0 . fresh-rename-count)
   (call
     (touch.gloc.of current-rename-count)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 57374))
     (push)
     (push.const . 1)
     (push.subr.gloc.of + 2 "./boot/macro/initial.scm" . 57371)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 57349))
   (touch.gloc.of current-rename-count)
   (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 58373))
 (set.gloc.of fresh-rename-count)
 (ret.const.unspec))
((close
   (2 0 . rename-id)
   (call
     (iloc.0 . 0)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error in rename-id: expect symbol but got ~s")
     (push.iloc.0 . 0)
     (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 62486))
   (push.const . "~a~a~a")
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 63529))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 4 "./boot/macro/initial.scm" . 63509)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 63493))
 (set.gloc.of rename-id)
 (ret.const.unspec))
((close
   (1 0 . renamed-id?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 68635)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 68655))
   (push)
   (ret.subr.gloc.of string-contains "./boot/macro/initial.scm" . 68618))
 (set.gloc.of renamed-id?)
 (ret.const.unspec))
((close
   (1 0 . original-id)
   (call
     (iloc.0 . 0)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error in original-id: expect symbol but got ~s")
     (push.iloc.0 . 0)
     (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 72726))
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 73745)
   (extend . 1)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 74788))
   (push)
   (push.subr.gloc.of string-contains 2 "./boot/macro/initial.scm" . 74766)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of substring 3 "./boot/macro/initial.scm" . 75824)
     (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 75808))
   (ret.iloc 2 . 0))
 (set.gloc.of original-id)
 (ret.const.unspec))
((close
   (1 0 . strip-rename-suffix)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 81962)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 81941))
     (push)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 82986)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 82965))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/initial.scm" . 84001)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/initial.scm" . 84019)
       (ret.eq? "./boot/macro/initial.scm" . 84012))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/initial.scm" . 85018))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of original-id)
     (push.iloc.0 . 0)
     (apply.gloc.of original-id "./boot/macro/initial.scm" . 86042))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/initial.scm" . 87052)
   (if.true
     (call
       (push.gloc.of strip-rename-suffix)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/initial.scm" . 87105)
       (apply.gloc.of map "./boot/macro/initial.scm" . 87080))
     (push)
     (apply.gloc.of list->vector "./boot/macro/initial.scm" . 87066))
   (ret.iloc 0 . 0))
 (set.gloc.of strip-rename-suffix)
 (ret.const.unspec))
((close
   (1 0 . retrieve-rename-suffix)
   (call
     (iloc.0 . 0)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error in retrieve-rename-suffix: expect symbol but got ~s")
     (push.iloc.0 . 0)
     (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 92182))
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 93201)
   (extend . 1)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 94244))
   (push)
   (push.subr.gloc.of string-contains 2 "./boot/macro/initial.scm" . 94222)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/macro/initial.scm" . 95285)
     (ret.subr.gloc.of substring "./boot/macro/initial.scm" . 95264))
   (ret.const . ""))
 (set.gloc.of retrieve-rename-suffix)
 (ret.const.unspec))
((close
   (2 0 . set-closure-comment!)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 100362))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 101407))
   (push)
   (push.iloc.0 . 0)
   (push.const . heap)
   (iloc.0 . 1)
   (push.cons)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 101386))
 (set.gloc.of set-closure-comment!)
 (ret.const.unspec))
((close
   (2 1 . annotate-closure)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 105482))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 106533))
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 106513)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (iloc.1 . 2)
     (if.null?
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 109615))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 109594))
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 110639))
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (1 . 2) "./boot/macro/initial.scm" . 110677)
     (cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 110688)
     (push.cons)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 110618))
   (ret.const.unspec))
 (set.gloc.of annotate-closure)
 (ret.const.unspec))
((close
   (1 0 . annotated?)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 114698)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 115722)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of annotated?)
 (ret.const.unspec))
((close
   (1 0 . get-annotation)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 121866)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 122890))
 (set.gloc.of get-annotation)
 (ret.const.unspec))
((close
   (2 0 . put-annotation)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 128010)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 129034))
   (ret.iloc 0 . 0))
 (set.gloc.of put-annotation)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 149524)
   (if.true.ret)
   (call
     (touch.gloc.of |loop`15|)
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 150554)
     (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 150548))
   (if.true.ret)
   (touch.gloc.of |loop`15|)
   (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 151578)
   (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 151572))
 (set.gloc.of |loop`15|)
 (close
   (2 0 . put-note!)
   (iloc.0 . 1)
   (if.false.ret)
   (extend.enclose
     (1 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/initial.scm" . 139285)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 140313)
     (if.true.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (subr.gloc.of core-hashtable-set! 3 "./boot/macro/initial.scm" . 142363)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/macro/initial.scm" . 143387))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/initial.scm" . 138254))
 (set.gloc.of |put-note!`2|)
 (close
   (1 0 . get-note)
   (touch.gloc.of |loop`15|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 147465))
 (set.gloc.of |get-note`2|)
 (close
   (2 0 . annotate)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #f)
     (call
       (call
         (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 157720)
         (if.false.ret)
         (touch.gloc.of |get-note`2|)
         (push.iloc.0 . 1)
         (apply.gloc.of |get-note`2| "./boot/macro/initial.scm" . 157746))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of |put-note!`2|)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |put-note!`2| "./boot/macro/initial.scm" . 158754))
       (ret.const.unspec))
     (call
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 159768))
       (if.false.ret)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 159815))
       (push)
       (push.iloc.0 . 1)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 159795))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 160823))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 160802))
     (ret.const.unspec))
   (ret.iloc 0 . 0))
 (set.gloc.of annotate)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 168975)
     (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 168984))
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 170010)
     (call
       (touch.gloc.of |loop`5|)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 170026)
       (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 170036)
       (apply.gloc.of |loop`5| "./boot/macro/initial.scm" . 170020))
     (ret.cons "./boot/macro/initial.scm" . 170004))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`5|)
 (close
   (2 0 . abbreviated-take)
   (touch.gloc.of annotate)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`5| "./boot/macro/initial.scm" . 166918))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 166918))
 (set.gloc.of abbreviated-take)
 (ret.const.unspec))
((close
   (3 0 . abbreviated-take-form)
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 178195)
           (if.true.ret)
           (push.iloc.0 . 2)
           (push.const . 0)
           (ret.subr.gloc.of <= "./boot/macro/initial.scm" . 178205))
         (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 178216))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 179232)
           (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 179242)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 179226))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 179261)
           (push.iloc 2 . 1)
           (push.n+.iloc (0 . 2) -1 "./boot/macro/initial.scm" . 179276)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 179255))
         (ret.cons "./boot/macro/initial.scm" . 179220))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (apply.iloc+ (0 . 0) "./boot/macro/initial.scm" . 176134))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 174083))
 (set.gloc.of abbreviated-take-form)
 (ret.const.unspec))

;
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 9234)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 9259)
       (apply.gloc.of formals->list "./boot/macro/expand.scm" . 9244))
     (ret.cons "./boot/macro/expand.scm" . 9228))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/macro/expand.scm" . 11276))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . collect-lambda-formals)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/macro/expand.scm" . 15377))
   (push)
   (extend . 1)
   (call
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/expand.scm" . 16395))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 17437)
     (push.const . "malformed formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 17419))
   (call
     (call
       (touch.gloc.of unique-id-list?)
       (push.iloc.0 . 0)
       (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 18443))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 19485)
     (push.const . "duplicate formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 19467))
   (ret.iloc 0 . 0))
 (set.gloc.of collect-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . rename-lambda-formals)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 26653)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 26647)
     (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 26642)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 27689)
       (push.iloc.0 . 1)
       (apply.gloc.of rename-lambda-formals "./boot/macro/expand.scm" . 27666))
     (ret.cons "./boot/macro/expand.scm" . 26636))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 29713)
   (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 29708))
 (set.gloc.of rename-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . check-let*-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 33801)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 34843)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 34825))
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.0 . 0)
         (apply.gloc.of safe-length "./boot/macro/expand.scm" . 36893))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/expand.scm" . 36890)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 36927)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 36918))
     (if.true.ret)
     (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 37927)
     (push.const . "expected each binding consist of symbol and expression")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 37909))
   (push.iloc.0 . 1)
   (apply.gloc.of for-each "./boot/macro/expand.scm" . 35845))
 (set.gloc.of check-let*-bindings)
 (ret.const.unspec))
((close
   (2 0 . check-let-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 43017)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 44059)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 44041))
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.close
         (1 0)
         (call
           (call
             (touch.gloc.of safe-length)
             (push.iloc.0 . 0)
             (apply.gloc.of safe-length "./boot/macro/expand.scm" . 47133))
           (push)
           (push.const . 2)
           (subr.gloc.of = 2 "./boot/macro/expand.scm" . 47130)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 47167)
           (if.not.symbol?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 47182))
         (if.true.ret)
         (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 48167)
         (push.const . "expected each binding consist of symbol and expression")
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 48149))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 46090))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 45065))
   (if.true.ret)
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 50203)
   (push.const . "duplicate bindings")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 50185))
 (set.gloc.of check-let-bindings)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`7|)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 59416)
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 60446)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 60440))
     (push)
     (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 59410))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 62489)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 63518))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of |filter-unique-ids`2|)
   (call
     (touch.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`15| "./boot/macro/expand.scm" . 69642))
   (push)
   (apply.gloc.of |filter-unique-ids`2| "./boot/macro/expand.scm" . 57353))
 (set.gloc.of |collect-ids`2|)
 (close
   (1 0 . filter-unique-ids)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 57353))
 (set.gloc.of |filter-unique-ids`2|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 72738)
     (push.const . quote)
     (push.subr.gloc.of eq? 2 "./boot/macro/expand.scm" . 72733)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 72728))
   (if.true
     (push.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 73747))
   (ret.const))
 (set.gloc.of |loop`15|)
 (close
   (2 0 . check-internal-def-contract-violation)
   (call
     (touch.gloc.of |collect-ids`2|)
     (push.iloc.0 . 1)
     (apply.gloc.of |collect-ids`2| "./boot/macro/expand.scm" . 76816))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 77855)
     (if.false.ret)
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 77831))
 (set.gloc.of check-internal-def-contract-violation)
 (ret.const.unspec))
((close
   (1 0 . filter-unique-ids)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 85001))
 (set.gloc.of |filter-unique-ids`2|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 100387)
     (push.const lambda quote)
     (push.subr.gloc.of memq 2 "./boot/macro/expand.scm" . 100381)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 100376))
   (if.true
     (push.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 101395))
   (ret.const))
 (set.gloc.of |loop`15|)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`7|)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 87064)
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 88094)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 88088))
     (push)
     (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 87058))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 90137)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 91166))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of |filter-unique-ids`2|)
   (call
     (touch.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`15| "./boot/macro/expand.scm" . 97290))
   (push)
   (apply.gloc.of |filter-unique-ids`2| "./boot/macro/expand.scm" . 83975))
 (set.gloc.of |collect-ids`2|)
 (close
   (2 0 . check-rec-contract-violation)
   (call
     (touch.gloc.of |collect-ids`2|)
     (push.iloc.0 . 1)
     (apply.gloc.of |collect-ids`2| "./boot/macro/expand.scm" . 104464))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of memq "./boot/macro/expand.scm" . 105498))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 105479))
 (set.gloc.of check-rec-contract-violation)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of check-rec-contract-violation)
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 111667)
     (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 111632))
   (if.true.ret)
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 112662)
   (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 112673)
   (apply.gloc.of |loop`5| "./boot/macro/expand.scm" . 112656))
 (set.gloc.of |loop`5|)
 (close
   (2 0 . check-rec*-contract-violation)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of |loop`5| "./boot/macro/expand.scm" . 109573))
 (set.gloc.of check-rec*-contract-violation)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/expand.scm" . 124935))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . rewrite-letrec*-bindings)
   (push.close
     (0 0)
     (touch.gloc.of partition)
     (push.close
       (1 0)
       (cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 118835)
       (if.not.pair?.ret.const . #t)
       (call
         (touch.gloc.of denote-quote?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 119866)
         (apply.gloc.of denote-quote? "./boot/macro/expand.scm" . 119847))
       (if.true.ret)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 120891)
         (apply.gloc.of denote-lambda? "./boot/macro/expand.scm" . 120871))
       (if.true
         (call
           (touch.gloc.of set-closure-comment!)
           (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 121924)
           (call
             (touch.gloc.of original-id)
             (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 121952)
             (apply.gloc.of original-id "./boot/macro/expand.scm" . 121939))
           (push)
           (apply.gloc.of set-closure-comment! "./boot/macro/expand.scm" . 121902))
         (ret.const . #t))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (apply.gloc.of partition "./boot/macro/expand.scm" . 116741))
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 115715))
 (set.gloc.of rewrite-letrec*-bindings)
 (ret.const.unspec))
((close
   (2 0 . flatten-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 132117)
     (if.not.pair?.ret.const . #f)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 133145)
       (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 133138)
       (if.true.ret)
       (push.const . #f)
       (push.const . "expression is not a proper list")
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 134217)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 134162))
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 135201)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 135182))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 140303))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 141333)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 142363)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 142357))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 141327))
       (iloc.0 . 1)
       (if.null? (ret.iloc 0 . 0))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of append "./boot/macro/expand.scm" . 146454))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 138246))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 130053))
 (set.gloc.of flatten-begin)
 (ret.const.unspec))
((close
   (2 0 . flatten-top-level-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 154645)
     (if.not.pair?.ret.const . #f)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 155673)
       (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 155666)
       (if.true.ret)
       (push.const . #f)
       (push.const . "expression is not a proper list")
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 156745)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 156690))
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 157729)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 157710))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 162831))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 163861)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 164891)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 164885))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 163855))
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 166933)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 167963)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 167957))
       (ret.cons "./boot/macro/expand.scm" . 166927))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 160774))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 152581))
 (set.gloc.of flatten-top-level-begin)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 197643)
     (ret.pair? "./boot/macro/expand.scm" . 197643))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
     (ret.null? "./boot/macro/expand.scm" . 197643))
   (if.true
     (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
     (push.const . |.SYNTAX|)
     (push.cadr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
     (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 197643)
     (ret.subr.gloc.of |.list| "./boot/macro/expand.scm" . 197643))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/expand.scm" . 197643)
     (ret.null? "./boot/macro/expand.scm" . 197643))
   (if.true
     (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
     (push.cadr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
     (push.const . |.SYNTAX|)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/expand.scm" . 197643)
     (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 197643)
     (ret.subr.gloc.of |.list| "./boot/macro/expand.scm" . 197643))
   (push.const . "internal error: syntax-rules->syntax-case")
   (apply.gloc.of scheme-error "./boot/macro/expand.scm" . 197643))
 (set.gloc.of |.fn1.1`1|)
 (close
   (3 0 . compile-macro)
   (extend.unbound . 4)
   (push.close
     (2 0 . compile-transformer)
     (push.const . |.transformer-thunk|)
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (call
             (touch.gloc.of make-out-of-context)
             (push.const . #f)
             (apply.gloc.of make-out-of-context "./boot/macro/expand.scm" . 177207))
           (push)
           (extend . 2)
           (call
             (push.close
               (1 0)
               (car.iloc (0 . 0) "./boot/macro/expand.scm" . 179244)
               (if.not.symbol?.ret.const . #f)
               (call
                 (touch.gloc.of renamed-id?)
                 (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 180272)
                 (apply.gloc.of renamed-id? "./boot/macro/expand.scm" . 180259))
               (if.false.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 181310)
               (push.const . #f)
               (subr.gloc.of core-hashtable-ref 3 "./boot/macro/expand.scm" . 181287)
               (if.true.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 182335)
               (push.iloc.1 . 1)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/expand.scm" . 182311))
             (push.iloc.1 . 1)
             (apply.gloc.of for-each "./boot/macro/expand.scm" . 178194))
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable->alist "./boot/macro/expand.scm" . 184338))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 185414))
       (push)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 185389))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 185361)
     (extend . 1)
     (call
       (touch.gloc.of interpret-coreform)
       (push.iloc.0 . 0)
       (apply.gloc.of interpret-coreform "./boot/macro/expand.scm" . 186393))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 187414)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 187432))
     (call
       (touch.gloc.of variable-transformer-token?)
       (push.iloc.0 . 0)
       (apply.gloc.of variable-transformer-token? "./boot/macro/expand.scm" . 188438))
     (if.true
       (call
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 0)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/expand.scm" . 189491)
         (push.iloc 2 . 1)
         (apply.gloc.of make-macro-variable "./boot/macro/expand.scm" . 189470))
       (push)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 189462))
     (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 191528)
     (push.const . "invalid transformer expression")
     (push.iloc 4 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 191510))
   (push.close+
     (2 0 . compile-extended-syntax-rules)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 195607))
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/expand.scm" . 196628))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
       (if.not.pair?.ret.const . #f)
       (push.cadr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
       (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 197643)
       (if.false.ret)
       (push.cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
       (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 197643)
       (if.false.ret)
       (push.const . |.LAMBDA|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.list| 1 "./boot/macro/expand.scm" . 197643)
       (push.const . |.SYNTAX-CASE|)
       (push.iloc.0 . 0)
       (push.cadr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
       (call
         (push.gloc.of |.fn1.1`1|)
         (push.cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 197643)
         (apply.gloc.of map "./boot/macro/expand.scm" . 197643))
       (push)
       (push.subr.gloc.of |.cons*| 4 "./boot/macro/expand.scm" . 197643)
       (ret.subr.gloc.of |.list| "./boot/macro/expand.scm" . 197643))
     (push)
     (push.iloc.1 . 1)
     (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 195593))
   (push.close
     (1 0 . syntax-rules?)
     (touch.gloc.of denote-syntax-rules?)
     (push.iloc 2 . 2)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-syntax-rules? "./boot/macro/expand.scm" . 213001))
   (push.close
     (1 0 . no-fender?)
     (touch.gloc.of every1)
     (push.close
       (1 0)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 218131)
         (ret.pair? "./boot/macro/expand.scm" . 218131))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (car.iloc (1 . 0) "./boot/macro/expand.scm" . 218131)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 218131)
         (ret.pair? "./boot/macro/expand.scm" . 218131))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (2 . 0) "./boot/macro/expand.scm" . 218131)
         (ret.null? "./boot/macro/expand.scm" . 218131))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.false.ret)
         (cddr.iloc (3 . 0) "./boot/macro/expand.scm" . 218131)
         (if.not.pair?.ret.const . #f)
         (push.iloc 3 . 0)
         (subr.gloc.of |.cdddr| 1 "./boot/macro/expand.scm" . 218131)
         (ret.null? "./boot/macro/expand.scm" . 218131))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.subr.gloc.of |.caar| 1 "./boot/macro/expand.scm" . 218131)
         (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 218131))
       (if.true.ret.const . #t)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.subr.gloc.of |.caar| 1 "./boot/macro/expand.scm" . 218131)
         (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 218131))
       (if.true.ret.const . #f)
       (iloc.1 . 0)
       (if.true
         (push.const . syntax-rules)
         (push.const . "expected identifer for first subform of pattern")
         (push.iloc 7 . 1)
         (push.iloc 4 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 218131))
       (iloc.0 . 0)
       (if.true
         (push.const . syntax-rules)
         (push.const . "expected identifer for first subform of pattern")
         (push.iloc 7 . 1)
         (push.iloc 4 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 218131))
       (call
         (iloc 3 . 0)
         (if.false.ret)
         (cddr.iloc (4 . 0) "./boot/macro/expand.scm" . 218131)
         (if.not.pair?.ret.const . #f)
         (push.iloc 4 . 0)
         (subr.gloc.of |.cdddr| 1 "./boot/macro/expand.scm" . 218131)
         (ret.null? "./boot/macro/expand.scm" . 218131))
       (if.true
         (push.const . syntax-rules)
         (push.const . "expected list for pattern")
         (push.iloc 7 . 1)
         (push.iloc 4 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 218131))
       (call
         (iloc 3 . 0)
         (if.false.ret)
         (cddr.iloc (4 . 0) "./boot/macro/expand.scm" . 218131)
         (ret.null? "./boot/macro/expand.scm" . 218131))
       (if.true
         (push.const . syntax-rules)
         (push.const . "expected list for pattern")
         (push.iloc 7 . 1)
         (push.iloc 4 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 218131))
       (push.const . syntax-rules)
       (push.const . "expected (pattern template) or (pattern fender template) for each rule")
       (push.iloc 7 . 1)
       (push.iloc 4 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 218131))
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/macro/expand.scm" . 216071))
   (enclose . 4)
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (if.not.null?.ret.const . #f)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (apply.iloc (0 . 2) "./boot/macro/expand.scm" . 174085))
   (if.true
     (push.const . syntax-rules)
     (push.const . "expected literals and rules")
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 174085)
     (if.false.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (apply.iloc (0 . 2) "./boot/macro/expand.scm" . 174085))
   (if.true
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (push.cadr.iloc (1 . 1) "./boot/macro/expand.scm" . 174085)
     (extend . 2)
     (call
       (call
         (push.iloc.0 . 1)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 174085)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 1)
         (apply.gloc.of every1 "./boot/macro/expand.scm" . 174085))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "invalid literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 1)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 174085))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "duplicate literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call
       (push.const . _)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 174085)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "_ in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call
       (push.const . ...)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 174085)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "... in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 174085))
     (call (push.iloc.0 . 0) (apply.iloc (1 . 3) "./boot/macro/expand.scm" . 174085))
     (if.true
       (touch.gloc.of compile-syntax-rules)
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 2 . 2)
       (apply.gloc.of compile-syntax-rules "./boot/macro/expand.scm" . 174085))
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (apply.iloc+ (1 . 1) "./boot/macro/expand.scm" . 174085))
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (apply.iloc (0 . 0) "./boot/macro/expand.scm" . 174085))
 (set.gloc.of compile-macro)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 263223))
   (ret.cons "./boot/macro/expand.scm" . 263211))
 (set.gloc.of |.fn2.1`2|)
 (close
   (3 0 . expand-let-syntax-bindings)
   (call
     (push.gloc.of car)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 254993))
   (push)
   (extend . 1)
   (touch.gloc.of extend-env)
   (call
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 259126))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 260134))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 261163))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 258075))
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 256018))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 258056))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn2.1`2|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 263186))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 264210))
     (push)
     (ret.subr.gloc.of append "./boot/macro/expand.scm" . 263178))
   (push)
   (push.iloc.1 . 2)
   (apply.gloc.of extend-env "./boot/macro/expand.scm" . 254981))
 (set.gloc.of expand-let-syntax-bindings)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 278610))
   (ret.cons "./boot/macro/expand.scm" . 278590))
 (set.gloc.of |.fn1.1`1|)
 (close
   (3 0 . expand-letrec-syntax-bindings)
   (extend.enclose
     (1 0 . undefined-macro)
     (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 272411)
     (push.const . "attempt to reference unbound syntactic keyword")
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 272393))
   (call
     (push.gloc.of car)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 274449))
   (push)
   (call
     (push.gloc.of cadr)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 275474))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (touch.gloc.of make-macro)
       (push.iloc 2 . 0)
       (push.const)
       (apply.gloc.of make-macro "./boot/macro/expand.scm" . 276529))
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 276509))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of extend-env)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 278557))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 279581))
     (push)
     (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 278549)
     (push.iloc 3 . 2)
     (apply.gloc.of extend-env "./boot/macro/expand.scm" . 277524))
   (push)
   (extend . 1)
   (call
     (push.close
       (2 0)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 286773))
       (push)
       (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 286794)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 286763))
     (push.iloc 2 . 0)
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 6 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 282681))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 283689))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 284718))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 281630))
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 281611))
     (push)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 286733))
   (ret.iloc 0 . 0))
 (set.gloc.of expand-letrec-syntax-bindings)
 (ret.const.unspec))
((close
   (3 0 . expand-macro-use)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 292869))
   (call
     (touch.gloc.of current-macro-expression)
     (push.iloc.0 . 0)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 293893))
   (push.const . #f)
   (push.const . #f)
   (push.cddr.iloc (0 . 2) "./boot/macro/expand.scm" . 295001)
   (extend . 3)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 295943))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-transformer-environment)
       (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 295943))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 295943))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 2)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 295943))
   (push.close
     (0 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 295959)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 295947)
     (if.true (push.iloc 2 . 0) (cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 296972) (apply))
     (touch.gloc.of transcribe-syntax-rules)
     (push.iloc 2 . 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 298025)
     (apply.gloc.of transcribe-syntax-rules "./boot/macro/expand.scm" . 297995))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc.1 . 0)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 295943))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 1)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 295943))
   (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 295943))
 (set.gloc.of expand-macro-use)
 (ret.const.unspec))
((close
   (2 0 . rewrite-form)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 318487)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 318480))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 320528)
   (if.true
     (touch.gloc.of annotate)
     (call
       (touch.gloc.of |rewrite-form-each`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |rewrite-form-each`2| "./boot/macro/expand.scm" . 321562))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 321552))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/expand.scm" . 322576)
   (if.true
     (call
       (touch.gloc.of |rewrite-form-each`2|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/expand.scm" . 323633)
       (push.iloc.0 . 1)
       (apply.gloc.of |rewrite-form-each`2| "./boot/macro/expand.scm" . 323614))
     (push)
     (apply.gloc.of list->vector "./boot/macro/expand.scm" . 323600))
   (ret.iloc 0 . 0))
 (set.gloc.of |rewrite-form`2|)
 (close
   (2 0 . rewrite-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 344073)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 344073)
     (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 344073)
     (if.false.ret)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 344073)
     (ret.subr.gloc.of list? "./boot/macro/expand.scm" . 344073))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 344073)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 344073)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 344073))
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 344073))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 344073))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 344073))
         (ret.cons "./boot/macro/expand.scm" . 344073))
       (call
         (push.gloc.of car)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 344073))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 344073))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (touch.gloc.of |rewrite-form`2|)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 344073))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/expand.scm" . 344073))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 344073))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 344073))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 344073)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 344073))
 (set.gloc.of |rewrite-letrec-syntax`2|)
 (close
   (2 0 . rewrite-form-each)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 308266)
       (push.iloc 2 . 1)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 308252))
     (push)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 309282)
       (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 309276))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/expand.scm" . 310309)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 310328)
       (ret.eq? "./boot/macro/expand.scm" . 310320))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 312344))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 305161))
 (set.gloc.of |rewrite-form-each`2|)
 (close
   (2 0 . rewrite-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 328713)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 328713)
     (ret.subr.gloc.of |.list?| "./boot/macro/expand.scm" . 328713))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 328713)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 328713)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 328713))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 328713))
     (push)
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 328713))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 328713))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/expand.scm" . 328713))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 328713))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of list)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 328713))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/expand.scm" . 328713))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of cons)
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/expand.scm" . 328713))
       (push)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 328713))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 328713))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 328713)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 328713))
 (set.gloc.of |rewrite-let-syntax`2|)
 (close
   (2 0 . expand-initial-forms)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 356391)
     (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 356382))
   (if.true
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 357416)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 357400))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (gloc.of denote-let-syntax)
     (if.eq?
       (touch.gloc.of |rewrite-let-syntax`2|)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of |rewrite-let-syntax`2| "./boot/macro/expand.scm" . 359445))
     (push.iloc.0 . 0)
     (gloc.of denote-letrec-syntax)
     (if.eq?
       (touch.gloc.of |rewrite-letrec-syntax`2|)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of |rewrite-letrec-syntax`2| "./boot/macro/expand.scm" . 361493))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 362517))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 363570))
       (push.close
         (2 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 364580))
         (push)
         (ret.subr.gloc.of values "./boot/macro/expand.scm" . 364567))
       (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 357388))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 366613))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of values "./boot/macro/expand.scm" . 368652))
 (set.gloc.of expand-initial-forms)
 (ret.const.unspec))
((close
   (3 0 . expand-body)
   (extend.unbound . 6)
   (push.const)
   (push.const)
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 379935)
       (push.iloc 2 . 2)
       (apply.gloc.of extend-env "./boot/macro/expand.scm" . 379923))
     (set.iloc 2 . 2)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 380942))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/expand.scm" . 383009))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 1)
         (call
           (touch.gloc.of generate-local-macro-symbol)
           (push.iloc.0 . 0)
           (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 384057))
         (push.cons)
         (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 384038)
         (push.iloc 2 . 2)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 384026))
       (set.iloc 2 . 2)
       (ret.const.unspec))
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 385065)
       (push.iloc 3 . 2)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 385055))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 385033))
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 390165)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/expand.scm" . 391191)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 392234)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 392218))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 393236))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/expand.scm" . 397332))
   (push.close
     (3 0 . rewrite-body)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of annotate)
       (call
         (touch.gloc.of expand-each)
         (push.iloc.0 . 0)
         (push.iloc 2 . 2)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 403482))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of annotate "./boot/macro/expand.scm" . 403472))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 405541))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 405524))
       (if.true.ret)
       (call
         (touch.gloc.of find-duplicates)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 406575))
         (push)
         (apply.gloc.of find-duplicates "./boot/macro/expand.scm" . 406558))
       (push)
       (extend . 1)
       (push.const . define)
       (push.const . "duplicate definitions")
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 409649)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 409666))
       (push)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 410682)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 410673)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 410700))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 407574))
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 411705)
         (push.iloc.1 . 2)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 411699)
         (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 411694))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 411675))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 412731)
         (push.iloc 3 . 2)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 412718))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 412699))
     (push)
     (extend . 2)
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/expand.scm" . 413721))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 415812)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 415820)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 415831))
         (push.iloc 2 . 2)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 415784))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 416800))
       (push.const . define)
       (push.const . "attempt to reference unbound variable ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 418866)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 420957)
             (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 420967)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 420927))
           (if.false.ret)
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 421951))
         (push.iloc 3 . 1)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 419890))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 417824))
     (call
       (touch.gloc.of check-internal-def-contract-violation)
       (call
         (push.gloc.of car)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 424000))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of check-internal-def-contract-violation "./boot/macro/expand.scm" . 423961))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 426014))
       (push.const . define)
       (push.const
         .
         "identifier ~u already used to determine the meaning of undeferred portions of definition")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 428080)
       (call
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 429111)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 429141))
         (ret.const . #f))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 413714))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 433216))
       (push)
       (push.iloc 5 . 2)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/expand.scm" . 433190))
     (push)
     (call
       (touch.gloc.of expand-each)
       (push.iloc 3 . 0)
       (push.iloc 5 . 2)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 433242))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/expand.scm" . 432153)
     (push.subr.gloc.of |.list| 1 "./boot/macro/expand.scm" . 432153)
     (push.iloc 5 . 1)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 432153))
   (enclose . 6)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 436243))
   (push)
   (extend . 1)
   (extend.enclose
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (car.iloc (0 . 0) "./boot/macro/expand.scm" . 439324)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 439345)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 439336))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 440360)
       (push.iloc 3 . 2)
       (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 440354)
       (set.iloc 3 . 2)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 4 . 2)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 441388)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 441372))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 443423))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 443417))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 445465)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/expand.scm" . 445465)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/expand.scm" . 445465)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/expand.scm" . 445465)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 445465)
           (ret.subr.gloc.of |.list?| "./boot/macro/expand.scm" . 445465))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/expand.scm" . 445465)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 445465))
         (if.true
           (push.cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 445465)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/expand.scm" . 445465)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/expand.scm" . 445465)
           (extend . 3)
           (call
             (push.close
               (0 0)
               (touch.gloc.of compile-macro)
               (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 445465)
               (push.iloc.1 . 1)
               (push.iloc 8 . 2)
               (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 445465))
             (push.close
               (1 1)
               (call
                 (iloc.0 . 1)
                 (if.not.pair?.ret.const . #f)
                 (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 445465)
                 (push.iloc 7 . 1)
                 (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 445465)
                 (set.iloc 7 . 1)
                 (ret.const.unspec))
               (call
                 (touch.gloc.of macro-variable?)
                 (push.iloc.0 . 0)
                 (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 445465))
               (if.true
                 (push.iloc.1 . 2)
                 (push.iloc.0 . 0)
                 (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 445465))
               (push.iloc.1 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.0 . 0)
                 (push.iloc 8 . 2)
                 (apply.gloc.of make-macro "./boot/macro/expand.scm" . 445465))
               (push)
               (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 445465))
             (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 445465))
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (call
             (touch.gloc.of acons)
             (push.iloc.0 . 2)
             (push.const . #f)
             (push.iloc 3 . 2)
             (apply.gloc.of acons "./boot/macro/expand.scm" . 445465))
           (push)
           (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 445465))
         (iloc.0 . 0)
         (if.true
           (push.iloc 2 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 445465)
           (push.const . "expected symbol for first clause")
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 445465)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 445465))
         (push.iloc 2 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 445465)
         (push.const . "expected symbol and transformer expression")
         (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 445465)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 445465))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 460867)
             (apply.gloc.of desugar-define "./boot/macro/expand.scm" . 460851))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 460846)
           (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 460880)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 460836))
         (push)
         (extend . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 461862)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 461889)
           (push.iloc 4 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 461878))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 2)
           (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 462884)
           (if.true
             (call
               (touch.gloc.of current-macro-expression)
               (push.iloc 7 . 0)
               (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 464937))
             (push.const . define)
             (push.const
               .
               "identifier ~u already used to determine the meaning of undeferred portions of definition")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 466992)
             (push.car.iloc (3 . 0) "./boot/macro/expand.scm" . 468016)
             (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 465961))
           (ret.const.unspec))
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (6 . 3) "./boot/macro/expand.scm" . 469021))
         (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 470051)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 2)
           (apply.gloc.of acons "./boot/macro/expand.scm" . 470078))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 470045))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/expand.scm" . 471069))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/expand.scm" . 473117))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 474184)
           (push.iloc 6 . 2)
           (apply.gloc.of expand-initial-forms "./boot/macro/expand.scm" . 474162))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 6 . 2)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 476219)
             (push.iloc 6 . 2)
             (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 476204))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 478250)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 478244))
           (call (push.iloc.0 . 0) (apply.iloc (6 . 4) "./boot/macro/expand.scm" . 479268))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 480316)
             (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 480298)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 480292))
           (push.iloc.0 . 0)
           (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 482372)
           (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 482354)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 482384)
           (push.iloc 3 . 2)
           (apply.iloc (6 . 5) "./boot/macro/expand.scm" . 482340))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 441360))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 484396)
       (push.iloc.1 . 2)
       (apply.iloc (4 . 5) "./boot/macro/expand.scm" . 484377))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 486435)
     (push.iloc.0 . 2)
     (apply.iloc (3 . 5) "./boot/macro/expand.scm" . 486416))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 437272))
   (push)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/expand.scm" . 437255))
 (set.gloc.of expand-body)
 (ret.const.unspec))
((close
   (2 0 . expand-each)
   (call
     (touch.gloc.of current-macro-expression)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 490513))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (call
     (push.close
       (1 0)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc.1 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 492568))
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 493592))
     (push.iloc.1 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 491537))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 491527))
 (set.gloc.of expand-each)
 (ret.const.unspec))
((close
   (2 0 . expand-form)
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 500760))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.symbol? (ret.iloc 0 . 0))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 502805))
     (if.true
       (push.close
         (0 0)
         (call
           (touch.gloc.of expansion-trace-level)
           (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 504874))
         (push)
         (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 504898))
         (push)
         (subr.gloc.of < 2 "./boot/macro/expand.scm" . 504871)
         (if.true
           (push.const . #f)
           (push.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 505939))
           (push)
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 505966))
           (push.cons)
           (push.const . 1)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 506962))
           (push)
           (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 506957)
           (extend . 4)
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 507945))
             (set.iloc 1 . 0)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 507945))
             (set.iloc 1 . 1)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 2)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 507945))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 3)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 507945))
           (push.close
             (0 0)
             (touch.gloc.of expand-macro-use)
             (push.iloc 4 . 0)
             (push.iloc 4 . 1)
             (push.iloc 3 . 0)
             (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 507945))
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 0)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 507945))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 1)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 507945))
           (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 507945))
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 508967))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 509993))
         (push)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 509975))
       (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 500748))
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/expand.scm" . 510997))
     (if.true
       (push.const . #f)
       (push.const . "attempt to reference unbound variable ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 513063)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 514087))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 512021))
     (call
       (touch.gloc.of out-of-context?)
       (push.iloc.0 . 0)
       (apply.gloc.of out-of-context? "./boot/macro/expand.scm" . 515093))
     (if.true
       (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 516121)
       (if.true
         (push.const . #f)
         (push.const . "identifer ~u out of context")
         (push.iloc.1 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 518187)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 519211))
         (push)
         (call
           (touch.gloc.of annotate)
           (push.const . syntax)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 520259)
           (push.subr.gloc.of list 2 "./boot/macro/expand.scm" . 520245)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 520271)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 520235))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 517145))
       (push.const . #f)
       (push.const . "identifer ~u out of context")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 522283)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 523307))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 521241))
     (call
       (touch.gloc.of special?)
       (push.iloc.0 . 0)
       (apply.gloc.of special? "./boot/macro/expand.scm" . 524309))
     (if.true
       (push.const . #f)
       (push.const . "misplaced syntactic keyword ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 525354)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 525401))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 525333))
     (call
       (touch.gloc.of pattern-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of pattern-variable? "./boot/macro/expand.scm" . 526357))
     (if.true
       (push.const . #f)
       (push.const . "misplaced pattern variable ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 527402)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 527448))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 527381))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 529420)
   (if.true
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.const . #f)
       (push.const . "invalid expression")
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 530462))
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.0 . 0)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 531468))
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 532508)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.0 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 533551)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 533535))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/expand.scm" . 534556))
       (if.true
         (call
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 535588))
           (if.true.ret)
           (push.gloc.of denote-begin)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-import)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-macro)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-let-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-letrec-syntax)
           (iloc.0 . 0)
           (ret.eq? "./boot/macro/expand.scm" . 542756))
         (if.true
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 543777)
           (apply))
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 545826))
           (set.iloc 1 . 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.const . #t)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 545826))
         (push.close
           (0 0)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 545827)
           (apply))
         (push.close
           (0 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.iloc.1 . 0)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 545826))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 545826))
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 0)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 546844))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-macro-use)
           (push.iloc 2 . 0)
           (push.iloc 2 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 547897))
         (push.close
           (2 0)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 548901))
           (push)
           (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 548925))
           (push)
           (subr.gloc.of < 2 "./boot/macro/expand.scm" . 548898)
           (if.true
             (push.const . #f)
             (push.const . #f)
             (push.iloc 2 . 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 549971))
             (push.cons)
             (push.const . 1)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 550989))
             (push)
             (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 550984)
             (extend . 4)
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 551972))
               (set.iloc 1 . 0)
               (call
                 (touch.gloc.of expansion-trace-level)
                 (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 551972))
               (set.iloc 1 . 1)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 2)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 551972))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 3)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 551972))
             (push.close
               (0 0)
               (touch.gloc.of expand-form)
               (push.iloc 2 . 0)
               (call
                 (touch.gloc.of extend-env)
                 (push.iloc 2 . 1)
                 (push.iloc 4 . 1)
                 (apply.gloc.of extend-env "./boot/macro/expand.scm" . 551990))
               (push)
               (apply.gloc.of expand-form "./boot/macro/expand.scm" . 551972))
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 0)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 551972))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 1)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 551972))
             (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 551972))
           (touch.gloc.of expand-form)
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of extend-env)
             (push.iloc.0 . 1)
             (push.iloc 2 . 1)
             (apply.gloc.of extend-env "./boot/macro/expand.scm" . 553012))
           (push)
           (apply.gloc.of expand-form "./boot/macro/expand.scm" . 552994))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 533523))
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 555040))
       (if.true
         (touch.gloc.of expand-each)
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 556064))
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 558114))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 558114))
       (push.close
         (0 0)
         (touch.gloc.of expand-each)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 558114))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 558114))
       (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 558114))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 561173))
       (set.iloc 1 . 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #t)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 561173))
     (push.close
       (0 0)
       (touch.gloc.of expand-each)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 561173))
     (push.close
       (0 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 0)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 561173))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 561173))
   (iloc.0 . 0)
   (if.pair?
     (push.const . #f)
     (push.const . "expression is not a proper list")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 563212))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/expand.scm" . 564240)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/expand.scm" . 564256)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/expand.scm" . 564271)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/expand.scm" . 564284)
     (if.true.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of bytevector? "./boot/macro/expand.scm" . 564299))
   (if.true (ret.iloc 0 . 0))
   (push.const . #f)
   (push.const . "invalid expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 566284))
 (set.gloc.of expand-form)
 (ret.const.unspec))
((close
   (1 1 . macro-expand)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (extend . 8)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-macro-expression)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 2)
     (call
       (touch.gloc.of current-expansion-mode)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 3)
     (call
       (touch.gloc.of current-top-level-exterior)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 4)
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 5)
     (call
       (touch.gloc.of expansion-trace-level)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 6)
     (call
       (touch.gloc.of expansion-trace-stack)
       (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 578567))
     (set.iloc 1 . 7)
     (call
       (touch.gloc.of current-temporary-count)
       (push.const . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-rename-count)
       (push.const . 0)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-macro-expression)
       (push.const . #f)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.const . #f)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #f)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.const . 0)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 578567))
     (touch.gloc.of expansion-trace-stack)
     (push.const)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 578567))
   (push.close
     (0 0)
     (call
       (call
         (touch.gloc.of denote-begin?)
         (push.const)
         (push.const . begin)
         (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 578583))
       (if.true
         (touch.gloc.of flatten-top-level-begin)
         (push.const . begin)
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 579607)
         (push.gloc.of private-primitives-environment)
         (apply.gloc.of flatten-top-level-begin "./boot/macro/expand.scm" . 579607))
       (ret.iloc 2 . 0))
     (push)
     (extend . 1)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 581652)
     (if.null? (ret.const.unspec))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.gloc.of private-primitives-environment)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 583725))
     (push)
     (push.gloc.of annotate)
     (push.gloc.of annotate-closure)
     (call (apply.gloc.of current-after-expansion-hook "./boot/macro/expand.scm" . 583694))
     (apply))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (push.iloc.1 . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-rename-count)
       (push.iloc.1 . 1)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.1 . 2)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc.1 . 3)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 4)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 5)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 578567))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.iloc.1 . 6)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 578567))
     (touch.gloc.of expansion-trace-stack)
     (push.iloc.1 . 7)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 578567))
   (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 577556))
 (set.gloc.of macro-expand)
 (ret.const.unspec))

;
((close
   (2 0 . expand-lambda)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 7183))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/base.scm" . 7180)
   (if.true
     (call
       (touch.gloc.of collect-lambda-formals)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 8240)
       (push.iloc.0 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/base.scm" . 8216))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 9245))
     (push)
     (extend . 1)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/base.scm" . 10303))
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/base.scm" . 10285))
       (push)
       (apply.gloc.of map "./boot/macro/base.scm" . 10270))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 3 . 0)
       (push.cddr.iloc (3 . 0) "./boot/macro/base.scm" . 11309)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of extend-env "./boot/macro/base.scm" . 11321))
       (push)
       (apply.gloc.of expand-body "./boot/macro/base.scm" . 11291))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.const . lambda)
       (push.const . "empty body")
       (push.iloc 4 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 13332))
     (touch.gloc.of annotate)
     (push.const . lambda)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cadr.iloc (4 . 0) "./boot/macro/base.scm" . 14399)
       (push.iloc.1 . 0)
       (apply.gloc.of rename-lambda-formals "./boot/macro/base.scm" . 14376))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/base.scm" . 14356)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 14356))
   (push.const . lambda)
   (push.const . "expected formals and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 16396))
 (set.gloc.of expand-lambda)
 (ret.const.unspec))
((close
   (2 0 . expand-quote)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 20492))
   (push)
   (push.const . 2)
   (subr.gloc.of = 2 "./boot/macro/base.scm" . 20489)
   (if.true
     (touch.gloc.of annotate)
     (push.const . quote)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 21553)
       (apply.gloc.of strip-rename-suffix "./boot/macro/base.scm" . 21532))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/base.scm" . 21513)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 21513))
   (push.const . quote)
   (push.const . "expected single datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 22537))
 (set.gloc.of expand-quote)
 (ret.const.unspec))
((close
   (2 0 . expand-begin)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 26634))
     (if.false.ret)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 27669)
     (if.pair?.ret.const . #t)
     (push.const . begin)
     (push.const . "misplaced empty begin")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 28686))
   (touch.gloc.of annotate)
   (push.const . begin)
   (call
     (touch.gloc.of flatten-begin)
     (call
       (touch.gloc.of expand-each)
       (push.cdr.iloc (0 . 0) "./boot/macro/base.scm" . 29749)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/base.scm" . 29736))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of flatten-begin "./boot/macro/base.scm" . 29721))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 29701))
 (set.gloc.of expand-begin)
 (ret.const.unspec))
((close
   (2 0 . expand-if)
   (touch.gloc.of annotate)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (ret.pair? "./boot/macro/base.scm" . 33797))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 33797)
       (extend . 1)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/base.scm" . 33797))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddddr| 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cadddr| 1 "./boot/macro/base.scm" . 33797)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 33797)
       (extend . 2)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 1)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/base.scm" . 33797))
     (push.const . if)
     (push.const . "expected 2 or 3 expressions")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 33797))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 32771))
 (set.gloc.of expand-if)
 (ret.const.unspec))
((close
   (2 0 . expand-set!)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 48133)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 48133))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 48133)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (extend . 2)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/base.scm" . 48133))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 3 . 1)
           (apply.gloc.of extend-env "./boot/macro/base.scm" . 48133))
         (push)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
       (apply.gloc.of |.call-with-values| "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/base.scm" . 48133))
       (if.true.ret)
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.const . set!)
       (push.const . "misplaced syntactic keyword as variable")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (push.gloc.of immutable-primitives)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (call
         (touch.gloc.of renamed-id?)
         (push.iloc.0 . 0)
         (apply.gloc.of renamed-id? "./boot/macro/base.scm" . 48133))
       (if.true.ret.const . #f)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 4 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
         (apply.gloc.of denote-lambda? "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 0)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 48133))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 48133))
     (touch.gloc.of annotate)
     (push.const . set!)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 3 "./boot/macro/base.scm" . 48133)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 48133))
   (push.const . set!)
   (push.const . "expected variable and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
 (set.gloc.of expand-set!)
 (ret.const.unspec))
((close
   (2 0 . expand-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (ret.subr.gloc.of |.list?| "./boot/macro/base.scm" . 74757))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 74757)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 74757))
     (touch.gloc.of expand-form)
     (push.const . |.BEGIN|)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/base.scm" . 74757))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 74757))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
 (set.gloc.of expand-let-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (ret.subr.gloc.of |.list?| "./boot/macro/base.scm" . 87045))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 87045)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 87045))
     (touch.gloc.of expand-form)
     (push.const . |.BEGIN|)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/base.scm" . 87045))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 87045))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
 (set.gloc.of expand-letrec-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-define-syntax)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99338))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 100380)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 100362))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 99333)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 99333))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 99333)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/base.scm" . 99333)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 99333)
       (push.const . "expression is not a proper list")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 99333))
     (call
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 4 . 0)
           (push.iloc 3 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-macro "./boot/macro/base.scm" . 99333))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 99333))
           (if.true
             (push.const . variable)
             (push.iloc 3 . 1)
             (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
             (push.iloc 4 . 1)
             (apply.gloc.of |.set-top-level-macro!| "./boot/macro/base.scm" . 99333))
           (push.const . syntax)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |.set-top-level-macro!| "./boot/macro/base.scm" . 99333))
         (apply.gloc.of |.call-with-values| "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (apply.gloc.of |.dynamic-wind| "./boot/macro/base.scm" . 99333))
     (call
       (touch.gloc.of env-delete!)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-delete! "./boot/macro/base.scm" . 99333))
     (ret.const begin))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
   (push.const . "expected symbol and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 99333))
 (set.gloc.of expand-define-syntax)
 (ret.const.unspec))
((close
   (1 0 . immutable?)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 121869)
   (if.true.ret)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (ret.subr.gloc.of memq "./boot/macro/base.scm" . 122893))
 (set.gloc.of |immutable?`2|)
 (close
   (2 0 . expand-define)
   (extend.enclose+
     (1 0 . let?)
     (touch.gloc.of denote-let?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-let? "./boot/macro/base.scm" . 133129))
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135178))
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 136220)
     (push.const . "misplaced definition")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 136202))
   (call
     (touch.gloc.of desugar-define)
     (push.iloc.1 . 0)
     (apply.gloc.of desugar-define "./boot/macro/base.scm" . 137242))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 137242)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 137242)
   (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
   (extend . 2)
   (call
     (call
       (touch.gloc.of |immutable?`2|)
       (push.iloc.0 . 1)
       (apply.gloc.of |immutable?`2| "./boot/macro/base.scm" . 137242))
     (if.false.ret)
     (push.car.iloc (3 . 0) "./boot/macro/base.scm" . 137242)
     (push.const . "attempt to modify immutable binding")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 137242))
   (call
     (push.const . #f)
     (push.const . #f)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 137242))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 137242))
       (set.iloc 1 . 1)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 137242))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc 2 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 137242))
     (push.close
       (0 0)
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 137242))
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 137242))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 137242))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/base.scm" . 137242))
   (push)
   (extend . 1)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 137242)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 137242)
       (apply.iloc+ (3 . 0) "./boot/macro/base.scm" . 137242))
     (if.true
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 137242)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 1)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 137242))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 137242))
     (touch.gloc.of set-closure-comment!)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of original-id)
       (push.iloc.1 . 1)
       (apply.gloc.of original-id "./boot/macro/base.scm" . 137242))
     (push)
     (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 137242))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/base.scm" . 137242)
   (call
     (touch.gloc.of env-delete!)
     (push.iloc 4 . 1)
     (push.iloc.1 . 1)
     (apply.gloc.of env-delete! "./boot/macro/base.scm" . 137242))
   (touch.gloc.of annotate)
   (push.const . define)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 3 "./boot/macro/base.scm" . 137242)
   (push.iloc 4 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 137242))
 (set.gloc.of expand-define)
 (ret.const.unspec))

;
((close
   (2 0 . expand-let)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.pair? "./boot/macro/derived.scm" . 7173))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 7173)
     (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 7173)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 7173)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 7173)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 3)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 1)
       (push.const . |.LETREC*|)
       (push.iloc.0 . 2)
       (push.const . |.LAMBDA|)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 7173)
       (push.iloc.0 . 2)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push.cons)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 7173)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 7173))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 4 . 0)
       (push.cddr.iloc (4 . 0) "./boot/macro/derived.scm" . 7173)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of cons)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
         (push)
         (push.iloc 4 . 1)
         (apply.gloc.of extend-env "./boot/macro/derived.scm" . 7173))
       (push)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 5 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (call
       (push.close
         (2 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (call
           (touch.gloc.of denote-lambda?)
           (push.iloc 6 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
           (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 7173))
         (if.false.ret)
         (touch.gloc.of set-closure-comment!)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of original-id)
           (push.iloc.0 . 1)
           (apply.gloc.of original-id "./boot/macro/derived.scm" . 7173))
         (push)
         (apply.gloc.of set-closure-comment! "./boot/macro/derived.scm" . 7173))
       (push.iloc 2 . 1)
       (push.iloc 2 . 0)
       (apply.gloc.of for-each "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.1 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
 (set.gloc.of expand-let)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec*)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.pair? "./boot/macro/derived.scm" . 44037))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 44037))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 44037))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 44037))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 44037))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 44037))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 44037)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
             (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 44037)
             (push.iloc.0 . 0)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 44037))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (push.iloc.1 . 0)
         (apply.gloc.of any1 "./boot/macro/derived.scm" . 44037))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc 2 . 0)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 44037))
     (push)
     (push.iloc.1 . 1)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 7 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
 (set.gloc.of expand-letrec*)
 (ret.const.unspec))
((close
   (2 0 . expand-let*)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 74764))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 74761)
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 75801)
     (extend . 1)
     (call
       (touch.gloc.of check-let*-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let*-bindings "./boot/macro/derived.scm" . 76811))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . |.LET|)
             (push.const)
             (push.cddr.iloc (3 . 0) "./boot/macro/derived.scm" . 81951)
             (ret.subr.gloc.of |.cons*| "./boot/macro/derived.scm" . 80911))
           (push.const . |.LET|)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 82972)
           (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 80911)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 82990)
             (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 82984))
           (push)
           (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 80911))
         (push.iloc.1 . 0)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 79885))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 75785))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 75785))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 86043)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 86025))
 (set.gloc.of expand-let*)
 (ret.const.unspec))
((close
   (2 0)
   (push.const . set!)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn2.1`2|)
 (close (1 0) (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . |.&UNDEF|)
   (ret.subr.gloc.of list "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn4.1`4|)
 (close
   (2 0 . expand-letrec)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.pair? "./boot/macro/derived.scm" . 90117))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.const)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
     (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LETREC*|)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caaadr| 1 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 90117)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 90117))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 90117))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 90117)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 90117)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
     (call
       (touch.gloc.of check-rec-contract-violation)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 90117)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 90117)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
             (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 90117)
             (push.iloc.0 . 0)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 90117))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (push.iloc.1 . 0)
         (apply.gloc.of any1 "./boot/macro/derived.scm" . 90117))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
     (call
       (touch.gloc.of every1)
       (push.close
         (1 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (touch.gloc.of denote-lambda?)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
         (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 90117))
       (push.iloc.1 . 0)
       (apply.gloc.of every1 "./boot/macro/derived.scm" . 90117))
     (if.true
       (touch.gloc.of annotate)
       (push.const . letrec*)
       (call
         (touch.gloc.of rewrite-letrec*-bindings)
         (call
           (push.gloc.of list)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 90117))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc 7 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc 5 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (push.const . let)
     (call
       (push.gloc.of |.fn4.1`4|)
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (push.gloc.of |.fn2.1`2|)
       (push.iloc 4 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc 2 . 1)
     (push.subr.gloc.of |.append| 2 "./boot/macro/derived.scm" . 90117)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 90117))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
 (set.gloc.of expand-letrec)
 (ret.const.unspec))
((close
   (2 0 . expand-let-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 124933))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 124933)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "expected bindings and body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of append)
           (call
             (push.close
               (1 0)
               (call
                 (iloc.0 . 0)
                 (if.not.pair?.ret.const . #f)
                 (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (if.not.pair?.ret.const . #f)
                 (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (ret.null? "./boot/macro/derived.scm" . 124933))
               (if.true
                 (touch.gloc.of collect-lambda-formals)
                 (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (push.iloc 2 . 0)
                 (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 124933))
               (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 124933)
               (push.const . "expected each binding consist of formals and expression")
               (push.iloc 2 . 0)
               (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
             (push.iloc.0 . 1)
             (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
           (push)
           (apply.gloc.of apply "./boot/macro/derived.scm" . 124933))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/derived.scm" . 124933))
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "duplicate formals")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (touch.gloc.of annotate)
     (call
       (extend.enclose
         (2 0 . loop)
         (iloc.0 . 0)
         (if.null?
           (touch.gloc.of expand-form)
           (push.const . |.LET|)
           (push.const)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 124933)
           (push.iloc.0 . 1)
           (apply.gloc.of expand-form "./boot/macro/derived.scm" . 124933))
         (call
           (car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 124933)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 124933)
           (ret.null? "./boot/macro/derived.scm" . 124933))
         (if.true
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 124933)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 124933)
           (extend . 2)
           (call
             (touch.gloc.of collect-lambda-formals)
             (push.iloc.0 . 1)
             (push.iloc 4 . 0)
             (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of fresh-rename-count)
             (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (call
             (push.gloc.of cons)
             (push.iloc.1 . 0)
             (call
               (push.close
                 (1 0)
                 (touch.gloc.of rename-id)
                 (push.iloc.0 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of rename-id "./boot/macro/derived.scm" . 124933))
               (push.iloc.1 . 0)
               (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
             (push)
             (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (push.const . |.call-with-values|)
           (push.const . lambda)
           (push.const)
           (call
             (touch.gloc.of expand-form)
             (push.iloc 3 . 0)
             (push.iloc 7 . 1)
             (apply.gloc.of expand-form "./boot/macro/derived.scm" . 124933))
           (push)
           (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 124933)
           (push.const . lambda)
           (call
             (touch.gloc.of rename-lambda-formals)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of rename-lambda-formals "./boot/macro/derived.scm" . 124933))
           (push)
           (call
             (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 124933)
             (call
               (touch.gloc.of extend-env)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of extend-env "./boot/macro/derived.scm" . 124933))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/derived.scm" . 124933))
           (push)
           (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 124933)
           (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 124933))
         (push.const . "internal error: let-values: ~m")
         (push.iloc 3 . 0)
         (apply.gloc.of scheme-error "./boot/macro/derived.scm" . 124933))
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 124933))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 124933))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
 (set.gloc.of expand-let-values)
 (ret.const.unspec))
((close
   (2 0 . expand-do)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 166917)
     (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 166917)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 166917))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (extend . 4)
     (call
       (push.iloc.0 . 3)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 166917)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
       (push.const . "malformed (variable init update)")
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 166917))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
           (ret.pair? "./boot/macro/derived.scm" . 166917))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
           (ret.null? "./boot/macro/derived.scm" . 166917))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.car| "./boot/macro/derived.scm" . 166917))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
           (ret.null? "./boot/macro/derived.scm" . 166917))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.caddr| "./boot/macro/derived.scm" . 166917))
         (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 166917)
         (push.const . "malformed (variable init update)")
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
       (push.iloc.0 . 3)
       (apply.gloc.of map "./boot/macro/derived.scm" . 166917))
     (push)
     (extend . 2)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 0)
       (call
         (push.close
           (1 0)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 166917))
           (if.true
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (ret.subr.gloc.of list "./boot/macro/derived.scm" . 166917))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 166917)
           (push.const . "malformed (variable init update)")
           (push.iloc 3 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
         (push.iloc.1 . 3)
         (apply.gloc.of map "./boot/macro/derived.scm" . 166917))
       (push)
       (push.const . |.IF|)
       (push.iloc.1 . 2)
       (call
         (iloc.1 . 1)
         (if.null? (ret.const |.UNSPECIFIED|))
         (push.const . |.BEGIN|)
         (iloc.1 . 1)
         (ret.cons "./boot/macro/derived.scm" . 166917))
       (push)
       (push.const . |.BEGIN|)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 166917)
       (subr.gloc.of |.append| 2 "./boot/macro/derived.scm" . 166917)
       (push.cons)
       (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 166917)
       (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 166917)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 166917))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 166917))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
   (push.const . "expected (variable init update), test, and command")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
 (set.gloc.of expand-do)
 (ret.const.unspec))
((close
   (2 0 . expand-let*-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 199685))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 199685)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 199685)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 199685)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . |.LET|)
             (push.const)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.cons*| "./boot/macro/derived.scm" . 199685))
           (call
             (car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 199685)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 199685)
             (ret.null? "./boot/macro/derived.scm" . 199685))
           (if.true
             (push.const . |.CALL-WITH-VALUES|)
             (push.const . |.LAMBDA|)
             (push.const)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 199685)
             (push.const . |.LAMBDA|)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 199685)
             (call
               (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
               (apply.iloc (1 . 0) "./boot/macro/derived.scm" . 199685))
             (push)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 199685)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 199685))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 199685)
           (push.const . "expected each binding consist of formals and expression")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
         (push.iloc.1 . 1)
         (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 199685))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 199685))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 199685))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
 (set.gloc.of expand-let*-values)
 (ret.const.unspec))
((close
   (2 0 . expand-cond)
   (extend.unbound . 3)
   (push.close+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 228384))
   (push.close+
     (1 0 . =>?)
     (touch.gloc.of denote-=>?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-=>? "./boot/macro/derived.scm" . 229406))
   (push.close+
     (1 0 . lambda?)
     (touch.gloc.of denote-lambda?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 230434))
   (enclose . 3)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.1 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 232463))
   (push)
   (push.const . 1)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 232460)
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?.ret.const |.UNSPECIFIED|)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 238626)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.pair? "./boot/macro/derived.scm" . 239638))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (call
               (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 239638))
             (if.false.ret)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.pair? "./boot/macro/derived.scm" . 239638))
           (if.true
             (cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
             (if.null?
               (push.const . |.BEGIN|)
               (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (ret.cons "./boot/macro/derived.scm" . 239638))
             (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 239638)
             (push.const . "misplaced else")
             (push.iloc 5 . 0)
             (push.iloc.1 . 0)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 239638)
             (if.false.ret)
             (call
               (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 239638))
             (if.false.ret)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 239638)
             (apply.iloc+ (4 . 2) "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 239638)
             (extend . 1)
             (push.const . |.LET|)
             (push.iloc.0 . 0)
             (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 239638)
             (push.const . |.IF|)
             (push.iloc.0 . 0)
             (push.const . |.LET|)
             (push.const)
             (push.iloc 2 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (extend . 2)
             (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 239638))
             (push)
             (extend . 1)
             (push.const . |.LET|)
             (push.iloc.0 . 0)
             (push.iloc.1 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 239638)
             (push.const . |.IF|)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (5 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.null? "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.const . |.OR|)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.const . |.IF|)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (push.const . |.BEGIN|)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (push.cons)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 239638)
           (push.const . "malformed cond clause")
           (push.iloc 5 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 239638))
         (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 235550)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 235534))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 228357))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 228357))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 267294)
   (push.const . "expected cond clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 267276))
 (set.gloc.of expand-cond)
 (ret.const.unspec))
((close
   (2 0 . maplist)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call (push.iloc.0 . 1) (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 277531))
   (push)
   (call
     (touch.gloc.of |maplist`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/macro/derived.scm" . 277556)
     (apply.gloc.of |maplist`2| "./boot/macro/derived.scm" . 277542))
   (ret.cons "./boot/macro/derived.scm" . 277525))
 (set.gloc.of |maplist`2|)
 (close
   (2 0 . expand-case)
   (extend.enclose+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 272416))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (ret.pair? "./boot/macro/derived.scm" . 298040))
   (if.true
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (extend . 2)
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 298040))
     (push)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 298040)
       (push.const . |.COND|)
       (call
         (touch.gloc.of |maplist`2|)
         (push.close
           (1 0)
           (push.gloc.of pair?)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (car.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
             (ret.pair? "./boot/macro/derived.scm" . 298040))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 298040)
             (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 298040))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (call
               (push.iloc 3 . 0)
               (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
               (apply.iloc+ (6 . 0) "./boot/macro/derived.scm" . 298040))
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (if.null?
               (push.const . |.ELSE|)
               (push.iloc 3 . 0)
               (subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 298040)
             (push.const . "misplaced else")
             (push.iloc 7 . 0)
             (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (if.not.pair?.ret.const . #f)
             (push.iloc 3 . 0)
             (subr.gloc.of |.cdaar| 1 "./boot/macro/derived.scm" . 298040)
             (if.not.null?.ret.const . #f)
             (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 298040)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caaar| 1 "./boot/macro/derived.scm" . 298040)
             (extend . 2)
             (call
               (iloc.0 . 1)
               (if.symbol?.ret.const . #t)
               (push.iloc.0 . 1)
               (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (iloc.0 . 1)
               (ret.null? "./boot/macro/derived.scm" . 298040))
             (if.true
               (push.const . |.EQ?|)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
               (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.const . |.EQV?|)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 298040))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 298040)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (extend . 2)
             (iloc.0 . 1)
             (if.null?.ret.const #f)
             (call
               (touch.gloc.of every1)
               (push.close
                 (1 0)
                 (iloc.0 . 0)
                 (if.symbol?.ret.const . #t)
                 (push.iloc.0 . 0)
                 (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (iloc.1 . 1)
                 (ret.null? "./boot/macro/derived.scm" . 298040))
               (push.iloc.0 . 1)
               (apply.gloc.of every1 "./boot/macro/derived.scm" . 298040))
             (if.true
               (push.const . |.MEMQ|)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
               (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.const . |.MEMV|)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 298040))
           (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 298040)
           (push.const . "malformed case clause")
           (push.iloc 7 . 0)
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
         (push.iloc.1 . 0)
         (apply.gloc.of |maplist`2| "./boot/macro/derived.scm" . 298040))
       (push.cons)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
       (push.iloc 3 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 298040))
     (push)
     (push.iloc 3 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 298040))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
   (push.const . "expected case clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
 (set.gloc.of expand-case)
 (ret.const.unspec))
((close
   (2 0 . expand-and)
   (touch.gloc.of annotate)
   (push.const . and)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 312356)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 312343))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 312325))
 (set.gloc.of expand-and)
 (ret.const.unspec))
((close
   (2 0 . expand-or)
   (touch.gloc.of annotate)
   (push.const . or)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 316451)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 316438))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 316421))
 (set.gloc.of expand-or)
 (ret.const.unspec))
((close
   (1 0 . desugar-define)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true
     (touch.gloc.of annotate)
     (push.const . define)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const (|.UNSPECIFIED|))
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (extend . 2)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 337933))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 1)
     (push.const . lambda)
     (push.iloc.0 . 0)
     (push.const (|.UNSPECIFIED|))
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 337933))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.iloc 2 . 0)
   (push.subr.gloc.of length 1 "./boot/macro/derived.scm" . 337933)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/derived.scm" . 337933)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "expected 1 or 2, but no clause given")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.iloc.0 . 0)
   (push.const 1 2)
   (subr.gloc.of |.memq| 2 "./boot/macro/derived.scm" . 337933)
   (if.true
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "expected symbol for first clause")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
   (push.const . "expected 1 or 2, but ~a clauses given")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 337933)
   (push.iloc 3 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
 (set.gloc.of desugar-define)
 (ret.const.unspec))
((close
   (1 0 . desugar-define-macro)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 344069)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 344069))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 344069)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 344069))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 344069))
     (touch.gloc.of annotate)
     (push.const . define-macro)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 344069)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 344069)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 344069))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 344069))
   (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
   (push.const . "expected symbol and expression")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 344069))
 (set.gloc.of desugar-define-macro)
 (ret.const.unspec))
((close
   (1 0 . rewrite-define-macro)
   (call
     (touch.gloc.of desugar-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of desugar-define-macro "./boot/macro/derived.scm" . 357402))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 357402)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 357402)
   (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (extend . 2)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 357402))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (push.const . |.DEFINE-SYNTAX|)
   (push.iloc.1 . 1)
   (push.const . |.LAMBDA|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 357402)
   (push.const . |.APPLY|)
   (push.iloc.1 . 0)
   (push.const . |.CDR|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.iloc 3 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 357402))
 (set.gloc.of rewrite-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-define-macro)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/derived.scm" . 364554))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 365596)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 365578))
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of rewrite-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of rewrite-define-macro "./boot/macro/derived.scm" . 366610))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 366597))
 (set.gloc.of expand-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-identifier-syntax)
   (extend.enclose+
     (1 0 . set!?)
     (touch.gloc.of denote-set!?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-set!? "./boot/macro/derived.scm" . 371744))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 371717)
     (ret.pair? "./boot/macro/derived.scm" . 371717))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
     (ret.null? "./boot/macro/derived.scm" . 371717))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LAMBDA|)
       (push.const x)
       (push.const . |.SYNTAX-CASE|)
       (push.const . x)
       (push.const)
       (push.const . id)
       (push.const |.IDENTIFIER?| (|.SYNTAX| id))
       (push.const . |.SYNTAX|)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
       (push.const _ x ...)
       (push.const . |.SYNTAX|)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
       (const x ...)
       (push.cons)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 5 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 371717))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 371717))
   (iloc.0 . 0)
   (if.false.ret)
   (cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cddadr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (call
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 371717)
     (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 371717))
   (if.false.ret)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.cadadr| 1 "./boot/macro/derived.scm" . 371717)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 371717)
   (extend . 2)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (push.const . |.MAKE-VARIABLE-TRANSFORMER|)
     (push.const . |.LAMBDA|)
     (push.const x)
     (push.const . |.SYNTAX-CASE|)
     (push.const . x)
     (push.const set!)
     (push.const . set!)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 371717)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.const . |.SYNTAX|)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc.0 . 1)
     (const x ...)
     (push.cons)
     (push.const . |.SYNTAX|)
     (push.iloc.0 . 0)
     (const x ...)
     (push.cons)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc.0 . 1)
     (push.const |.IDENTIFIER?| (|.SYNTAX| id))
     (push.const . |.SYNTAX|)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 6 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 371717))
   (push)
   (push.iloc 3 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 371717))
 (set.gloc.of expand-identifier-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-assert)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (ret.null? "./boot/macro/derived.scm" . 398341))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.OR|)
       (push.iloc.0 . 0)
       (push.const . assertion-violation)
       (push.const . quote)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/derived.scm" . 398341))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 398341)
       (push.const . "assertion failed in expression ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 398341)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 398341)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 398341)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 398341))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 398341))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
   (push.const . "expected single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 398341))
 (set.gloc.of expand-assert)
 (ret.const.unspec))

;
((close
   (2 0 . expand-quasiquote)
   (extend.unbound . 12)
   (push.close+
     (1 0 . unquote?)
     (touch.gloc.of denote-unquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 8228))
   (push.close+
     (1 0 . quasiquote?)
     (touch.gloc.of denote-quasiquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 9255))
   (push.close+
     (1 0 . unquote-splicing?)
     (touch.gloc.of denote-unquote-splicing?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 10285))
   (push.close+
     (1 0 . quoted?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 15381)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/quasi.scm" . 16405)
     (if.not.null?.ret.const . #f)
     (touch.gloc.of denote-quote?)
     (push.iloc 2 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 17441)
     (apply.gloc.of denote-quote? "./boot/macro/quasi.scm" . 17422))
   (push.close+
     (1 0 . constant?)
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/quasi.scm" . 21517)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/quasi.scm" . 22541)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/quasi.scm" . 23565)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/quasi.scm" . 24589)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of bytevector? 1 "./boot/macro/quasi.scm" . 25613)
     (if.true.ret)
     (push.iloc.0 . 0)
     (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 26637))
   (push.close+
     (1 0 . constant-value)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 30736))
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cadr "./boot/macro/quasi.scm" . 30748))
     (ret.iloc 0 . 0))
   (push.close+
     (1 0 . null-constant?)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 35854))
     (if.false.ret)
     (cadr.iloc (0 . 0) "./boot/macro/quasi.scm" . 36885)
     (ret.null? "./boot/macro/quasi.scm" . 36878))
   (push.close+
     (2 0 . emit-append)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 42000))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 43031)
       (push.const . 1)
       (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 43028)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/macro/quasi.scm" . 43048))
       (push.const . |.APPEND|)
       (iloc.0 . 0)
       (ret.cons "./boot/macro/quasi.scm" . 43024))
     (push.const . |.APPEND|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of |.list| 1 "./boot/macro/quasi.scm" . 44047)
     (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 44047)
     (ret.cons "./boot/macro/quasi.scm" . 44047))
   (push.close+
     (2 0 . emit-cons*)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 49168)
     (push.const . 1)
     (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 49165)
     (if.true
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 50200)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 9) "./boot/macro/quasi.scm" . 50189))
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 52244))
     (if.true (push.const . |.LIST|) (iloc.0 . 0) (ret.cons "./boot/macro/quasi.scm" . 52243))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 54315)
       (const . |.LIST|)
       (ret.eq? "./boot/macro/quasi.scm" . 54310))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 55333)
       (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 54291)
       (ret.cons "./boot/macro/quasi.scm" . 54291))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56367)
       (const . |.CONS|)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56391)
       (const . |.CONS*|)
       (ret.eq? "./boot/macro/quasi.scm" . 56386))
     (if.true
       (push.const . |.CONS*|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 57382)
       (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 56339)
       (ret.cons "./boot/macro/quasi.scm" . 56339))
     (push.const . |.CONS*|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of |.list| 1 "./boot/macro/quasi.scm" . 58387)
     (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 58387)
     (ret.cons "./boot/macro/quasi.scm" . 58387))
   (push.close+
     (2 0 . emit-cons)
     (call
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63506))
       (if.false.ret)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63523))
     (if.true
       (push.const . |.QUOTE|)
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64545))
       (push)
       (call (push.iloc.0 . 1) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64567))
       (push.cons)
       (ret.subr.gloc.of list "./boot/macro/quasi.scm" . 64525))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 65556))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 65555))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 67627)
       (const . |.LIST|)
       (ret.eq? "./boot/macro/quasi.scm" . 67622))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 68644)
       (ret.subr.gloc.of |.cons*| "./boot/macro/quasi.scm" . 67603))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69679)
       (const . |.CONS|)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69703)
       (const . |.CONS*|)
       (ret.eq? "./boot/macro/quasi.scm" . 69698))
     (if.true
       (push.const . |.CONS*|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 70693)
       (ret.subr.gloc.of |.cons*| "./boot/macro/quasi.scm" . 69651))
     (push.const . |.CONS|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 71699))
   (push.close
     (2 0 . expand-vector)
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/quasi.scm" . 76828)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 11) "./boot/macro/quasi.scm" . 76820))
     (push)
     (extend . 1)
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 6) "./boot/macro/quasi.scm" . 77842))
     (if.true.ret.const |.QUOTE| #())
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 4) "./boot/macro/quasi.scm" . 79890))
     (if.true
       (push.const . |.QUOTE|)
       (call
         (call (push.iloc.0 . 0) (apply.iloc+ (2 . 5) "./boot/macro/quasi.scm" . 80938))
         (push)
         (apply.gloc.of list->vector "./boot/macro/quasi.scm" . 80924))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 79889))
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 81943)
     (const . |.LIST|)
     (if.eq?
       (push.const . |.VECTOR|)
       (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 82974)
       (ret.cons "./boot/macro/quasi.scm" . 81937))
     (push.const . |.LIST->VECTOR|)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 83985))
   (push.close
     (2 0 . expand)
     (iloc.0 . 0)
     (if.pair?
       (=n.iloc (0 . 1) 0 "./boot/macro/quasi.scm" . 90132)
       (if.true
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (ret.subr.gloc.of |.list?| "./boot/macro/quasi.scm" . 90128))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 8) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 7) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (subr.gloc.of |.list?| 1 "./boot/macro/quasi.scm" . 90128)
           (if.false.ret)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (call
             (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.null?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.cadr| "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "nested quasiquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote-splicing appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 108575)
       (extend . 1)
       (call
         (call
           (touch.gloc.of denote-unquote?)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 109601))
         (if.true.ret)
         (touch.gloc.of denote-unquote-splicing?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 109627))
       (if.true
         (push.const . |.QUOTE|)
         (push.iloc.0 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/quasi.scm" . 110621)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 111664)
           (push.n+.iloc (1 . 1) -1 "./boot/macro/quasi.scm" . 111675)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 111656))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 110621))
       (call
         (touch.gloc.of denote-quasiquote?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 112669))
       (if.true
         (push.const . |.QUOTE|)
         (push.iloc.0 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/quasi.scm" . 113693)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 114736)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/quasi.scm" . 114747)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 114728))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 113693))
       (call
         (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 116784)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 116776))
       (push)
       (call
         (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 117808)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 117800))
       (push)
       (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 116765))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/quasi.scm" . 118800)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 10) "./boot/macro/quasi.scm" . 119824))
     (iloc.0 . 0)
     (if.symbol?
       (push.const . |.QUOTE|)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 120847))
     (iloc.0 . 0)
     (if.null?.ret.const |.QUOTE| ())
     (ret.iloc 0 . 0))
   (enclose . 12)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (call
       (push.cadr.iloc (1 . 0) "./boot/macro/quasi.scm" . 127012)
       (push.const . 0)
       (apply.iloc (0 . 11) "./boot/macro/quasi.scm" . 127004))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/quasi.scm" . 126994))
   (push)
   (push.iloc.1 . 1)
   (apply.gloc.of expand-form "./boot/macro/quasi.scm" . 126981))
 (set.gloc.of expand-quasiquote)
 (ret.const.unspec))

;
((close
   (1 0 . ellipsis-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 8209)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 9231)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 9226))
 (set.gloc.of ellipsis-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-splicing-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 14353)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 15375)
   (const . ...)
   (if.not.eq?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 16401)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/macro/synpat.scm" . 17423)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 17418))
 (set.gloc.of ellipsis-splicing-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-quote?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 22545)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 23567)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 23562))
 (set.gloc.of ellipsis-quote?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 29716)
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 30746)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 30740))
     (push)
     (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 29710))
   (push.iloc.0 . 0)
   (const . ...)
   (if.eq? (ret.iloc 0 . 1))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 33810)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/synpat.scm" . 33829))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 34830)
   (if.true
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 35860)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 35854))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . collect-unique-ids)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 27653))
 (set.gloc.of collect-unique-ids)
 (ret.const.unspec))
((close
   (4 0 . collect-vars-ranks)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 3))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 43024)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of acons)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of acons "./boot/macro/synpat.scm" . 45072))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 0)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 46092))
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 47136)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 48173)
       (if.symbol?
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 49195)
         (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 49205)
         (push.iloc.0 . 3)
         (apply.gloc.of acons "./boot/macro/synpat.scm" . 49188))
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 50232)
       (push.iloc.0 . 1)
       (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 50248)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 50212))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 47116))
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of collect-vars-ranks)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 52256)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 53300)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 53280))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 52236))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 54284)
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 55328)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 55308))
   (ret.iloc 0 . 3))
 (set.gloc.of collect-vars-ranks)
 (ret.const.unspec))
((close
   (2 0 . check-misplaced-ellipsis)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq?
       (push.const . "syntax pattern")
       (push.const . "improper use of ellipsis")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 83986))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 85010))
     (if.true
       (call
         (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 86048)
         (if.not.symbol?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 87069)
         (push.iloc 2 . 1)
         (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 87063)
         (if.false.ret)
         (push.const . "syntax pattern")
         (push.const . "ellipsis following literal")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 88087))
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 91170)
         (const . ...)
         (if.eq?
           (push.const . "syntax pattern")
           (push.const . "ambiguous use of ellipsis")
           (push.iloc 4 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 92189))
         (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 93219)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 93213))
       (push.cddr.iloc (1 . 0) "./boot/macro/synpat.scm" . 89122)
       (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 89106))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 95260)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95254))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 95277)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95271))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 96274)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 97304)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 97298))
     (ret.const . #f))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 81929))
 (set.gloc.of |check-misplaced-ellipsis`2|)
 (close
   (2 0 . check-duplicate-variable)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 65560)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 66590)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 66584))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 65554))
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq? (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (const . _)
     (if.eq? (ret.iloc 0 . 1))
     (iloc.0 . 0)
     (if.symbol?
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 70678)
       (if.true (ret.iloc 0 . 1))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 72730)
       (if.true
         (push.const . "syntax pattern")
         (push.const . "duplicate pattern variables")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 73754))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/synpat.scm" . 74778))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 75794)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 76824)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 76818))
     (ret.iloc 0 . 1))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 63497))
 (set.gloc.of |check-duplicate-variable`2|)
 (close
   (2 0 . check-pattern)
   (call
     (touch.gloc.of |check-misplaced-ellipsis`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |check-misplaced-ellipsis`2| "./boot/macro/synpat.scm" . 100357))
   (touch.gloc.of |check-duplicate-variable`2|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of |check-duplicate-variable`2| "./boot/macro/synpat.scm" . 101381))
 (set.gloc.of check-pattern)
 (ret.const.unspec))
((close
   (3 0 . match-ellipsis?)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 107550)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 107561)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 107534))
   (if.false.ret)
   (touch.gloc.of match-ellipsis?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 108575)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 108558))
 (set.gloc.of match-ellipsis?)
 (ret.const.unspec))
((close
   (4 0 . match-ellipsis-n?)
   (=n.iloc (0 . 2) 0 "./boot/macro/synpat.scm" . 112649)
   (if.true.ret)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 114718)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 114729)
     (push.iloc.0 . 3)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 114702))
   (if.false.ret)
   (touch.gloc.of match-ellipsis-n?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 115745)
   (push.iloc.0 . 1)
   (push.n+.iloc (0 . 2) -1 "./boot/macro/synpat.scm" . 115760)
   (push.iloc.0 . 3)
   (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 115726))
 (set.gloc.of match-ellipsis-n?)
 (ret.const.unspec))
((close
   (3 0 . match-pattern?)
   (push.iloc.0 . 1)
   (const . _)
   (if.eq?.ret.const . #t)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 121875)
     (if.true
       (call
         (iloc.0 . 0)
         (if.symbol?.ret.const . #t)
         (push.iloc.0 . 0)
         (apply.gloc.of identifier? "./boot/macro/synpat.scm" . 123932))
       (if.false.ret)
       (touch.gloc.of free-id=?)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of free-id=? "./boot/macro/synpat.scm" . 124952))
     (ret.const . #t))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 126988))
   (if.true
     (call
       (iloc.0 . 0)
       (if.pair?.ret.const . #t)
       (iloc.0 . 0)
       (ret.null? "./boot/macro/synpat.scm" . 128034))
     (if.false.ret)
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 129057)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 129069))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 130082)
       (if.symbol?.ret.const . #t)
       (touch.gloc.of match-ellipsis?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 131102))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 132129))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 132159)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 132147))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 132126)
     (extend . 1)
     (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 133147)
     (if.true
       (touch.gloc.of match-pattern?)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 134192)
       (push.iloc.1 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 134171))
     (>n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 135200)
     (if.false.ret)
     (call
       (touch.gloc.of match-ellipsis-n?)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 136224))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 137264)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 137283)
     (push.iloc.1 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 137248))
   (iloc.0 . 1)
   (if.pair?
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of match-pattern?)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 140321)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 140332)
       (push.iloc.0 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 140305))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 141345)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 141356)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 141329))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 142348)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 143377)
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 144417)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 144437)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 144401))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of equal? "./boot/macro/synpat.scm" . 145425))
 (set.gloc.of match-pattern?)
 (ret.const.unspec))
((close
   (2 0 . union-vars)
   (iloc.0 . 1)
   (if.null? (ret.iloc 0 . 0))
   (touch.gloc.of union-vars)
   (call
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 151584)
     (push.iloc.0 . 1)
     (push.subr.gloc.of cdar 1 "./boot/macro/synpat.scm" . 151606)
     (push.subr.gloc.of reverse 1 "./boot/macro/synpat.scm" . 151597)
     (push.iloc.0 . 0)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 151573))
   (push)
   (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 152597)
   (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 151561))
 (set.gloc.of union-vars)
 (ret.const.unspec))
((close
   (3 0 . bind-var!)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 2))
   (push.iloc.0 . 0)
   (push.iloc.0 . 2)
   (push.subr.gloc.of assq 2 "./boot/macro/synpat.scm" . 158744)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 160819)
     (push.cons)
     (subr.gloc.of set-cdr! 2 "./boot/macro/synpat.scm" . 160793)
     (ret.iloc 1 . 2))
   (touch.gloc.of acons)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of list 1 "./boot/macro/synpat.scm" . 161821)
   (push.iloc.1 . 2)
   (apply.gloc.of acons "./boot/macro/synpat.scm" . 161810))
 (set.gloc.of bind-var!)
 (ret.const.unspec))
((close
   (3 0 . bind-null-ellipsis)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 168977)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 170011)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 170005)
       (if.true (ret.iloc 0 . 1))
       (touch.gloc.of bind-var!)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 172064)
       (push.const)
       (push.iloc.0 . 1)
       (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 172053))
     (push)
     (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 168971))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.car.iloc (1 . 0) "./boot/macro/synpat.scm" . 165929)
     (apply.gloc.of collect-unique-ids "./boot/macro/synpat.scm" . 165909))
   (push)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 165893))
 (set.gloc.of bind-null-ellipsis)
 (ret.const.unspec))
((close
   (5 0 . bind-ellipsis)
   (iloc.0 . 0)
   (if.null?
     (iloc.0 . 4)
     (if.null?
       (touch.gloc.of bind-null-ellipsis)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-null-ellipsis "./boot/macro/synpat.scm" . 178189))
     (touch.gloc.of union-vars)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 179213))
   (touch.gloc.of bind-ellipsis)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 180248)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 181286)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 181297)
     (push.iloc.0 . 2)
     (push.iloc.0 . 4)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 181272))
   (push)
   (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 180233))
 (set.gloc.of bind-ellipsis)
 (ret.const.unspec))
((close
   (6 0 . bind-ellipsis-n)
   (=n.iloc (0 . 3) 0 "./boot/macro/synpat.scm" . 185353)
   (if.true
     (touch.gloc.of union-vars)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 186377))
   (touch.gloc.of bind-ellipsis-n)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 187418)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.n+.iloc (0 . 3) -1 "./boot/macro/synpat.scm" . 187439)
   (push.iloc.0 . 4)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 188456)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 188467)
     (push.iloc.0 . 2)
     (push.iloc.0 . 5)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 188442))
   (push)
   (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 187401))
 (set.gloc.of bind-ellipsis-n)
 (ret.const.unspec))
((close
   (4 0 . bind-pattern)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 193552)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 195600))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 196620))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 197660)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 197672))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 198685)
       (if.symbol?
         (touch.gloc.of bind-var!)
         (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 199711)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 199700))
       (touch.gloc.of bind-ellipsis)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 200724))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 201756))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 201786)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 201774))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 201753)
     (extend . 1)
     (touch.gloc.of bind-pattern)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 202784)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 202803)
     (push.iloc.1 . 2)
     (call
       (call
         (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 203817)
         (if.false.ret)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 203834)
         (ret.subr.gloc.of symbol? "./boot/macro/synpat.scm" . 203825))
       (if.true
         (touch.gloc.of bind-var!)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 204847)
         (push.const)
         (push.iloc.1 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 204836))
       (touch.gloc.of bind-ellipsis-n)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 205860))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 202770))
   (iloc.0 . 1)
   (if.pair?
     (touch.gloc.of bind-pattern)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 207898)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 207909)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of bind-pattern)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 208936)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 208947)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 208922))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 207884))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 209932)
   (if.true
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 210970)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 210990)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 210956))
   (ret.iloc 0 . 3))
 (set.gloc.of bind-pattern)
 (ret.const.unspec))

;
((close
   (2 0 . collect-rename-ids)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 11287)
     (push.iloc 2 . 1)
     (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 11281)
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 12311)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 12305))
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13335)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13351)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 13345))
     (ret.cons "./boot/macro/syntmp.scm" . 13329))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.1 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 7184))
   (push)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 8199))
 (set.gloc.of collect-rename-ids)
 (ret.const.unspec))
((close
   (1 0 . parse-ellipsis-splicing)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 18469)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 18464))
     (if.true
       (push.n+.iloc (0 . 0) 1 "./boot/macro/syntmp.scm" . 19476)
       (push.cdr.iloc (0 . 1) "./boot/macro/syntmp.scm" . 19486)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 19470))
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-head 2 "./boot/macro/syntmp.scm" . 21526)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 21518))
   (push.const . 2)
   (push.iloc.1 . 0)
   (push.subr.gloc.of cdddr 1 "./boot/macro/syntmp.scm" . 17438)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 17413))
 (set.gloc.of parse-ellipsis-splicing)
 (ret.const.unspec))
((close
   (2 0 . check-template)
   (extend.unbound . 2)
   (push.close
     (2 0 . control-patvar-exists?)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 30742))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 30738))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 31762))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 32816))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 33827)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 33816))
           (if.true.ret)
           (call
             (push.iloc.0 . 0)
             (push.const . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 34845))
           (if.false.ret)
           (push.iloc.0 . 1)
           (push.iloc.1 . 1)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 35869))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 28681))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 36882))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 37916)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 37926)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 37910))
         (if.true.ret)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 38945)
           (push.const . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 38939))
         (if.false.ret)
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 39969)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 39963))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 40978))
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of rank-of)
               (push.iloc.0 . 0)
               (push.iloc 5 . 1)
               (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 42029))
             (push)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 42025))
           (call
             (touch.gloc.of collect-unique-ids)
             (push.iloc.0 . 0)
             (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 42056))
           (push)
           (apply.gloc.of any1 "./boot/macro/syntmp.scm" . 42006))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 43036)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 43030))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 45084)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 45078))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 46108)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 46102))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 47122)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 48152)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 48146))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 28681))
   (push.close
     (2 0 . check-escaped)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 55324))
         (push)
         (push.iloc 2 . 1)
         (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 55319)
         (if.false.ret)
         (push.const . "syntax template")
         (push.const . "too few ellipsis following subtemplate")
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 56343))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 58392)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 58386))
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 59416)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 59410))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 60434)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 61464)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 61458))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 53257))
   (enclose . 2)
   (call
     (call
       (touch.gloc.of safe-length)
       (push.iloc.1 . 0)
       (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 63505))
     (push)
     (push.const . 2)
     (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 63502)
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 63532)
     (const . ...)
     (ret.eq? "./boot/macro/syntmp.scm" . 63527))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 64536)
     (push.const . 0)
     (apply.iloc (0 . 1) "./boot/macro/syntmp.scm" . 64521))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (call
         (push.iloc.0 . 0)
         (const . ...)
         (if.not.eq?.ret.const . #f)
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 68631))
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 69658))
       (>.iloc (0 . 1) "./boot/macro/syntmp.scm" . 69655)
       (if.false.ret)
       (push.const . "syntax template")
       (push.const . "too few ellipsis following subtemplate")
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 70679))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 71698))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 72752))
       (push.close
         (3 0)
         (call
           (=n.iloc (1 . 1) 0 "./boot/macro/syntmp.scm" . 73753)
           (if.false.ret)
           (call
             (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 74805)
             (push.iloc.0 . 2)
             (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 74781))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 4 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 75805))
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 76831)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 76820))
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 77844))
       (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 65545))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 78866))
     (if.true
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 79906)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 80942)
           (push.iloc 3 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 80933))
         (push)
         (extend . 1)
         (<n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 81954)
         (if.true
           (push.const . "syntax template")
           (push.const . "misplace ellipsis following literal")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 83057)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 82978))
         (n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 84010)
         (<.iloc (0 . 0) "./boot/macro/syntmp.scm" . 84002)
         (if.true
           (push.const . "syntax template")
           (push.const . "too few ellipsis following subtemplate")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 85108)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 85026))
         (push.cddr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 87080)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 87074))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 88096)
       (if.pair?
         (call
           (=n.iloc (0 . 1) 0 "./boot/macro/syntmp.scm" . 89118)
           (if.false.ret)
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 90170)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 90180)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 90146))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 91276)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 91170))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 92191)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 92201)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 92185))
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 93215)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 93209))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 94240)
       (if.null?
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis following empty list")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 95257))
       (push.const . "syntax template")
       (push.const . "misplaced ellipsis following literal")
       (push.iloc 3 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 97385)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 97305))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 98322))
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 99361)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 99346))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 100376)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 100370))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 102424)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 102418))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 103448)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 103442))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 104466)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 105496)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 105490))
     (ret.const.unspec))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 65545))
 (set.gloc.of check-template)
 (ret.const.unspec))
((close
   (2 0 . rank-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 109585)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 110608))
   (ret.const . -1))
 (set.gloc.of rank-of)
 (ret.const.unspec))
((close
   (2 0 . subform-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 114698)
   (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 114693))
 (set.gloc.of subform-of)
 (ret.const.unspec))
((close
   (4 0 . collect-ellipsis-vars)
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 118800))
   (push)
   (extend . 1)
   (touch.gloc.of filter)
   (push.gloc.of values)
   (call
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 121889)
       (push.iloc.1 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syntmp.scm" . 121883)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 122930)
       (push.iloc 2 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 122924)
       (subr.gloc.of cdr 1 "./boot/macro/syntmp.scm" . 122919)
       (<.iloc (2 . 2) "./boot/macro/syntmp.scm" . 123940)
       (if.true (ret.iloc 0 . 0))
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124975)
       (cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124986)
       (ret.cons "./boot/macro/syntmp.scm" . 124969))
     (push.iloc.1 . 3)
     (apply.gloc.of map "./boot/macro/syntmp.scm" . 118789))
   (push)
   (apply.gloc.of filter "./boot/macro/syntmp.scm" . 118789))
 (set.gloc.of collect-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . consume-ellipsis-vars)
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 139299)
         (push.iloc 3 . 0)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 139290))
       (<.iloc (3 . 1) "./boot/macro/syntmp.scm" . 139287)
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140317)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140333)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 140327))
         (ret.cons "./boot/macro/syntmp.scm" . 140311))
       (push.iloc.0 . 0)
       (subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 141342)
       (if.null?
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 142365)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 142359))
       (push.iloc.0 . 0)
       (subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 143390)
       (if.null?
         (const . #t)
         (set.iloc 2 . 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 145437)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 145431))
       (call
         (call
           (touch.gloc.of circular-list?)
           (push.iloc.0 . 0)
           (push.subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 147499)
           (apply.gloc.of circular-list? "./boot/macro/syntmp.scm" . 147483))
         (if.true.ret)
         (const . #t)
         (set.iloc 2 . 1)
         (ret.const.unspec))
       (touch.gloc.of acons)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 148510)
       (push.iloc.0 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 148521)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 148539)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 148533))
       (push)
       (apply.gloc.of acons "./boot/macro/syntmp.scm" . 148503))
     (push.iloc 2 . 2)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 137230))
   (push)
   (extend . 1)
   (iloc.1 . 1)
   (if.true (iloc.1 . 0) (if.true.ret.const . #f) (ret.iloc 0 . 0))
   (iloc.1 . 0)
   (if.true.ret)
   (ret.const))
 (set.gloc.of consume-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . contain-rank-moved-var?)
   (extend.enclose+
     (2 0 . traverse-escaped)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 160791))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 160786))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 162844)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 162838))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 163868)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 163862))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 164882)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 165912)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 165906))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 158729))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (push.const . 0)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 171027))
       (push)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 171022))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 172046))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 173100))
       (push.close
         (3 0)
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 174111)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 174100))
         (if.true.ret)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 175124))
       (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 168965))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 176142))
     (if.true
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 177176)
         (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 177186)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 177170))
       (if.true.ret)
       (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 178200)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 178194))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 179214))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 180256)
       (push.iloc.0 . 1)
       (apply.iloc+ (2 . 0) "./boot/macro/syntmp.scm" . 180238))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 182296)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 182290))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 183320)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 183314))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 184334)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 185364)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 185358))
     (ret.const . #f))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 168965))
 (set.gloc.of contain-rank-moved-var?)
 (ret.const.unspec))
((close
   (3 0 . rewrite-template-ranks-vars)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (extend.unbound . 2)
   (push.close
     (2 0 . revealed)
     (push.const . 0)
     (call
       (touch.gloc.of rank-of)
       (push.iloc.0 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 202776))
     (push)
     (push.iloc.0 . 1)
     (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 202771)
     (if.true
       (push.const . "~a:~a")
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syntmp.scm" . 203842))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 3 "./boot/macro/syntmp.scm" . 203826)
       (push.subr.gloc.of string->symbol 1 "./boot/macro/syntmp.scm" . 203810)
       (extend . 1)
       (call
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syntmp.scm" . 204825)
         (if.true.ret)
         (extend.enclose+
           (2 0 . loop)
           (>n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 206882)
           (if.true
             (push.n+.iloc (0 . 0) -1 "./boot/macro/syntmp.scm" . 207912)
             (call
               (touch.gloc.of |make-infinite-list`6|)
               (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 207946)
               (apply.gloc.of |make-infinite-list`6| "./boot/macro/syntmp.scm" . 207926))
             (push)
             (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 207920)
             (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 207906))
           (push.iloc 5 . 0)
           (push.iloc 2 . 0)
           (push.iloc 3 . 1)
           (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syntmp.scm" . 209954)
           (push.iloc 5 . 1)
           (push.iloc 2 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syntmp.scm" . 210978))
         (push.iloc 2 . 1)
         (call
           (touch.gloc.of rank-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 205872))
         (push)
         (push.subr.gloc.of - 2 "./boot/macro/syntmp.scm" . 205863)
         (call
           (touch.gloc.of subform-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of subform-of "./boot/macro/syntmp.scm" . 205900))
         (push)
         (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 205849))
       (ret.iloc 0 . 0))
     (ret.iloc 0 . 0))
   (push.close
     (2 0 . traverse-escaped)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 219160))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 221220)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 221214))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 222244)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 222238))
         (ret.cons "./boot/macro/syntmp.scm" . 221208))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 223256)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 224300)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 224294))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 224280))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 217103))
   (enclose . 2)
   (call
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 230427))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 231451))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 232505))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 233520)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233509))
           (push)
           (push.const . ...)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233544))
           (push.cons)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 233501))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 228370))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 234523))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 235559)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 235569)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 235553))
         (push)
         (push.const . ...)
         (call
           (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 236594)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 236588))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/syntmp.scm" . 236577)
         (ret.cons "./boot/macro/syntmp.scm" . 235547))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 237595))
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 238625)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 239667)
           (push.iloc.0 . 1)
           (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 239649))
         (ret.cons "./boot/macro/syntmp.scm" . 238619))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 241703)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 241697))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 242727)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 242721))
         (ret.cons "./boot/macro/syntmp.scm" . 241691))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 243739)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 244783)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 244777))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 244763))
       (ret.iloc 0 . 0))
     (push.iloc 3 . 0)
     (push.const . 0)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 228370))
   (push)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 247843)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 247829)
   (push.iloc 2 . 2)
   (push.iloc.1 . 1)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 248866)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 248853)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 195595))
 (set.gloc.of |rewrite-template-ranks-vars`2|)
 (close
   (1 0 . make-infinite-list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 197658)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of set-cdr! 2 "./boot/macro/syntmp.scm" . 198680)
   (ret.iloc 0 . 0))
 (set.gloc.of |make-infinite-list`6|)
 (close
   (3 0 . adapt-to-rank-moved-vars)
   (call
     (touch.gloc.of contain-rank-moved-var?)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of contain-rank-moved-var? "./boot/macro/syntmp.scm" . 250889))
   (if.true
     (touch.gloc.of |rewrite-template-ranks-vars`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of |rewrite-template-ranks-vars`2| "./boot/macro/syntmp.scm" . 251913))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 252937))
 (set.gloc.of adapt-to-rank-moved-vars)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 266268)
   (push.iloc.0 . 1)
   (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 266262)
   (if.true
     (touch.gloc.of |loop`13|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 267292)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 267286))
   (touch.gloc.of |loop`13|)
   (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269340)
   (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269356)
   (iloc.0 . 1)
   (push.cons)
   (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 269334))
 (set.gloc.of |loop`13|)
 (close
   (1 0 . remove-duplicates)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 262172)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 262183)
       (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 262166)
       (if.true.ret.const . #f)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 263201)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 263195))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 260109))
   (if.true.ret)
   (touch.gloc.of |loop`13|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 264205))
 (set.gloc.of |remove-duplicates`2|)
 (close
   (5 0 . transcribe-template)
   (push.close
     (0 0)
     (touch.gloc.of adapt-to-rank-moved-vars)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (call
       (touch.gloc.of |remove-duplicates`2|)
       (push.iloc.1 . 2)
       (apply.gloc.of |remove-duplicates`2| "./boot/macro/syntmp.scm" . 271440))
     (push)
     (apply.gloc.of adapt-to-rank-moved-vars "./boot/macro/syntmp.scm" . 271397))
   (push.close
     (3 0)
     (extend.unbound . 5)
     (push.close+
       (2 0 . expand-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 275474)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 277541)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 278569)
           (apply.iloc (4 . 4) "./boot/macro/syntmp.scm" . 278563))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 279587))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 281618)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 281618))
     (push.close+
       (2 0 . expand-ellipsis-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 286738)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 288805)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.iloc 4 . 4)
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 289837)
           (apply.gloc.of map "./boot/macro/syntmp.scm" . 289827))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 290851))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 292882)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 292882))
     (push.close
       (3 0 . expand-ellipsis-template)
       (extend.enclose+
         (2 0 . loop)
         (iloc.0 . 1)
         (if.pair?
           (call
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.iloc (3 . 4) "./boot/macro/syntmp.scm" . 300064))
           (push)
           (iloc.0 . 0)
           (push.cons)
           (call
             (touch.gloc.of consume-ellipsis-vars)
             (push.iloc 4 . 1)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.gloc.of consume-ellipsis-vars "./boot/macro/syntmp.scm" . 301082))
           (push)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 300052))
         (iloc.0 . 1)
         (if.null?.ret.const)
         (push.iloc.0 . 1)
         (const . #t)
         (if.eq? (push.iloc.0 . 0) (ret.subr.gloc.of reverse "./boot/macro/syntmp.scm" . 303141))
         (push.const . "syntax template")
         (push.const . "subforms have different size of matched input")
         (push.const . template:)
         (push.iloc 5 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 305172)
         (push.const . subforms:)
         (iloc 5 . 2)
         (push.cons)
         (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 305172))
       (push.const)
       (call
         (touch.gloc.of collect-ellipsis-vars)
         (push.iloc.1 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.gloc.of collect-ellipsis-vars "./boot/macro/syntmp.scm" . 298026))
       (push)
       (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 297995))
     (push.close+
       (3 0 . expand-escaped-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 311321))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 311318)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 312349)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 312342))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 313366))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 315441)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 315416))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 316465)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 316440))
         (ret.cons "./boot/macro/syntmp.scm" . 315410))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 317458)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 318521)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 318496))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 318482))
       (ret.iloc 0 . 0))
     (push.close
       (3 0 . expand-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 324633))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 324630)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 325661)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 325654))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 326678))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 327698))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 328752))
         (push.close
           (3 0)
           (call
             (push.gloc.of append)
             (call
               (push.iloc.0 . 0)
               (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 329801)
               (push.iloc.1 . 2)
               (apply.iloc (2 . 2) "./boot/macro/syntmp.scm" . 329770))
             (push)
             (apply.gloc.of apply "./boot/macro/syntmp.scm" . 329756))
           (push)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (push.iloc.1 . 2)
             (apply.iloc (2 . 4) "./boot/macro/syntmp.scm" . 330780))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 329748))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 322569))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 331794))
       (if.true
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 332834)
         (if.symbol?
           (call
             (touch.gloc.of rank-of)
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 333870)
             (push.iloc 2 . 1)
             (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 333861))
           (push)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 334890)
           (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 334882)
           (if.true
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 335935)
               (push.iloc.0 . 2)
               (apply.iloc+ (1 . 1) "./boot/macro/syntmp.scm" . 335914))
             (push)
             (call
               (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 336955)
               (push.iloc.0 . 1)
               (push.iloc.0 . 2)
               (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 336938))
             (push)
             (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 335906))
           (ret.const.unspec))
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 337952)
         (if.pair?
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 339003)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 339014)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 2) "./boot/macro/syntmp.scm" . 338977))
           (push)
           (call
             (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 340018)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 340001))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 338969))
         (ret.const.unspec))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 341010))
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 342065)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 342040))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 343081)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 343064))
         (ret.cons "./boot/macro/syntmp.scm" . 342034))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 345129)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 345112))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 346153)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 346136))
         (ret.cons "./boot/macro/syntmp.scm" . 345106))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 347154)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 348209)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 348192))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 348178))
       (ret.iloc 0 . 0))
     (enclose . 5)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.1 . 0)
         (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 351251))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 351248)
       (if.false.ret)
       (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 351278)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 351273))
     (if.true
       (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 352292)
       (push.const . 0)
       (push.iloc.1 . 2)
       (apply.iloc+ (0 . 3) "./boot/macro/syntmp.scm" . 352267))
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.1 . 2)
     (apply.iloc (0 . 4) "./boot/macro/syntmp.scm" . 353291))
   (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 264205))
 (set.gloc.of transcribe-template)
 (ret.const.unspec))

;
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 30773)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 30782)
   (ret.subr.gloc.of |.list| "./boot/macro/synrule.scm" . 30758))
 (set.gloc.of |.fn4.1`4|)
 (close
   (2 0 . transcribe-compiled-templete)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 10265)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 11289)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/synrule.scm" . 13332))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/synrule.scm" . 14359))
   (push)
   (extend . 4)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 21536)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
           (push.iloc 2 . 3)
           (apply.gloc.of rename-id "./boot/macro/synrule.scm" . 21556))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/synrule.scm" . 21546))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synrule.scm" . 21530))
     (push.iloc 2 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/synrule.scm" . 12313)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 17426))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (apply.gloc.of transcribe-template "./boot/macro/synrule.scm" . 23573))
   (push)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 25634)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 25660)
         (apply.gloc.of env-lookup "./boot/macro/synrule.scm" . 25644))
       (ret.cons "./boot/macro/synrule.scm" . 25628))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 24597))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 23565))
 (set.gloc.of |transcribe-compiled-templete`2|)
 (close
   (2 0 . compiled->source)
   (push.const . syntax-rules)
   (push.iloc.0 . 0)
   (call
     (push.gloc.of |.fn4.1`4|)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 30753))
   (push)
   (ret.subr.gloc.of |.cons*| "./boot/macro/synrule.scm" . 29703))
 (set.gloc.of |compiled->source`2|)
 (close
   (2 0 . transcribe-syntax-rules)
   (call
     (iloc.0 . 0)
     (if.pair?.ret.const . #t)
     (push.iloc.0 . 0)
     (push.const . "misplaced syntactic keyword")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 33801))
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 35858)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 35878)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 1)
       (if.true
         (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 39971)
         (push.const . "invalid syntax")
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of put-annotation)
           (call
             (touch.gloc.of |compiled->source`2|)
             (push.iloc 2 . 0)
             (push.cddr.iloc (3 . 1) "./boot/macro/synrule.scm" . 40044)
             (apply.gloc.of |compiled->source`2| "./boot/macro/synrule.scm" . 40020))
           (push)
           (push.iloc 2 . 1)
           (apply.gloc.of put-annotation "./boot/macro/synrule.scm" . 40004))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 39953))
       (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 40995)
       (push.const . "invalid syntax")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 40977))
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 42010)
     (extend . 1)
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 43037)
     (extend . 1)
     (call
       (call
         (touch.gloc.of match-pattern?)
         (push.iloc 5 . 0)
         (push.iloc.0 . 0)
         (push.iloc 4 . 0)
         (apply.gloc.of match-pattern? "./boot/macro/synrule.scm" . 44063))
       (if.false.ret)
       (touch.gloc.of bind-pattern)
       (push.iloc 5 . 0)
       (push.iloc.0 . 0)
       (push.iloc 4 . 0)
       (push.const)
       (apply.gloc.of bind-pattern "./boot/macro/synrule.scm" . 45087))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (touch.gloc.of |transcribe-compiled-templete`2|)
       (push.cdr.iloc (2 . 0) "./boot/macro/synrule.scm" . 47153)
       (push.iloc.0 . 0)
       (apply.gloc.of |transcribe-compiled-templete`2| "./boot/macro/synrule.scm" . 47123))
     (push.cdr.iloc (3 . 0) "./boot/macro/synrule.scm" . 48153)
     (apply.iloc+ (4 . 0) "./boot/macro/synrule.scm" . 48147))
   (push.cddr.iloc (2 . 1) "./boot/macro/synrule.scm" . 35898)
   (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 36871))
 (set.gloc.of transcribe-syntax-rules)
 (ret.const.unspec))
((close
   (3 0 . parse-syntax-rule)
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 52244)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 52268)
   (extend . 2)
   (call
     (touch.gloc.of check-pattern)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of check-pattern "./boot/macro/synrule.scm" . 53255))
   (call
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.const)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synrule.scm" . 54292))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of check-template)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of check-template "./boot/macro/synrule.scm" . 55305))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of collect-rename-ids)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-rename-ids "./boot/macro/synrule.scm" . 56360))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 56329))
 (set.gloc.of parse-syntax-rule)
 (ret.const.unspec))
((close
   (1 0 . make-remark)
   (call
     (touch.gloc.of get-annotation)
     (push.iloc.0 . 0)
     (apply.gloc.of get-annotation "./boot/macro/synrule.scm" . 63504))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.const . |.&SOURCE-PATH|)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/synrule.scm" . 65563)
     (iloc.0 . 0)
     (ret.cons "./boot/macro/synrule.scm" . 65557))
   (ret.const . #f))
 (set.gloc.of |make-remark`2|)
 (close
   (4 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of list "./boot/macro/synrule.scm" . 73754))
 (set.gloc.of |.fn3.1`3|)
 (close
   (4 0 . compile-syntax-rules)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of |make-remark`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |make-remark`2| "./boot/macro/synrule.scm" . 70673))
   (push)
   (call
     (push.close
       (1 0)
       (push.close
         (0 0)
         (touch.gloc.of parse-syntax-rule)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (push.iloc 2 . 3)
         (apply.gloc.of parse-syntax-rule "./boot/macro/synrule.scm" . 72775))
       (push.gloc.of |.fn3.1`3|)
       (apply.gloc.of |.call-with-values| "./boot/macro/synrule.scm" . 71702))
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 61445))
   (push)
   (subr.gloc.of cons 2 "./boot/macro/synrule.scm" . 61445)
   (ret.cons "./boot/macro/synrule.scm" . 61445))
 (set.gloc.of compile-syntax-rules)
 (ret.const.unspec))

;
((push.const . |.patvars|)
 (push.const)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 14337))
((close
   (3 0 . make-syntax-object)
   (push.const . type:syntax)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 16446))
 (set.gloc.of make-syntax-object)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-expr)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 17453))
 (set.gloc.of syntax-object-expr)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-renames)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 18477))
 (set.gloc.of syntax-object-renames)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-lexname)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 19501))
 (set.gloc.of syntax-object-lexname)
 (ret.const.unspec))
((close
   (1 0 . wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 23562)
   (const . type:syntax)
   (ret.eq? "./boot/macro/syncase.scm" . 23557))
 (set.gloc.of wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (2 0 . lookup-lexical-name)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 27665))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of renamed-id?)
     (push.iloc.0 . 0)
     (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 28686))
   (if.true (ret.iloc 0 . 0))
   (call
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/syncase.scm" . 29715))
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 29729))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 28679))
   (ret.iloc 2 . 0))
 (set.gloc.of lookup-lexical-name)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 36888)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 36882))
     (if.true.ret)
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 36905)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 36899))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 37902)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 39957)
       (if.false.ret)
       (call
         (touch.gloc.of |loop`5|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 40991)
         (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 40985))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 42016)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 42009))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 38944)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 38941)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 38926))
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 44046))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . contain-wrapped-syntax-object?)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 34821))
 (set.gloc.of contain-wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 50200)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 50194))
     (if.true.ret)
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 50217)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 50211))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 51214)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 53269)
       (if.false.ret)
       (call
         (touch.gloc.of |loop`5|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 54303)
         (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 54297))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 55328)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 55321))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 52256)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 52253)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 52238))
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 56334))
   (if.true.ret.const . #f)
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 58382))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . contain-non-id-wrapped-syntax-object?)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 48133))
 (set.gloc.of contain-non-id-wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (1 0 . unwrap-syntax)
   (call
     (touch.gloc.of contain-non-id-wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of contain-non-id-wrapped-syntax-object? "./boot/macro/syncase.scm" . 62476))
   (if.true
     (call
       (subr.gloc.of make-core-hashtable 0)
       (push)
       (extend . 1)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.pair?
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 67620)
               (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 67614))
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 68644)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 68638))
           (push.iloc.0 . 0)
           (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 69662)
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 70701)
             (apply.gloc.of for-each "./boot/macro/syncase.scm" . 70686))
           (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 71710))
           (if.true
             (call
               (touch.gloc.of syntax-object-renames)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 72748))
             (push)
             (extend . 1)
             (iloc.0 . 0)
             (if.null?.ret.const . #t)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 74817)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 74788)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 75836)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 75849)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 75812))
           (call
             (touch.gloc.of wrapped-syntax-object?)
             (push.iloc.0 . 0)
             (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 76830))
           (if.true
             (call
               (push.close
                 (1 0)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 78923)
                 (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 78894)
                 (if.true.ret)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 79942)
                 (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 79950)
                 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 79918))
               (call
                 (touch.gloc.of syntax-object-renames)
                 (push.iloc.0 . 0)
                 (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 80936))
               (push)
               (apply.gloc.of for-each "./boot/macro/syncase.scm" . 77854))
             (call
               (touch.gloc.of syntax-object-expr)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 81956))
             (push)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 81950))
           (ret.const.unspec))
         (push.iloc 2 . 0)
         (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 65557))
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable->alist "./boot/macro/syncase.scm" . 82965))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 86054)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 86048))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 86075)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 86069))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 87084)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 87102)
           (ret.eq? "./boot/macro/syncase.scm" . 87095))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 88101))
       (iloc.0 . 0)
       (if.symbol?
         (touch.gloc.of make-syntax-object)
         (push.iloc.0 . 0)
         (call
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 90163)
           (if.true.ret)
           (ret.const))
         (push)
         (push.const . #f)
         (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 90135))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 91159))
       (if.true
         (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 92190))
         (if.true (ret.iloc 0 . 0))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 93225))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 93219))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 94231)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 95279)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 95269))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 95255))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 83982))
   (ret.iloc 0 . 0))
 (set.gloc.of unwrap-syntax)
 (ret.const.unspec))
((close
   (2 0 . identical-global-macro?)
   (call
     (touch.gloc.of macro?)
     (push.iloc.0 . 0)
     (apply.gloc.of macro? "./boot/macro/syncase.scm" . 104462))
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 105496)
   (ret.eq? "./boot/macro/syncase.scm" . 105486))
 (set.gloc.of |identical-global-macro?`2|)
 (close
   (2 0 . unrename-syntax)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (touch.gloc.of annotated?)
         (push.iloc.0 . 0)
         (apply.gloc.of annotated? "./boot/macro/syncase.scm" . 109586))
       (if.true
         (touch.gloc.of annotate)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 110632)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 110626))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 110649)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 110643))
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 110610))
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 111646)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 111640))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 111663)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 111657))
       (ret.cons "./boot/macro/syncase.scm" . 111634))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 113690))
       (push)
       (call
         (touch.gloc.of original-id)
         (push.iloc.0 . 0)
         (apply.gloc.of original-id "./boot/macro/syncase.scm" . 114712))
       (push)
       (extend . 2)
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/syncase.scm" . 115735))
       (if.true (ret.iloc 0 . 1))
       (call
         (touch.gloc.of |identical-global-macro?`2|)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of |identical-global-macro?`2| "./boot/macro/syncase.scm" . 116759))
       (if.true (ret.iloc 0 . 1))
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 118798)
     (if.true
       (call
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 119846)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 119836))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 119822))
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 107525))
 (set.gloc.of unrename-syntax)
 (ret.const.unspec))
((close
   (1 0)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 129062)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 129056))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 129083)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 129077))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 130092)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 130110)
           (ret.eq? "./boot/macro/syncase.scm" . 130103))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 131109))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 132119)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 133167)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 133157))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 133143))
       (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 134167))
       (if.true
         (call
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 135205))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?.ret.const . #t)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 137278)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 137249)
           (if.true.ret)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 138297)
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 138310)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 138273))
         (touch.gloc.of syntax-object-expr)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 139287))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 140311))
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 142404)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 142375)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 143423)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 143431)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 143399))
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 144417))
           (push)
           (apply.gloc.of for-each "./boot/macro/syncase.scm" . 141335))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 145437))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 145431))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 126990))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 147478)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 124933))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.flatten-syntax|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 123907))
((close
   (3 1)
   (extend.enclose+
     (2 0 . match)
     (call
       (touch.gloc.of match-pattern?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/syncase.scm" . 154638))
     (if.false.ret)
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc 2 . 2)
     (push.const)
     (apply.gloc.of bind-pattern "./boot/macro/syncase.scm" . 155662))
   (call
     (touch.gloc.of unwrap-syntax)
     (push.iloc.1 . 1)
     (apply.gloc.of unwrap-syntax "./boot/macro/syncase.scm" . 157713))
   (push)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (call
         (iloc 2 . 0)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (ret.subr.gloc.of car "./boot/macro/syncase.scm" . 160817))
       (push)
       (push.const . "invalid syntax")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 160781))
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 161819)
     (push.subr.gloc.of cadr 1 "./boot/macro/syncase.scm" . 163869)
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 161819)
     (push.subr.gloc.of caddr 1 "./boot/macro/syncase.scm" . 164891)
     (extend . 2)
     (call
       (push.iloc 3 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 161819)
       (push.subr.gloc.of car 1 "./boot/macro/syncase.scm" . 162842)
       (apply.iloc+ (4 . 0) "./boot/macro/syncase.scm" . 165917))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.1 . 0)
       (if.false.ret.const . #t)
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 169000)
       (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 168992))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 170013)
       (apply.iloc (1 . 1) "./boot/macro/syncase.scm" . 170007))
     (push.cdr.iloc (2 . 0) "./boot/macro/syncase.scm" . 171037)
     (apply.iloc+ (3 . 0) "./boot/macro/syncase.scm" . 171031))
   (push.iloc 3 . 3)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 158727))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax-dispatch|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 149505))
((close
   (2 0 . partial-wrap-syntax-object)
   (extend.enclose+
     (1 0 . loop)
     (call
       (touch.gloc.of contain-wrapped-syntax-object?)
       (push.iloc.0 . 0)
       (apply.gloc.of contain-wrapped-syntax-object? "./boot/macro/syncase.scm" . 184338))
     (if.true
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 186408)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 186402))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 186429)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 186423))
         (push)
         (extend . 2)
         (call
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 187436)
           (iloc.0 . 0)
           (if.not.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 187454)
           (iloc.0 . 1)
           (ret.eq? "./boot/macro/syncase.scm" . 187449))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 188455))
       (ret.iloc 0 . 0))
     (iloc.0 . 0)
     (if.symbol?
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 191534)
         (if.true.ret)
         (ret.const))
       (push)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 191506))
     (call
       (iloc.0 . 0)
       (if.pair?.ret.const . #t)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of vector? "./boot/macro/syncase.scm" . 192546))
     (if.true
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 193554))
     (iloc.0 . 0)
     (if.null?.ret.const)
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 196626))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 183305))
 (set.gloc.of |partial-wrap-syntax-object`2|)
 (close
   (5 0)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 199693))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/syncase.scm" . 201741))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of rename-id "./boot/macro/syncase.scm" . 203816))
       (ret.cons "./boot/macro/syncase.scm" . 203807))
     (call
       (touch.gloc.of collect-rename-ids)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 204818))
     (push)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 203789))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 206886)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 206916)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 206896))
       (ret.cons "./boot/macro/syncase.scm" . 206880))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 206861))
   (push)
   (extend . 1)
   (call
     (iloc 4 . 4)
     (if.null? (ret.const))
     (iloc 3 . 0)
     (if.null?.ret.const)
     (touch.gloc.of filter)
     (push.gloc.of values)
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 215085)
         (push.iloc 5 . 4)
         (push.subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 216108)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 215085)
             (push.iloc 5 . 0)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 218173))
           (push)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 218206)
           (if.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 219203)
           (call
             (touch.gloc.of make-out-of-context)
             (push.iloc 6 . 1)
             (apply.gloc.of make-out-of-context "./boot/macro/syncase.scm" . 219211))
           (ret.cons "./boot/macro/syncase.scm" . 219197))
         (ret.const . #f))
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 198661))
     (push)
     (apply.gloc.of filter "./boot/macro/syncase.scm" . 198661))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc 5 . 1)
     (push.iloc 5 . 2)
     (push.iloc 5 . 0)
     (push.iloc 2 . 0)
     (push.gloc.of |emit`2|)
     (apply.gloc.of transcribe-template "./boot/macro/syncase.scm" . 222227))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 225325)
       (if.true.ret)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 225352)
       (if.true.ret)
       (ret.const))
     (push)
     (push.iloc 6 . 3)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 225296))
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 226320))
   (if.true
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 227355))
     (if.null?.ret.const)
     (ret.iloc 0 . 0))
   (touch.gloc.of |partial-wrap-syntax-object`2|)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of extend-env)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 229425))
   (push)
   (apply.gloc.of |partial-wrap-syntax-object`2| "./boot/macro/syncase.scm" . 229392))
 (set.gloc.of |.fn3.1`3|)
 (close
   (1 0 . emit)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 178192))
   (if.true (ret.iloc 0 . 0))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 179221))
 (set.gloc.of |emit`2|)
 (push.const . |.syntax-transcribe|)
 (push.gloc.of |.fn3.1`3|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 182279))
((close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 237610)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 237604))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 237627)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 237621))
       (ret.cons "./boot/macro/syncase.scm" . 237598))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 238629))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 237579))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 239634)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 239672)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 239662))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 239648))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 236553))
 (set.gloc.of |rewrite`2|)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
   (call
     (touch.gloc.of make-pattern-variable)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (apply.gloc.of make-pattern-variable "./boot/macro/syncase.scm" . 234501))
   (ret.cons "./boot/macro/syncase.scm" . 234501))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . expand-syntax-case)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 234501)
     (ret.subr.gloc.of |.list?| "./boot/macro/syncase.scm" . 234501))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 234501)
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
     (extend . 2)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/syncase.scm" . 234501)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 234501))
     (push)
     (extend . 1)
     (call
       (call
         (push.iloc.0 . 0)
         (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 234501)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 0)
         (apply.gloc.of every1 "./boot/macro/syncase.scm" . 234501))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "invalid literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 0)
         (apply.gloc.of unique-id-list? "./boot/macro/syncase.scm" . 234501))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "duplicate literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (push.const . _)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 234501)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "_ in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (push.const . ...)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 234501)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "... in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of lookup-lexical-name)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 234501))
         (ret.cons "./boot/macro/syncase.scm" . 234501))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 234501))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of |rewrite`2|)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of |rewrite`2| "./boot/macro/syncase.scm" . 234501))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . parse-pattern)
       (call
         (touch.gloc.of |rewrite`2|)
         (call
           (touch.gloc.of unrename-syntax)
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 234501))
         (push)
         (push.iloc 3 . 0)
         (apply.gloc.of |rewrite`2| "./boot/macro/syncase.scm" . 234501))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 234501))
       (call
         (touch.gloc.of check-pattern)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of check-pattern "./boot/macro/syncase.scm" . 234501))
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of |.fn1.1`1|)
           (call
             (touch.gloc.of collect-vars-ranks)
             (push.iloc.0 . 0)
             (push.iloc 3 . 0)
             (push.const . 0)
             (push.const)
             (apply.gloc.of collect-vars-ranks "./boot/macro/syncase.scm" . 234501))
           (push)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 234501))
         (push)
         (push.iloc 7 . 1)
         (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 234501))
       (push)
       (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 234501))
     (touch.gloc.of annotate)
     (push.const . |.syntax-dispatch|)
     (call
       (touch.gloc.of expand-form)
       (push.const . |.patvars|)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
     (push)
     (call
       (touch.gloc.of expand-form)
       (push.iloc 4 . 1)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
     (push)
     (push.const . quote)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 234501)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 234501)
           (ret.pair? "./boot/macro/syncase.scm" . 234501))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
           (ret.null? "./boot/macro/syncase.scm" . 234501))
         (if.true
           (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
           (extend . 2)
           (push.close
             (0 0)
             (push.iloc.1 . 1)
             (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 234501))
           (push.close
             (2 0)
             (push.const . |.list|)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 234501)
             (push.const . #f)
             (call
               (touch.gloc.of expand-form)
               (push.const . |.LAMBDA|)
               (push.const |.patvars|)
               (push.iloc.1 . 0)
               (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 234501)
               (push.iloc.0 . 1)
               (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/syncase.scm" . 234501))
           (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 234501))
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 234501)
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.caddr| 1 "./boot/macro/syncase.scm" . 234501)
         (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
         (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 234501)
         (extend . 3)
         (push.close
           (0 0)
           (push.iloc.1 . 2)
           (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 234501))
         (push.close
           (2 0)
           (push.const . |.list|)
           (push.const . quote)
           (push.iloc.0 . 0)
           (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 234501)
           (call
             (touch.gloc.of expand-form)
             (push.const . |.LAMBDA|)
             (push.const |.patvars|)
             (push.iloc.1 . 1)
             (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 234501)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
           (push)
           (call
             (touch.gloc.of expand-form)
             (push.const . |.LAMBDA|)
             (push.const |.patvars|)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 234501)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 234501))
           (push)
           (ret.subr.gloc.of |.list| "./boot/macro/syncase.scm" . 234501))
         (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 234501))
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 234501))
     (push)
     (push.subr.gloc.of |.cons*| 5 "./boot/macro/syncase.scm" . 234501)
     (push.iloc 4 . 1)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 234501))
   (push.const . syntax-case)
   (push.const . "invalid syntax")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 234501))
 (set.gloc.of expand-syntax-case)
 (ret.const.unspec))
((close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 299050)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 299044))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 299067)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 299061))
       (ret.cons "./boot/macro/syncase.scm" . 299038))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 300069))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 299019))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 301074)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 301112)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 301102))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 301088))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 297993))
 (set.gloc.of |rewrite`2|)
 (close
   (2 0 . expand-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
     (ret.null? "./boot/macro/syncase.scm" . 295941))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
     (extend . 1)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 295941))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of pattern-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of pattern-variable? "./boot/macro/syncase.scm" . 295941))
           (if.false.ret)
           (push.iloc.1 . 0)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 295941)
           (ret.cons "./boot/macro/syncase.scm" . 295941))
         (call
           (touch.gloc.of collect-unique-ids)
           (push.iloc.0 . 0)
           (apply.gloc.of collect-unique-ids "./boot/macro/syncase.scm" . 295941))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 295941))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.iloc.0 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 295941))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of renamed-id?)
             (push.iloc.0 . 0)
             (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 295941))
           (if.false.ret)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (if.eq?.ret.const . #f)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (ret.cons "./boot/macro/syncase.scm" . 295941))
         (call
           (touch.gloc.of collect-rename-ids)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 295941))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 295941))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of check-template)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of check-template "./boot/macro/syncase.scm" . 295941))
     (call
       (iloc 3 . 0)
       (if.not.symbol?.ret.const . #f)
       (touch.gloc.of lookup-lexical-name)
       (push.iloc 3 . 0)
       (push.iloc 4 . 1)
       (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 295941))
     (push)
     (extend . 1)
     (touch.gloc.of annotate)
     (push.const . |.syntax-transcribe|)
     (call
       (touch.gloc.of expand-form)
       (push.const . |.patvars|)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 295941))
     (push)
     (push.const . quote)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.const . quote)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.const . quote)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.const . quote)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 295941)
     (push.subr.gloc.of |.list| 6 "./boot/macro/syncase.scm" . 295941)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 295941))
   (push.const . syntax)
   (push.const . "expected exactly one datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 295941))
 (set.gloc.of expand-syntax)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 334878)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 334872))
     (push)
     (call
       (touch.gloc.of |loop`5|)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 334899)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 334893))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 335908)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 335926)
       (ret.eq? "./boot/macro/syncase.scm" . 335919))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 336925))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 337935)
   (if.true
     (call
       (push.gloc.of |loop`5|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 338983)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 338973))
     (push)
     (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 338959))
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 339983))
   (if.true
     (touch.gloc.of |loop`5|)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 341013))
     (push)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 341007))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . syntax->datum)
   (touch.gloc.of strip-rename-suffix)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 332806))
   (push)
   (apply.gloc.of strip-rename-suffix "./boot/macro/syncase.scm" . 332806))
 (set.gloc.of syntax->datum)
 (ret.const.unspec))
((close
   (2 0 . datum->syntax)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 346121))
   (if.false.call
     (push.const . datum->syntax)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 347181)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 347145))
   (call
     (touch.gloc.of retrieve-rename-suffix)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 348203))
     (push)
     (apply.gloc.of retrieve-rename-suffix "./boot/macro/syncase.scm" . 348179))
   (push)
   (call
     (call
       (touch.gloc.of syntax-object-renames)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 349211))
     (if.null?
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 350228))
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 351252))
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 4)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 356391)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 356385))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 356408)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 356402))
         (ret.cons "./boot/macro/syncase.scm" . 356379))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 357403)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 358451)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 358441))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 358427))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 2)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 360482)
         (if.true.ret)
         (push.iloc.0 . 0)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/syncase.scm" . 362572)
         (push.iloc 2 . 0)
         (push.subr.gloc.of string-append 2 "./boot/macro/syncase.scm" . 362557)
         (push.subr.gloc.of string->symbol 1 "./boot/macro/syncase.scm" . 362541)
         (extend . 1)
         (push.iloc 3 . 2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syncase.scm" . 363556)
         (call
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 364598))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc.1 . 0)
           (if.eq?
             (push.iloc 4 . 3)
             (push.iloc.1 . 0)
             (call
               (touch.gloc.of env-lookup)
               (push.iloc 4 . 1)
               (push.iloc 2 . 0)
               (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 367690))
             (push)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 367661))
           (push.iloc 4 . 3)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 370733))
         (ret.iloc 0 . 0))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 354322))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 374835)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 374825)
       (if.true.ret)
       (ret.const))
     (push)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 374797))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.iloc.1 . 3)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 375845)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 375821))
 (set.gloc.of datum->syntax)
 (ret.const.unspec))
((close
   (1 0 . identifier?)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 379914))
   (if.false.ret)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 380947))
   (push)
   (ret.subr.gloc.of symbol? "./boot/macro/syncase.scm" . 380938))
 (set.gloc.of identifier?)
 (ret.const.unspec))
((close
   (2 0 . bound-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 385033))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 386098)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 386057))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 387081))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 388146)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 388105))
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 389130))
   (push)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 389155))
   (ret.eq? "./boot/macro/syncase.scm" . 389125))
 (set.gloc.of bound-identifier=?)
 (ret.const.unspec))
((close
   (2 0 . free-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 393225))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 394289)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 394249))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 395273))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 396337)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 396297))
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 397328))
   (push)
   (extend . 1)
   (call
     (call
       (touch.gloc.of syntax-object-lexname)
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 398352))
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 398401))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 398380))
   (push)
   (call
     (call
       (touch.gloc.of syntax-object-lexname)
       (push.iloc.1 . 1)
       (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 399376))
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.1 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 399425))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 399404))
   (ret.eq? "./boot/macro/syncase.scm" . 398343))
 (set.gloc.of free-identifier=?)
 (ret.const.unspec))
((close
   (1 0)
   (touch.gloc.of make-syntax-object)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syncase.scm" . 405546))
   (push)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 405526))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . generate-temporaries)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 403465)
   (if.false.call
     (push.const . generate-temporaries)
     (push.const . "expected list, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 404532)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 404489))
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of map "./boot/macro/syncase.scm" . 405509))
 (set.gloc.of generate-temporaries)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer)
   (touch.gloc.of make-variable-transformer-token)
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 411666))
       (if.true (ret.iloc 0 . 0))
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 413714))
     (push)
     (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 411656))
   (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 409605))
 (set.gloc.of make-variable-transformer)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer-token)
   (push.const . type:variable-transformer-token)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 417797))
 (set.gloc.of make-variable-transformer-token)
 (ret.const.unspec))
((close
   (1 0 . variable-transformer-token?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 421898)
   (const . type:variable-transformer-token)
   (ret.eq? "./boot/macro/syncase.scm" . 421893))
 (set.gloc.of variable-transformer-token?)
 (ret.const.unspec))
((close
   (1 1)
   (iloc.0 . 1)
   (if.null?
     (push.iloc.0 . 0)
     (apply.gloc.of |.flatten-syntax| "./boot/macro/syncase.scm" . 431131))
   (push.iloc.0 . 0)
   (push.car.iloc (0 . 1) "./boot/macro/syncase.scm" . 432167)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 432155))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (push.close
     (1 0 . thunk)
     (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (2 . 0) "./boot/macro/syncase.scm" . 428064))
     (push.gloc.of |.fn1.1`1|)
     (apply.gloc.of call-with-values "./boot/macro/syncase.scm" . 427028))
   (extend . 1)
   (push.iloc.1 . 0)
   (subr.gloc.of procedure? 1 "./boot/macro/syncase.scm" . 433166)
   (if.true
     (push.close
       (0 0)
       (touch.gloc.of closure-arity)
       (push.iloc 2 . 0)
       (apply.gloc.of closure-arity "./boot/macro/syncase.scm" . 434216))
     (push.close
       (2 0)
       (=n.iloc (0 . 0) 1 "./boot/macro/syncase.scm" . 435221)
       (if.false.ret)
       (=n.iloc (0 . 1) 0 "./boot/macro/syncase.scm" . 435233)
       (if.false.ret)
       (ret.iloc 1 . 0))
     (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 425989))
   (call
     (touch.gloc.of variable-transformer-token?)
     (push.iloc.1 . 0)
     (apply.gloc.of variable-transformer-token? "./boot/macro/syncase.scm" . 436238))
   (if.true
     (push.iloc.1 . 0)
     (push.const . 1)
     (subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 437273)
     (set.iloc 1 . 0)
     (touch.gloc.of make-variable-transformer-token)
     (push.iloc.0 . 0)
     (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 438286))
   (ret.iloc 1 . 0))
 (set.gloc.of |.fn2.1`2|)
 (push.const . |.transformer-thunk|)
 (push.gloc.of |.fn2.1`2|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 429077))

;
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/library.scm" . 5150))
 (set.gloc.of scheme-library-paths)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 6176))
 (set.gloc.of scheme-library-exports)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 7201))
 (set.gloc.of scheme-library-versions)
 (ret.const.unspec))
((close
   (2 0 . generate-global-id)
   (push.const . "~a~a~a~a")
   (call
     (touch.gloc.of current-library-prefix)
     (apply.gloc.of current-library-prefix "./boot/macro/library.scm" . 11304))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-library-suffix)
     (apply.gloc.of current-library-suffix "./boot/macro/library.scm" . 11340))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 5 "./boot/macro/library.scm" . 11285)
   (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 11269))
 (set.gloc.of generate-global-id)
 (ret.const.unspec))
((close
   (2 0 . symbol-list->string)
   (push.gloc.of string-append)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 18467)
       (if.symbol?
         (push.iloc 2 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 20534)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/library.scm" . 20518)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 21548)
           (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 21542))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/library.scm" . 20512)
         (ret.cons "./boot/macro/library.scm" . 19482))
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 23584)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 23578))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 16401))
   (push)
   (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 14339)
   (apply.gloc.of apply "./boot/macro/library.scm" . 14339))
 (set.gloc.of symbol-list->string)
 (ret.const.unspec))
((close
   (1 0 . generate-library-id)
   (touch.gloc.of library-name->id)
   (push.const . #f)
   (push.iloc.0 . 0)
   (apply.gloc.of library-name->id "./boot/macro/library.scm" . 27653))
 (set.gloc.of generate-library-id)
 (ret.const.unspec))
((close
   (2 0 . library-name->id)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.true
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 35905))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 35853))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 36877))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 38926)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 38944)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 38939))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 39949))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.1 . 1)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 41015))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 40989))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 40973))
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 42028)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 42025)
     (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 42009)
     (extend . 1)
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 43027))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 44093))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 44067))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 44051))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 45075))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 46089))
 (set.gloc.of library-name->id)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 59406)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 59421)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 59434))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (2 0 . library-name->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 54340))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 54285))
     (push.const . library)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 55309))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 61454)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 61472)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 61467))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 62480))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 64564)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 64561)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 64545)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 64540)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?.ret.const . #f)
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 66590)
       (if.false.ret)
       (touch.gloc.of every1)
       (push.gloc.of |exact-nonnegative-integer?`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 66603))
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 67614))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 68617))
 (set.gloc.of library-name->version)
 (ret.const.unspec))
((close
   (2 0 . library-reference->name)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 76865))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 76813))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 77837))
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.1 . 1)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 79884))
   (if.true (ret.iloc 1 . 1))
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 81962)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 81959)
   (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 81944)
   (extend . 1)
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 82965))
   (if.true (ret.iloc 0 . 0))
   (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 83994))
 (set.gloc.of library-reference->name)
 (ret.const.unspec))
((close
   (2 0 . flatten-library-reference)
   (call
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 88078)
       (if.false.ret)
       (push.iloc.0 . 1)
       (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 88095)
       (ret.subr.gloc.of not "./boot/macro/library.scm" . 88090))
     (if.true.ret)
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 89149))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 89097))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 1) "./boot/macro/library.scm" . 88069)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 1) "./boot/macro/library.scm" . 88069)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 88069)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 88069)
     (if.false.ret)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 88069)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 88069))
   (if.true
     (touch.gloc.of flatten-library-reference)
     (push.iloc.0 . 0)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 88069)
     (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 88069))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 88069)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 88069))
   (if.true
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 88069))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 88069))
   (ret.iloc 0 . 1))
 (set.gloc.of flatten-library-reference)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 106510)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 106525)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 106538))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (2 0 . library-reference->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . import)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 101443))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 101389))
     (push.const . import)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 102413))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 108558)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 108575)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 108570))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 109584))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 110648)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 110645)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 110630)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 110625)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 111646)
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 112675))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 113673))
 (set.gloc.of library-reference->version)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 120846)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 120861)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 120874))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (4 0 . test-library-versions)
   (call
     (extend.enclose
       (1 0 . loop)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 123915)
         (ret.subr.gloc.of |.list?| "./boot/macro/library.scm" . 123915))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
         (if.not.null?.ret.const . #f)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
         (const . not)
         (ret.eq? "./boot/macro/library.scm" . 123915))
       (if.true
         (call
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
           (apply.iloc (2 . 0) "./boot/macro/library.scm" . 123915))
         (push)
         (ret.subr.gloc.of not "./boot/macro/library.scm" . 123915))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
         (const . or)
         (ret.eq? "./boot/macro/library.scm" . 123915))
       (if.true
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 123915))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
         (apply.gloc.of any1 "./boot/macro/library.scm" . 123915))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
         (const . and)
         (ret.eq? "./boot/macro/library.scm" . 123915))
       (if.true
         (touch.gloc.of every1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 123915))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 123915)
         (apply.gloc.of every1 "./boot/macro/library.scm" . 123915))
       (extend.enclose
         (2 0 . loop)
         (call
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/macro/library.scm" . 123915)
             (if.false.ret)
             (push.iloc.0 . 1)
             (ret.subr.gloc.of list? "./boot/macro/library.scm" . 123915))
           (if.true.ret)
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 123915))
           (push)
           (push.iloc 5 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 123915))
         (iloc.0 . 1)
         (if.null?.ret.const . #t)
         (push.iloc.0 . 0)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 123915)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 123915)
         (subr.gloc.of >= 2 "./boot/macro/library.scm" . 123915)
         (if.false.ret)
         (touch.gloc.of every2)
         (push.close
           (2 0)
           (call
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (0 . 1) "./boot/macro/library.scm" . 123915)
             (ret.subr.gloc.of |.list?| "./boot/macro/library.scm" . 123915))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 1)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 1) "./boot/macro/library.scm" . 123915)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (1 . 1) "./boot/macro/library.scm" . 123915)
             (ret.null? "./boot/macro/library.scm" . 123915))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (const . not)
             (ret.eq? "./boot/macro/library.scm" . 123915))
           (if.true
             (call
               (push.iloc 2 . 0)
               (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
               (apply.iloc (4 . 0) "./boot/macro/library.scm" . 123915))
             (push)
             (ret.subr.gloc.of not "./boot/macro/library.scm" . 123915))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (const . >=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 123915))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (ret.subr.gloc.of >= "./boot/macro/library.scm" . 123915))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (const . <=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 123915))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (ret.subr.gloc.of <= "./boot/macro/library.scm" . 123915))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (const . and)
             (ret.eq? "./boot/macro/library.scm" . 123915))
           (if.true
             (touch.gloc.of every1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 123915)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 123915)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 123915))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (apply.gloc.of every1 "./boot/macro/library.scm" . 123915))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (const . or)
             (ret.eq? "./boot/macro/library.scm" . 123915))
           (if.true
             (touch.gloc.of any1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 123915)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 123915)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 123915))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 123915)
             (apply.gloc.of any1 "./boot/macro/library.scm" . 123915))
           (call
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.iloc 2 . 1)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 123915))
           (if.true
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (ret.subr.gloc.of = "./boot/macro/library.scm" . 123915))
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 8 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 123915))
           (push)
           (push.iloc 8 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 123915))
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 123915)
         (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 123915)
         (push.iloc.0 . 1)
         (apply.gloc.of every2 "./boot/macro/library.scm" . 123915))
       (push.iloc 4 . 3)
       (push.iloc 2 . 0)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 123915))
     (push.iloc.1 . 2)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 122889))
   (if.true.ret)
   (push.const . import)
   (push.const . "mismatch between version reference ~a and current version ~a")
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 146459)
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 147483))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 145417))
 (set.gloc.of test-library-versions)
 (ret.const.unspec))
((close
   (1 0 . make-shield-id-table)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (call
     (touch.gloc.of make-unbound)
     (apply.gloc.of make-unbound "./boot/macro/library.scm" . 151596))
   (push)
   (extend . 2)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 154646)
           (apply.iloc (1 . 0) "./boot/macro/library.scm" . 154640))
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 155670)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 155664))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 157712))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/library.scm" . 158736)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/library.scm" . 159766)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 159760))
       (ret.const.unspec))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 152583))
   (ret.iloc 0 . 0))
 (set.gloc.of make-shield-id-table)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 165895))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 165895))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
   (cadr.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
   (ret.cons "./boot/macro/library.scm" . 165895))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . parse-exports)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (push.iloc.0 . 1) (ret.subr.gloc.of reverse "./boot/macro/library.scm" . 165895))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 165895))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 165895))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 165895))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 165895)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 165895))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 165895)
       (extend . 2)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of |.fn1.1`1|)
           (push.iloc.0 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 165895))
         (if.true.ret)
         (push.const . export)
         (push.const . "malformed export spec")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 165895))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 165895)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 165895))
       (push.iloc.0 . 0)
       (call
         (push.gloc.of |.fn2.1`2|)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/library.scm" . 165895))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 165895)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 165895))
     (push.const . export)
     (push.const . "malformed export spec")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 2 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 165895))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 165895)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 165895))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 164869))
 (set.gloc.of parse-exports)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 199687))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 199687))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . parse-imports)
   (extend.unbound . 2)
   (push.close
     (3 0 . check-unbound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 187417)
       (if.true.ret)
       (push.const . import)
       (push.const . "attempt to reference undefined identifier ~a in (~a ...) form")
       (push.iloc.0 . 0)
       (push.car.iloc (1 . 2) "./boot/macro/library.scm" . 188542)
       (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 188467)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 188557))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 188441))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 186377))
   (push.close
     (3 0 . check-bound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 194586)
       (if.false.ret)
       (push.const . import)
       (push.const . "duplicate import identifiers ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 195636)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 195682))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 195610))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 193545))
   (enclose . 2)
   (extend.enclose
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 199687)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 199687)
       (ret.pair? "./boot/macro/library.scm" . 199687))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 199687)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 199687))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 199687)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 199687)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 199687)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 199687))
       (push)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 199687))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 199687)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 199687))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 199687)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 199687)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 199687)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 199687)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 199687))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 199687)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 199687))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 199687)
           (push.iloc 2 . 1)
           (ret.subr.gloc.of memq "./boot/macro/library.scm" . 199687))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 199687))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 199687)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 199687))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 199687)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 199687))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 199687)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 199687)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 199687)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 199687)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 199687))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 199687)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 199687))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 199687)
           (push.iloc 2 . 1)
           (push.subr.gloc.of memq 2 "./boot/macro/library.scm" . 199687)
           (ret.subr.gloc.of not "./boot/macro/library.scm" . 199687))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 199687))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 199687)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 199687))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 199687)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 199687))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 199687)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 199687)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 199687)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 199687)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 199687))
       (push)
       (extend . 1)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of |.fn2.1`2|)
           (push.iloc.1 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 199687))
         (if.true.ret)
         (push.const . import)
         (push.const . "malformed import set")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 199687))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 199687)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 199687))
       (call
         (call
           (call
             (touch.gloc.of unique-id-list?)
             (call
               (push.gloc.of car)
               (push.iloc.1 . 1)
               (apply.gloc.of map "./boot/macro/library.scm" . 199687))
             (push)
             (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 199687))
           (if.false.ret)
           (touch.gloc.of unique-id-list?)
           (call
             (push.gloc.of cadr)
             (push.iloc.1 . 1)
             (apply.gloc.of map "./boot/macro/library.scm" . 199687))
           (push)
           (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 199687))
         (if.true.ret)
         (push.const . import)
         (push.const . "duplicate identifers in rename specs")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 199687))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 199687)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 199687))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of cadr)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 199687))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 199687)
         (apply.iloc (5 . 1) "./boot/macro/library.scm" . 199687))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of car)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 199687))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 199687)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 199687))
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 199687)
           (push.iloc 2 . 1)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 199687)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 199687)
             (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 199687)
             (ret.cons "./boot/macro/library.scm" . 199687))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/library.scm" . 199687))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 199687)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 199687))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 199687)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 199687)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 199687)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 199687))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 199687)
       (extend . 1)
       (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 199687)
       (call
         (push.close
           (1 0)
           (push.const . "~a~a")
           (push.iloc.1 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 199687)
           (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 199687)
           (push.subr.gloc.of string->symbol 1 "./boot/macro/library.scm" . 199687)
           (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 199687)
           (ret.cons "./boot/macro/library.scm" . 199687))
         (call
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 199687)
           (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 199687)
           (push.const)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 199687))
         (push)
         (apply.gloc.of map "./boot/macro/library.scm" . 199687))
       (push)
       (push.iloc 2 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 199687)
       (apply.iloc (3 . 0) "./boot/macro/library.scm" . 199687))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 199687)
       (extend . 1)
       (call
         (touch.gloc.of flatten-library-reference)
         (push.iloc 5 . 0)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 199687)
         (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 199687))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 199687))
       (push)
       (call
         (touch.gloc.of library-reference->version)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->version "./boot/macro/library.scm" . 199687))
       (push)
       (extend . 2)
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of |.require-scheme-library| "./boot/macro/library.scm" . 199687))
       (call
         (touch.gloc.of library-name->id)
         (push.iloc 7 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-name->id "./boot/macro/library.scm" . 199687))
       (push)
       (extend . 1)
       (call
         (call
           (iloc.1 . 1)
           (if.false.ret)
           (call
             (touch.gloc.of scheme-library-versions)
             (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 199687))
           (push)
           (push.iloc.0 . 0)
           (push.const . #f)
           (ret.subr.gloc.of core-hashtable-ref "./boot/macro/library.scm" . 199687))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of test-library-versions)
           (push.iloc 9 . 0)
           (push.iloc 3 . 0)
           (push.iloc 2 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of test-library-versions "./boot/macro/library.scm" . 199687))
         (ret.const.unspec))
       (push.iloc 3 . 0)
       (call
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 199687))
         (push)
         (push.iloc.0 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 199687)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (ret.subr.gloc.of append "./boot/macro/library.scm" . 199687))
         (push.const . import)
         (push.const . "attempt to import undefined library")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 9 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 199687))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 199687))
       (push)
       (apply.iloc (6 . 0) "./boot/macro/library.scm" . 199687))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 4 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 199687))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 199687)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 199687))
   (push.iloc 2 . 1)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 198661))
 (set.gloc.of parse-imports)
 (ret.const.unspec))
((close
   (2 0 . parse-depends)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 261127)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 261127)
       (ret.pair? "./boot/macro/library.scm" . 261127))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 261127)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 261127))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 261127)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 261127)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 261127)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 261127))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 261127)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 261127)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 261127)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 261127))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 261127)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 261127)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 261127)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 261127))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 261127)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 261127)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 261127)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 261127)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 261127)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 261127))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 261127)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 261127)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of flatten-library-reference)
           (push.iloc 3 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
           (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 261127))
         (push)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 261127))
       (push)
       (iloc.1 . 1)
       (push.cons)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 261127))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 3 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 261127))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 261127)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 261127))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 260101))
 (set.gloc.of parse-depends)
 (ret.const.unspec))
((close
   (1 0 . permute-env)
   (touch.gloc.of |loop`8|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 285721)
   (push.const)
   (push.const)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 285705))
 (set.gloc.of |permute-env`2|)
 (close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 287762))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 288796)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 288786))
   (if.true
     (touch.gloc.of |loop`8|)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 289816)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 289839)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 289810))
   (touch.gloc.of |loop`8|)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 291864)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 291880)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 291858))
 (set.gloc.of |loop`8|)
 (close
   (2 0 . expand-library)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.caddr| 1 "./boot/macro/library.scm" . 283653)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/library.scm" . 283653)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 283653)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/library.scm" . 283653)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 283653)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 283653)
     (push.subr.gloc.of |.cdr| 1 "./boot/macro/library.scm" . 283653)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 283653)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cddddr| 1 "./boot/macro/library.scm" . 283653)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 283653)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/library.scm" . 283653)
     (const . export)
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 283653)
     (push.subr.gloc.of |.car| 1 "./boot/macro/library.scm" . 283653)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 283653))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cddddr| 1 "./boot/macro/library.scm" . 283653)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 283653)
     (push.subr.gloc.of |.cdr| 1 "./boot/macro/library.scm" . 283653)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/library.scm" . 283653)
     (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
     (extend . 4)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 283653))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 283653))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 283653))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 283653))
     (call
       (touch.gloc.of parse-exports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of parse-exports "./boot/macro/library.scm" . 283653))
     (push)
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 283653))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 283653))
     (push)
     (extend . 3)
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 283653))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (call
       (subr.gloc.of make-core-hashtable 0)
       (push)
       (extend . 1)
       (push.close
         (1 0)
         (call
           (push.iloc.1 . 0)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
           (push.const . #f)
           (subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 283653)
           (if.false.ret)
           (push.const . library)
           (push.const . "duplicate export identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 6 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 283653))
           (push)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 283653))
         (push.iloc.1 . 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 283653)
         (push.iloc 2 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 283653))
       (push.iloc 2 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 283653))
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 283653)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 283653)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 283653)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (call
             (touch.gloc.of unbound?)
             (push.iloc.0 . 0)
             (apply.gloc.of unbound? "./boot/macro/library.scm" . 283653))
           (if.true
             (push.iloc 2 . 0)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 283653)
             (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 283653)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 283653))
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 283653)
           (if.eq?.ret.const . #t)
           (push.const . library)
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 6 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 283653))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 283653)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 283653))
         (ret.const.unspec))
       (push.iloc.1 . 1)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 283653))
     (call
       (touch.gloc.of |permute-env`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 283653))
     (push)
     (extend . 1)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 283653))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 3 . 1)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 283653))
     (push.close
       (0 0)
       (touch.gloc.of expand-library-body)
       (push.iloc 7 . 0)
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.iloc 6 . 0)
       (push.iloc 4 . 0)
       (push.iloc 4 . 1)
       (push.iloc 4 . 2)
       (call
         (touch.gloc.of extend-env)
         (push.gloc.of private-primitives-environment)
         (push.iloc 2 . 0)
         (apply.gloc.of extend-env "./boot/macro/library.scm" . 283653))
       (push)
       (push.iloc 2 . 0)
       (apply.gloc.of expand-library-body "./boot/macro/library.scm" . 283653))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 283653))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 283653))
   (push.const . library)
   (push.const . "expected library name, export spec, and import spec")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 283653))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 283653))
 (set.gloc.of expand-library)
 (ret.const.unspec))
((close
   (3 0 . check-duplicate-definition)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 357406))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 357389))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 358440))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 358423))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 359446)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 361518)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 361509)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 363566)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 365651)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 365624)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 365624))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 366648))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 364582))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 369718))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 370742))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 368676))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 371734)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 373806)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 373797)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 375854)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 377939)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 377912)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 377912))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 378936))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 376870))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 382033)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 382006)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 382006))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 383057)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 383030)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 383030))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 380964))
   (push.const . library)
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 385046))
 (set.gloc.of |check-duplicate-definition`2|)
 (close
   (1 0)
   (push.const . |.require-scheme-library|)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 392215)
   (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 392215))
 (set.gloc.of |.fn1.1`1|)
 (close
   (9 0 . expand-library-body)
   (extend.unbound . 6)
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/library.scm" . 331797)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/library.scm" . 332823)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 7)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 333866)
       (apply.gloc.of env-lookup "./boot/macro/library.scm" . 333850))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/library.scm" . 334868))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-macro)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/library.scm" . 339988))
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 346126))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 347167))
       (set.iloc 1 . 1)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 348191)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 348179))
     (set.iloc 2 . 7)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 349225)
       (push.iloc 3 . 7)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 349215))
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 349193))
   (push.close
     (2 0 . extend-library-env!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 353319)
       (push.iloc 2 . 8)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 353307))
     (set.iloc 2 . 8)
     (ret.const.unspec))
   (push.close
     (4 0 . rewrite-body)
     (call
       (touch.gloc.of |check-duplicate-definition`2|)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of |check-duplicate-definition`2| "./boot/macro/library.scm" . 389129))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 7)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 390174))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc 3 . 6)
       (apply.gloc.of map "./boot/macro/library.scm" . 392210))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 397380)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 398363))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 398363))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 398385)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 398379)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 398374)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 399411)
             (push.iloc 6 . 7)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 399398))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 400413))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 398363))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 398363))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 398363))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 396306))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 406568))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 410693)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 410683))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 410678)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 411726)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 411734)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 411702))
             (ret.const.unspec))
           (push.iloc 5 . 8)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 412720)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 409638))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 413734))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 406550)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 406550)
       (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 406550)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 415802)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 415796)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 415791)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 417841)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 416817)
           (const . template)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 419881)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 419881)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 419881))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 416817)
           (const . procedure)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 420905)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 420905))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 416817)
           (const . variable)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 421929)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 421929))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 422959))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 406550))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 406550)
       (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 406550))
     (push)
     (push.const . |.intern-scheme-library|)
     (push.const . quote)
     (push.iloc 3 . 1)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 424977)
     (push.const . quote)
     (push.iloc 3 . 2)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 424977)
     (push.const . quote)
     (call
       (push.close
         (1 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 431141)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 432178)
           (push.iloc 2 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 432172)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (touch.gloc.of make-import)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 432223)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 432210))
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 433202)
           (push.iloc 5 . 5)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 433196)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 432165))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 435244))
           (push.const . library)
           (push.const . "attempt to export unbound identifier ~u")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 437360)
           (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 437310)
           (push.iloc 6 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 438334)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 436268))
         (ret.cons "./boot/macro/library.scm" . 430109))
       (push.iloc 3 . 4)
       (apply.gloc.of map "./boot/macro/library.scm" . 391179))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 391179)
     (push.subr.gloc.of |.list| 4 "./boot/macro/library.scm" . 391179)
     (extend . 4)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 440345))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 441376))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 442390))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 444481)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 444489)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 444500))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 444453))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 445469))
         (push.const . #f)
         (push.const . "attempt to reference unbound variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 447535)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 449626)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 449596))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 450620))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 448559))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 446493))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 452621)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 452621)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 452621)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 452621)
     (subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 452621)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 452621))
   (enclose . 5)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 460836)
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 5)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 462919)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 462875))
     (push.iloc.1 . 5)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 462853))
   (extend.enclose
     (4 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 464935)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 464956)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 464947))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 7)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 465962)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 465946))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 7)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 467997))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 467991))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 470039)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 470039)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 470039)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 470039)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 470039)
           (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 470039)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 470039)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 470039))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 470039)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 470039)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 470039)
           (extend . 3)
           (call
             (push.iloc 4 . 5)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 470039)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 470039)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 470039))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 470039)
             (push.iloc.1 . 1)
             (push.iloc 6 . 7)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 470039))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 470039))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 470039))
               (push)
               (apply.iloc (6 . 3) "./boot/macro/library.scm" . 470039))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 470039)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 470039))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 470039))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 470039)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 470039)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 470039))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 470039))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 470039))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 470039)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 470039))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 470039))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 470039)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 470039)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 470039))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 470039))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 7)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 470039))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 470039))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 470039)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 470039))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 470039))
           (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 470039))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 470039)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 470039))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 490561)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 490545))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 490540)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 490574)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 490530))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 5)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 491599)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 491550)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 492638)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 492574))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 493604)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 494659)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 494628))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 495643))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 496692))
           (push)
           (apply.iloc (5 . 3) "./boot/macro/library.scm" . 496667))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 497697)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 497731))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 497691))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 499769)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 499747))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 499781)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 499735))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 500763))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 502811))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 503878)
           (push.iloc 5 . 7)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 503856))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 7)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 505913)
             (push.iloc 5 . 7)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 505898))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 507944)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 507938))
           (call (push.iloc.0 . 0) (apply.iloc (5 . 0) "./boot/macro/library.scm" . 508962))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 510010)
             (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 509992)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 509986))
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 512053)
           (push.iloc 3 . 2)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 512068)
           (push.iloc 3 . 3)
           (apply.iloc (5 . 4) "./boot/macro/library.scm" . 512034))
         (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 465934))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 514090)
       (push.iloc.1 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 514105)
       (push.iloc.1 . 3)
       (apply.iloc (3 . 4) "./boot/macro/library.scm" . 514071))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 516129)
     (push.iloc.0 . 2)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 516144)
     (push.iloc.0 . 3)
     (apply.iloc (2 . 4) "./boot/macro/library.scm" . 516110))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 7)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 463894))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 463877))
 (set.gloc.of expand-library-body)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 521247)
   (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 521270)
   (extend . 2)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/library.scm" . 524313)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/library.scm" . 525341)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 525367))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 526368)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 527410))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/macro/library.scm" . 528450)
   (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 528421))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . import-top-level-bindings)
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/macro/library.scm" . 519171))
 (set.gloc.of import-top-level-bindings)
 (ret.const.unspec))
((close
   (2 0 . expand-import)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/library.scm" . 533514))
     (if.false.ret)
     (push.const . import)
     (push.const . "misplaced top-level directive")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 534538))
   (call
     (touch.gloc.of auto-compile-cache-update)
     (apply.gloc.of auto-compile-cache-update "./boot/macro/library.scm" . 535557))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 538682)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 538650)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.iloc.0 . 0)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 540717)
         (if.eq?.ret.const . #t)
         (push.const . import)
         (push.const . "duplicate import identifiers")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 541788))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 541821)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 541731))
       (push.iloc 2 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 543803)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 543811)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 543770))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc.1 . 0)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 536616)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 536596))
     (push)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 536581))
   (touch.gloc.of import-top-level-bindings)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 545826)
   (apply.gloc.of import-top-level-bindings "./boot/macro/library.scm" . 545799))
 (set.gloc.of expand-import)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (call
       (touch.gloc.of generate-library-id)
       (push.iloc.0 . 0)
       (apply.gloc.of generate-library-id "./boot/macro/library.scm" . 549911))
     (push)
     (extend . 1)
     (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 550954))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 550934)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . pending)
     (if.eq?
       (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 552997))
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 552976)
       (push.const . library)
       (push.const . "encountered cyclic dependencies")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 554000))
     (push.iloc.0 . 0)
     (const . #f)
     (if.eq?
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 558120))
         (push)
         (push.iloc 2 . 0)
         (push.const . pending)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 558099))
       (push.close
         (0 0)
         (touch.gloc.of load-scheme-library)
         (push.iloc 3 . 0)
         (push.const . #f)
         (apply.gloc.of load-scheme-library "./boot/macro/library.scm" . 560147))
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 562225))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 562205)
         (const . pending)
         (if.not.eq?.ret.const . #f)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 563245))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 563224))
       (apply.gloc.of dynamic-wind "./boot/macro/library.scm" . 556048))
     (ret.const.unspec))
   (ret.const.unspec))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.require-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 548867))
((call
   (push.const . equal?)
   (push.subr.gloc.of make-core-hashtable 1 "./boot/macro/library.scm" . 567325)
   (extend . 1)
   (ret.close
     (1 0 . unify-import-bindings)
     (push.close
       (1 0)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 570389)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of values "./boot/macro/library.scm" . 570382))
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 572444)
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/library.scm" . 569351)))
 (set.gloc.of unify-import-bindings)
 (ret.const.unspec))
((close
   (3 0)
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of scheme-library-versions)
       (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 577583))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 577562))
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 578586))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of unify-import-bindings)
     (push.iloc.0 . 2)
     (apply.gloc.of unify-import-bindings "./boot/macro/library.scm" . 578622))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 578565))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.intern-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 575489))
((close
   (1 0)
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 582685))
   (push)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of core-hashtable-delete! "./boot/macro/library.scm" . 582661))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.unintern-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 580609))

;
((close
   (2 0 . extend-env)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/synenv.scm" . 9225))
 (set.gloc.of extend-env)
 (ret.const.unspec))
((close
   (2 0 . env-lookup)
   (call
     (iloc.0 . 1)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error: env-lookup: expect symbol but got ~s")
     (push.iloc.0 . 1)
     (apply.gloc.of scheme-error "./boot/macro/synenv.scm" . 14345))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 15372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of import?)
       (push.cdr.iloc (0 . 0) "./boot/macro/synenv.scm" . 17441)
       (apply.gloc.of import? "./boot/macro/synenv.scm" . 17432))
     (if.true
       (push.cddr.iloc (0 . 0) "./boot/macro/synenv.scm" . 18470)
       (extend . 1)
       (subr.gloc.of current-macro-environment 0)
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 19482))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of cdr "./boot/macro/synenv.scm" . 21528))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 23564))
 (set.gloc.of env-lookup)
 (ret.const.unspec))
((close
   (2 0 . env-delete!)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 27660)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of set-car! 2 "./boot/macro/synenv.scm" . 29713)
     (push.iloc.0 . 0)
     (push.const . no-use)
     (ret.subr.gloc.of set-cdr! "./boot/macro/synenv.scm" . 30737))
   (ret.const.unspec))
 (set.gloc.of env-delete!)
 (ret.const.unspec))
((close
   (2 0 . free-id=?)
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/synenv.scm" . 34832))
   (push)
   (extend . 1)
   (extend.unbound . 2)
   (push.close+
     (2 0 . free-lexical-name=?)
     (call
       (touch.gloc.of original-id)
       (push.iloc.0 . 0)
       (apply.gloc.of original-id "./boot/macro/synenv.scm" . 38933))
     (push)
     (call
       (touch.gloc.of original-id)
       (push.iloc.0 . 1)
       (apply.gloc.of original-id "./boot/macro/synenv.scm" . 38951))
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #t)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 40993))
     (push)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 42017))
     (push)
     (extend . 2)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #t)
     (call
       (push.iloc.1 . 0)
       (iloc.0 . 0)
       (if.eq?.ret.const . #t)
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 44083))
     (if.false.ret)
     (push.iloc.1 . 1)
     (iloc.0 . 1)
     (if.eq?.ret.const . #t)
     (touch.gloc.of unbound?)
     (push.iloc.0 . 1)
     (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 45107))
   (push.close
     (1 0 . lexical-name)
     (iloc.0 . 0)
     (if.symbol?
       (touch.gloc.of lookup-lexical-name)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 50191))
     (call
       (touch.gloc.of syntax-object-lexname)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-lexname "./boot/macro/synenv.scm" . 51219))
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/synenv.scm" . 52264))
     (push)
     (push.iloc 2 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 52243))
   (enclose . 2)
   (call (push.iloc 2 . 0) (apply.iloc (0 . 1) "./boot/macro/synenv.scm" . 54300))
   (push)
   (call (push.iloc 2 . 1) (apply.iloc (0 . 1) "./boot/macro/synenv.scm" . 54319))
   (push)
   (apply.iloc+ (0 . 0) "./boot/macro/synenv.scm" . 54279))
 (set.gloc.of free-id=?)
 (ret.const.unspec))
((close
   (1 0 . make-import)
   (push.const . import)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 58373))
 (set.gloc.of make-import)
 (ret.const.unspec))
((close (0 0 . make-unbound) (ret.const unbound)) (set.gloc.of make-unbound) (ret.const.unspec))
((close
   (1 0 . make-out-of-context)
   (iloc.0 . 0)
   (if.true (push.const . out-of-context) (iloc.0 . 0) (ret.cons "./boot/macro/synenv.scm" . 67593))
   (ret.const out-of-context . #f))
 (set.gloc.of make-out-of-context)
 (ret.const.unspec))
((close
   (1 0 . make-pattern-variable)
   (push.const . pattern-variable)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 72709))
 (set.gloc.of make-pattern-variable)
 (ret.const.unspec))
((close
   (2 0 . make-macro)
   (push.const . macro)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 76805))
 (set.gloc.of make-macro)
 (ret.const.unspec))
((close
   (2 0 . make-macro-variable)
   (push.const . macro-variable)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 80901))
 (set.gloc.of make-macro-variable)
 (ret.const.unspec))
((close
   (1 0 . make-special)
   (push.const . special)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 84997))
 (set.gloc.of make-special)
 (ret.const.unspec))
((close
   (1 0 . import?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 90127)
   (const . import)
   (ret.eq? "./boot/macro/synenv.scm" . 90122))
 (set.gloc.of import?)
 (ret.const.unspec))
((close
   (1 0 . unbound?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 95247)
   (const . unbound)
   (ret.eq? "./boot/macro/synenv.scm" . 95242))
 (set.gloc.of unbound?)
 (ret.const.unspec))
((close
   (1 0 . out-of-context?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 100367)
   (const . out-of-context)
   (ret.eq? "./boot/macro/synenv.scm" . 100362))
 (set.gloc.of out-of-context?)
 (ret.const.unspec))
((close
   (1 0 . macro?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 105491)
   (const . macro)
   (if.eq?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 106515)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 106510))
 (set.gloc.of macro?)
 (ret.const.unspec))
((close
   (1 0 . macro-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 111631)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 111626))
 (set.gloc.of macro-variable?)
 (ret.const.unspec))
((close
   (1 0 . pattern-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 116751)
   (const . pattern-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 116746))
 (set.gloc.of pattern-variable?)
 (ret.const.unspec))
((close
   (1 0 . special?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 121871)
   (const . special)
   (ret.eq? "./boot/macro/synenv.scm" . 121866))
 (set.gloc.of special?)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 125975)
   (push.const . "unquote appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 125957))
 (set.gloc.of unexpected-unquote)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote-splicing)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 130071)
   (push.const . "unquote-splicing appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 130053))
 (set.gloc.of unexpected-unquote-splicing)
 (ret.const.unspec))
((close
   (2 0 . unexpected-auxiliary-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 134167)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 134149))
 (set.gloc.of unexpected-auxiliary-syntax)
 (ret.const.unspec))
((close
   (2 0 . unexpected-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 138263)
   (push.const . "misplaced syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 138245))
 (set.gloc.of unexpected-syntax)
 (ret.const.unspec))
((subr.gloc.of make-core-hashtable 0 "./boot/macro/synenv.scm" . 140306)
 (set.gloc.of core-env)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . lambda)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-lambda)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 142386))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 142337))
((push.gloc.of core-env)
 (push.const . quote)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-quote)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 143410))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 143361))
((push.gloc.of core-env)
 (push.const . if)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-if)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 144434))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 144385))
((push.gloc.of core-env)
 (push.const . set!)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-set!)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 145458))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 145409))
((push.gloc.of core-env)
 (push.const . define-syntax)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-define-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 146482))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 146433))
((push.gloc.of core-env)
 (push.const . let-syntax)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-let-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 147506))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 147457))
((push.gloc.of core-env)
 (push.const . letrec-syntax)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-letrec-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 148530))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 148481))
((push.gloc.of core-env)
 (push.const . begin)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-begin)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 149554))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 149505))
((push.gloc.of core-env)
 (push.const . define)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-define)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 150578))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 150529))
((push.gloc.of core-env)
 (push.const . quasiquote)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-quasiquote)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 151602))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 151553))
((push.gloc.of core-env)
 (push.const . let)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-let)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 152626))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 152577))
((push.gloc.of core-env)
 (push.const . letrec)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-letrec)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 153650))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 153601))
((push.gloc.of core-env)
 (push.const . let*)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-let*)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 154674))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 154625))
((push.gloc.of core-env)
 (push.const . cond)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-cond)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 155698))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 155649))
((push.gloc.of core-env)
 (push.const . case)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-case)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 156722))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 156673))
((push.gloc.of core-env)
 (push.const . do)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-do)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 157746))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 157697))
((push.gloc.of core-env)
 (push.const . and)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-and)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 158770))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 158721))
((push.gloc.of core-env)
 (push.const . or)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-or)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 159794))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 159745))
((push.gloc.of core-env)
 (push.const . letrec*)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-letrec*)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 160818))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 160769))
((push.gloc.of core-env)
 (push.const . library)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-library)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 161842))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 161793))
((push.gloc.of core-env)
 (push.const . define-macro)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-define-macro)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 162866))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 162817))
((push.gloc.of core-env)
 (push.const . let*-values)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-let*-values)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 163890))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 163841))
((push.gloc.of core-env)
 (push.const . let-values)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-let-values)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 164914))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 164865))
((push.gloc.of core-env)
 (push.const . syntax)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 165938))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 165889))
((push.gloc.of core-env)
 (push.const . syntax-case)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-syntax-case)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 166962))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 166913))
((push.gloc.of core-env)
 (push.const . identifier-syntax)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-identifier-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 167986))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 167937))
((push.gloc.of core-env)
 (push.const . assert)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-assert)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 169010))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 168961))
((push.gloc.of core-env)
 (push.const . unquote)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of unexpected-unquote)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 170034))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 169985))
((push.gloc.of core-env)
 (push.const . unquote-splicing)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of unexpected-unquote-splicing)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 171058))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 171009))
((push.gloc.of core-env)
 (push.const . syntax-rules)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of unexpected-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 172082))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 172033))
((push.gloc.of core-env)
 (push.const . else)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of unexpected-auxiliary-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 173106))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 173057))
((push.gloc.of core-env)
 (push.const . =>)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of unexpected-auxiliary-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 174130))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 174081))
((push.gloc.of core-env)
 (push.const . ...)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of unexpected-auxiliary-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 175154))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 175105))
((push.gloc.of core-env)
 (push.const . _)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of unexpected-auxiliary-syntax)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 176178))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 176129))
((push.gloc.of core-env)
 (push.const . import)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-import)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 177202))
 (push)
 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 177153))
((push.gloc.of core-env)
 (push.const . lambda)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 179233)
 (set.gloc.of denote-lambda)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . begin)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 180257)
 (set.gloc.of denote-begin)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 181281)
 (set.gloc.of denote-define)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 182305)
 (set.gloc.of denote-define-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 183329)
 (set.gloc.of denote-let-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 184353)
 (set.gloc.of denote-letrec-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-macro)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 185377)
 (set.gloc.of denote-define-macro)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . library)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 186401)
 (set.gloc.of denote-library)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quasiquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 187425)
 (set.gloc.of denote-quasiquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 188449)
 (set.gloc.of denote-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . if)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 189473)
 (set.gloc.of denote-if)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . set!)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 190497)
 (set.gloc.of denote-set!)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 191521)
 (set.gloc.of denote-unquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote-splicing)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 192545)
 (set.gloc.of denote-unquote-splicing)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 193569)
 (set.gloc.of denote-let)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 194593)
 (set.gloc.of denote-letrec)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 195617)
 (set.gloc.of denote-let*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . cond)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 196641)
 (set.gloc.of denote-cond)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 197665)
 (set.gloc.of denote-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . do)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 198689)
 (set.gloc.of denote-do)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . and)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 199713)
 (set.gloc.of denote-and)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . or)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 200737)
 (set.gloc.of denote-or)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 201761)
 (set.gloc.of denote-letrec*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 202785)
 (set.gloc.of denote-let*-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 203809)
 (set.gloc.of denote-let-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 204833)
 (set.gloc.of denote-syntax-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 205857)
 (set.gloc.of denote-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 206881)
 (set.gloc.of denote-syntax-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-rules)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 207905)
 (set.gloc.of denote-syntax-rules)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . else)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 208929)
 (set.gloc.of denote-else)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . =>)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 209953)
 (set.gloc.of denote-=>)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . import)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 210977)
 (set.gloc.of denote-import)
 (ret.const.unspec))
((close
   (2 0 . denote-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of macro?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 216082))
   (push)
   (apply.gloc.of macro? "./boot/macro/synenv.scm" . 216074))
 (set.gloc.of denote-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-special?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of special?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 221204))
   (push)
   (apply.gloc.of special? "./boot/macro/synenv.scm" . 221194))
 (set.gloc.of denote-special?)
 (ret.const.unspec))
((close
   (2 0 . denote-lambda?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 226319))
   (push)
   (gloc.of denote-lambda)
   (ret.eq? "./boot/macro/synenv.scm" . 226314))
 (set.gloc.of denote-lambda?)
 (ret.const.unspec))
((close
   (2 0 . denote-begin?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 231439))
   (push)
   (gloc.of denote-begin)
   (ret.eq? "./boot/macro/synenv.scm" . 231434))
 (set.gloc.of denote-begin?)
 (ret.const.unspec))
((close
   (2 0 . denote-let?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 236559))
   (push)
   (gloc.of denote-let)
   (ret.eq? "./boot/macro/synenv.scm" . 236554))
 (set.gloc.of denote-let?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 241679))
   (push)
   (gloc.of denote-define-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 241674))
 (set.gloc.of denote-define-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-let-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 246799))
   (push)
   (gloc.of denote-let-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 246794))
 (set.gloc.of denote-let-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-letrec-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 251919))
   (push)
   (gloc.of denote-letrec-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 251914))
 (set.gloc.of denote-letrec-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-define?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 257039))
   (push)
   (gloc.of denote-define)
   (ret.eq? "./boot/macro/synenv.scm" . 257034))
 (set.gloc.of denote-define?)
 (ret.const.unspec))
((close
   (2 0 . denote-quote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 262159))
   (push)
   (gloc.of denote-quote)
   (ret.eq? "./boot/macro/synenv.scm" . 262154))
 (set.gloc.of denote-quote?)
 (ret.const.unspec))
((close
   (2 0 . denote-quasiquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 267279))
   (push)
   (gloc.of denote-quasiquote)
   (ret.eq? "./boot/macro/synenv.scm" . 267274))
 (set.gloc.of denote-quasiquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 272399))
   (push)
   (gloc.of denote-unquote)
   (ret.eq? "./boot/macro/synenv.scm" . 272394))
 (set.gloc.of denote-unquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote-splicing?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 277519))
   (push)
   (gloc.of denote-unquote-splicing)
   (ret.eq? "./boot/macro/synenv.scm" . 277514))
 (set.gloc.of denote-unquote-splicing?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 282639))
   (push)
   (gloc.of denote-define-macro)
   (ret.eq? "./boot/macro/synenv.scm" . 282634))
 (set.gloc.of denote-define-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-syntax-rules?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 287759))
   (push)
   (gloc.of denote-syntax-rules)
   (ret.eq? "./boot/macro/synenv.scm" . 287754))
 (set.gloc.of denote-syntax-rules?)
 (ret.const.unspec))
((close
   (2 0 . denote-else?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 292879))
   (push)
   (gloc.of denote-else)
   (ret.eq? "./boot/macro/synenv.scm" . 292874))
 (set.gloc.of denote-else?)
 (ret.const.unspec))
((close
   (2 0 . denote-=>?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 297999))
   (push)
   (gloc.of denote-=>)
   (ret.eq? "./boot/macro/synenv.scm" . 297994))
 (set.gloc.of denote-=>?)
 (ret.const.unspec))
((close
   (2 0 . denote-set!?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 303119))
   (push)
   (gloc.of denote-set!)
   (ret.eq? "./boot/macro/synenv.scm" . 303114))
 (set.gloc.of denote-set!?)
 (ret.const.unspec))
((push.const . |.LIST|)
 (const . |.list|)
 (push.cons)
 (push.const . |.CONS|)
 (const . |.cons|)
 (push.cons)
 (push.const . |.CONS*|)
 (const . |.cons*|)
 (push.cons)
 (push.const . |.APPEND|)
 (const . |.append|)
 (push.cons)
 (push.const . |.VECTOR|)
 (const . |.vector|)
 (push.cons)
 (push.const . |.LIST->VECTOR|)
 (const . |.list->vector|)
 (push.cons)
 (push.const . |.EQ?|)
 (const . |.eq?|)
 (push.cons)
 (push.const . |.EQV?|)
 (const . |.eqv?|)
 (push.cons)
 (push.const . |.MEMQ|)
 (const . |.memq|)
 (push.cons)
 (push.const . |.MEMV|)
 (const . |.memv|)
 (push.cons)
 (push.const . |.CALL-WITH-VALUES|)
 (const . |.call-with-values|)
 (push.cons)
 (push.const . |.APPLY|)
 (const . |.apply|)
 (push.cons)
 (push.const . |.CDR|)
 (const . |.cdr|)
 (push.cons)
 (push.const . |.IDENTIFIER?|)
 (const . |.identifier?|)
 (push.cons)
 (push.const . |.MAKE-VARIABLE-TRANSFORMER|)
 (const . |.make-variable-transformer|)
 (push.cons)
 (push.const . |.ASSERTION-VIOLATION|)
 (const . |.assertion-violation|)
 (push.cons)
 (push.const . |.UNSPECIFIED|)
 (const . |.unspecified|)
 (push.cons)
 (push.const . |.QUOTE|)
 (gloc.of denote-quote)
 (push.cons)
 (push.const . |.LET|)
 (gloc.of denote-let)
 (push.cons)
 (push.const . |.LETREC*|)
 (gloc.of denote-letrec*)
 (push.cons)
 (push.const . |.BEGIN|)
 (gloc.of denote-begin)
 (push.cons)
 (push.const . |.LAMBDA|)
 (gloc.of denote-lambda)
 (push.cons)
 (push.const . |.IF|)
 (gloc.of denote-if)
 (push.cons)
 (push.const . |.SET!|)
 (gloc.of denote-set!)
 (push.cons)
 (push.const . |.OR|)
 (gloc.of denote-or)
 (push.cons)
 (push.const . |.COND|)
 (gloc.of denote-cond)
 (push.cons)
 (push.const . |.ELSE|)
 (gloc.of denote-else)
 (push.cons)
 (push.const . |.DEFINE-SYNTAX|)
 (gloc.of denote-define-syntax)
 (push.cons)
 (push.const . |.SYNTAX|)
 (gloc.of denote-syntax)
 (push.cons)
 (push.const . |.SYNTAX-CASE|)
 (gloc.of denote-syntax-case)
 (push.cons)
 (subr.gloc.of list 30 "./boot/macro/synenv.scm" . 306179)
 (set.gloc.of private-primitives-environment)
 (ret.const.unspec))
((push.gloc.of core-env)
 (ret.subr.gloc.of current-macro-environment "./boot/macro/synenv.scm" . 338945))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/compile.scm" . 5147))
 (set.gloc.of ht-local-closures)
 (ret.const.unspec))
((close
   (1 0 . local-closure?)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/compile.scm" . 9248))
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 9228)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 10273)
     (push.const stack)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 10267))
   (ret.const . #f))
 (set.gloc.of local-closure?)
 (ret.const.unspec))
((close
   (1 0)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 16413)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 17435)
   (const . lambda)
   (if.not.eq?.ret.const . #f)
   (call
     (touch.gloc.of local-closure?)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 18470)
     (apply.gloc.of local-closure? "./boot/compile.scm" . 18454))
   (if.false.ret)
   (call
     (touch.gloc.of ht-local-closures)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 19499))
   (push)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 19519)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 19478))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . collect-local-closure)
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/compile.scm" . 15365))
 (set.gloc.of collect-local-closure)
 (ret.const.unspec))
((close
   (1 0 . make-application-comment)
   (subr.gloc.of backtrace 0 "./boot/compile.scm" . 24585)
   (if.true
     (subr.gloc.of current-source-comments 0 "./boot/compile.scm" . 25616)
     (if.true
       (subr.gloc.of current-source-comments 0)
       (push)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 27676)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 29733)
         (if.true
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . |.&SOURCE-PATH|)
           (push.const . #f)
           (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 30766)
           (push.iloc.0 . 0)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 30834)
           (ret.subr.gloc.of |.cons*| "./boot/compile.scm" . 29729))
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . |.&SOURCE-PATH|)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 31784)
         (iloc.0 . 0)
         (ret.cons "./boot/compile.scm" . 29729))
       (push.iloc.1 . 0)
       (ret.subr.gloc.of list "./boot/compile.scm" . 33820))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 35856))
   (ret.const))
 (set.gloc.of make-application-comment)
 (ret.const.unspec))
((close
   (1 0 . make-closure-comment)
   (call
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 40977))
     (if.false.ret)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 42021))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (ret.subr.gloc.of core-hashtable-ref "./boot/compile.scm" . 42001))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/compile.scm" . 40965))
   (ret.const))
 (set.gloc.of make-closure-comment)
 (ret.const.unspec))
((close
   (1 0 . top-level-subr)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 49162)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 50193)
   (subr.gloc.of subr? 1 "./boot/compile.scm" . 50186)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 51210))
 (set.gloc.of top-level-subr)
 (ret.const.unspec))
((close
   (1 0 . top-level-value-or-false)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 56330)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 57354))
 (set.gloc.of top-level-value-or-false)
 (ret.const.unspec))
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 62479)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 62504)
       (apply.gloc.of formals->list "./boot/compile.scm" . 62489))
     (ret.cons "./boot/compile.scm" . 62473))
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/compile.scm" . 64533))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . make-formals-operand)
   (push.iloc.0 . 1)
   (subr.gloc.of list? 1 "./boot/compile.scm" . 68620)
   (if.true
     (push.iloc.0 . 1)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 68642)
     (push.const . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 68636))
   (iloc.0 . 1)
   (if.pair?
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 69669)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/compile.scm" . 69666)
     (push.const . 1)
     (ret.subr.gloc.of list "./boot/compile.scm" . 69660))
   (ret.const 0 1))
 (set.gloc.of make-formals-operand)
 (ret.const.unspec))
((close
   (2 0 . make-iloc-operand)
   (extend.enclose+
     (2 0 . loop1)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 76824)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 76816)
     (if.true
       (push.iloc.0 . 1)
       (call
         (extend.enclose+
           (2 0 . loop2)
           (push.car.iloc (0 . 0) "./boot/compile.scm" . 79905)
           (iloc 4 . 0)
           (if.eq? (ret.iloc 0 . 1))
           (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 81955)
           (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 81966)
           (apply.iloc+ (1 . 0) "./boot/compile.scm" . 81948))
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 78888)
         (push.const . 0)
         (apply.iloc+ (0 . 0) "./boot/compile.scm" . 78870))
       (ret.cons "./boot/compile.scm" . 75783))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 82967)
     (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 82978)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 82960))
   (push.iloc.1 . 1)
   (push.const . 0)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 74757))
 (set.gloc.of make-iloc-operand)
 (ret.const.unspec))
((close
   (3 0 . iloc-iota)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 89102)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/compile.scm" . 90137)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of + 2 "./boot/compile.scm" . 90167)
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 90131))
   (push.n+.iloc (1 . 2) -1 "./boot/compile.scm" . 88087)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 88069))
 (set.gloc.of iloc-iota)
 (ret.const.unspec))
((close
   (2 0 . cte-extend-iloc)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (ret.cons "./boot/compile.scm" . 94213))
 (set.gloc.of cte-extend-iloc)
 (ret.const.unspec))
((close
   (2 0 . iloc?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 101405)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 101397)
     (if.true.ret)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 102427)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 102421))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 99338))
 (set.gloc.of iloc?)
 (ret.const.unspec))
((close
   (1 0 . immediate-literal?)
   (push.iloc.0 . 0)
   (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 106505)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of char? 1 "./boot/compile.scm" . 106517)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of boolean? 1 "./boot/compile.scm" . 106527)
   (if.true.ret)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 107549)
   (const . quote)
   (if.not.eq?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 107574)
   (ret.subr.gloc.of symbol? "./boot/compile.scm" . 107565))
 (set.gloc.of immediate-literal?)
 (ret.const.unspec))
((close
   (2 0 . compile-touch)
   (call
     (iloc.0 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 113686)
     (if.true.ret.const . #f)
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 114710))
     (push)
     (ret.subr.gloc.of not "./boot/compile.scm" . 114705))
   (if.true
     (push.const . touch.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 112651)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 112651))
   (ret.const))
 (set.gloc.of compile-touch)
 (ret.const.unspec))
((close
   (4 0 . compile-lambda-helper)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/compile.scm" . 120849))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of cte-extend-iloc)
     (push.iloc.0 . 0)
     (push.iloc.1 . 3)
     (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 121874))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of make-formals-operand)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of make-formals-operand "./boot/compile.scm" . 122900))
   (push)
   (push.iloc 2 . 2)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 122892)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 123918))
   (ret.cons "./boot/compile.scm" . 121863))
 (set.gloc.of compile-lambda-helper)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 128027))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of cons)
     (push.gloc.of =)
     (push.gloc.of <)
     (push.gloc.of <=)
     (push.gloc.of >)
     (push.gloc.of >=)
     (push.gloc.of eq?)
     (push.gloc.of null?)
     (push.gloc.of pair?)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of eqv?)
     (push.gloc.of equal?)
     (push.subr.gloc.of list 18 "./boot/compile.scm" . 129039)
     (apply.gloc.of for-each "./boot/compile.scm" . 128005))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 130053))
 (set.gloc.of ht-special-subr-expression)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 133123)
 (set.gloc.of alist-special-binary-subr)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 136195)
 (set.gloc.of alist-special-binary-subr-negate)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 139267)
 (set.gloc.of alist-special-binary-subr-iloc)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 142339)
 (set.gloc.of alist-special-binary-subr-iloc-negate)
 (ret.const.unspec))
((close
   (4 0 . compile-anonymous)
   (iloc.0 . 2)
   (if.true
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 150568)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 150545))
     (push)
     (push.const . ret.subr.gloc.of)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 150603)
     (push.iloc.0 . 3)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 149513)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 149513)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 149513))
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151592)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 151569))
   (push)
   (push.const . subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 151623)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151643)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 151635)
   (push.iloc.0 . 3)
   (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 149513)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 149513)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 149513))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (4 0 . compile-subr-expression)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 153620))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 154660)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 154643)
   (extend . 1)
   (push.gloc.of ht-special-subr-expression)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 155661)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 156699)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (iloc 2 . 2)
         (if.true.ret.const)
         (iloc 2 . 3)
         (if.true
           (push.const . ret.const.unspec)
           (push.subr.gloc.of list 1 "./boot/compile.scm" . 159789)
           (ret.subr.gloc.of list "./boot/compile.scm" . 159783))
         (push.const . const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 160813)
         (ret.subr.gloc.of list "./boot/compile.scm" . 160807))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 161824))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 162843)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of pair?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 165943)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 165923))
           (push)
           (push.const . ret.pair?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 164894)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 164894))
         (push.iloc.0 . 0)
         (gloc.of null?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 167991)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 167971))
           (push)
           (push.const . ret.null?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 166942)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 166942))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 170015))
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 171043)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 171036))
       (if.true
         (iloc 2 . 2)
         (if.true.ret.const)
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 175178)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 175159))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 174121)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 174121))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 177226)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 177207))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 176169)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 176169))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 179275)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 179256))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 178217)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 178217))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 181323)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 181304))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 180265)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 180265))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 183338))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 184348))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 185371)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of cons)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 188469)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 188451))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 188508)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 188488))
           (push)
           (push.const . ret.cons)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 187422)
           (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 187422)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 187422))
         (push.iloc.0 . 0)
         (gloc.of eq?)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 190517)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 190499))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 190556)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 190536))
           (push)
           (push.const . ret.eq?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 189470)
           (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 189470)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 189470))
         (push.iloc.0 . 0)
         (gloc.of eqv?)
         (if.eq?
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 192574)
           (extend . 1)
           (call
             (call
               (touch.gloc.of immediate-literal?)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 192555)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193577))
             (if.true.ret)
             (touch.gloc.of immediate-literal?)
             (push.iloc.0 . 0)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193603))
           (if.true
             (call
               (touch.gloc.of compile-argument)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 194619)
               (push.iloc 3 . 1)
               (apply.gloc.of compile-argument "./boot/compile.scm" . 194601))
             (push)
             (call
               (touch.gloc.of compile-expression)
               (push.iloc 3 . 0)
               (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 194658)
               (push.iloc 3 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 194638))
             (push)
             (push.const . ret.eq?)
             (iloc 2 . 0)
             (push.cons)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 193569)
             (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 193569)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 193569))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.iloc 2 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 195621))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 197663))
       (push.iloc.0 . 0)
       (push.gloc.of alist-special-binary-subr)
       (subr.gloc.of assq 2 "./boot/compile.scm" . 198687)
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 199723)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 199742)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 201787)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 201817))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 201858)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 201853)
             (ret.subr.gloc.of values "./boot/compile.scm" . 201835))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 202811)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 202841))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 202882)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 202877)
             (ret.subr.gloc.of values "./boot/compile.scm" . 202859))
           (push.const . #f)
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 203835))
         (push.close
           (3 0)
           (iloc.0 . 2)
           (if.true
             (push.iloc.0 . 2)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 204857))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 204841)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 204841))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 205866))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 206894))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 206937)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 206932)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 206982))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 205865)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 205865)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 205865))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 207914))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 208942))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 208985)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 208980)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 209037))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 207913)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 207913)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 207913))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 209967))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 199711))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 213035)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 213054)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 214085)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 214115))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 214133))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 215109)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 215139))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 215157))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 216133))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 218163))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 217123)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 217123))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 219175))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 213023))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 221227)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 221246)
         (extend . 2)
         (call
           (push.iloc.0 . 1)
           (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 222250)
           (if.false.ret)
           (iloc.0 . 0)
           (if.not.symbol?.ret.const . #f)
           (touch.gloc.of iloc?)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of iloc? "./boot/compile.scm" . 222280))
         (if.true
           (push.const . n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 223281))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 223311)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 222241)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 222241))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 3)
         (push.iloc 2 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 224293))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 227359))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 3)
     (push.iloc.1 . 0)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 229396))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc 2 . 3)
   (push.iloc.1 . 0)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 230413))
 (set.gloc.of compile-subr-expression)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 234523))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of cons)
     (push.subr.gloc.of list 8 "./boot/compile.scm" . 235535)
     (apply.gloc.of for-each "./boot/compile.scm" . 234501))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 236549))
 (set.gloc.of ht-special-subr-argument)
 (ret.const.unspec))
((close
   (3 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243748)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 243725))
   (push)
   (push.const . push.subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 243784)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243804)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 243796)
   (push.iloc.0 . 2)
   (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 242695)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 242695)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 242695))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (2 0 . compile-subr-argument)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 245780))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 246820)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 246803)
   (extend . 1)
   (push.gloc.of ht-special-subr-argument)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 247821)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 248859)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (push.const . push.const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 249912)
         (ret.subr.gloc.of list "./boot/compile.scm" . 249906))
       (push.const . subr.gloc.of)
       (push.car.iloc (2 . 0) "./boot/compile.scm" . 251948)
       (push.const 0)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 250906)
       (push.const . push)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 251963)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 250906))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 252955)
     (if.null?
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 253983)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 253976))
       (if.true
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . push.car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 255059)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 255040))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 255006)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 255006))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . push.cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 256083)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 256064))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 256030)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 256030))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . push.cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 257109)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 257090))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 257054)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 257054))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . push.cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 258133)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 258114))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 258078)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 258078))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 259108))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 260120))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 261147)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of cons)
       (if.eq?
         (call
           (touch.gloc.of compile-argument)
           (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 263217)
           (push.iloc 2 . 1)
           (apply.gloc.of compile-argument "./boot/compile.scm" . 263199))
         (push)
         (call
           (touch.gloc.of compile-expression)
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 263256)
           (push.iloc 2 . 1)
           (push.const . #f)
           (push.const . #f)
           (apply.gloc.of compile-expression "./boot/compile.scm" . 263236))
         (push)
         (push.const . push.cons)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 263281)
         (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 262170)
         (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 262170)
         (ret.subr.gloc.of |.append| "./boot/compile.scm" . 262170))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 265255)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 265274)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 266305))
             (if.false.ret)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 266322))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 266338))
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 267329))
             (if.false.ret)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 267346))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 267362))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 268353))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . push.n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 270388))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 269343)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 269343))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 271395))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 265243))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 273447)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 273466)
         (extend . 2)
         (call
           (call
             (touch.gloc.of iloc?)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 274470))
           (if.false.ret)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 274487))
         (if.true
           (push.const . push.n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 275506))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 275536)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 274461)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 274461))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 2 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 276513))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 278555))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 280596))
   (cdr.iloc (2 . 0) "./boot/compile.scm" . 281624)
   (if.null?
     (push.const . subr.gloc.of)
     (push.car.iloc (2 . 0) "./boot/compile.scm" . 282658)
     (push.const 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 281613)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 282673)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 281613))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 283665))
 (set.gloc.of compile-subr-argument)
 (ret.const.unspec))
((close
   (2 0 . compile-argument-each)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.gloc.of append)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 288808)
       (apply.gloc.of apply "./boot/compile.scm" . 288794))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 291862)
     (call
       (touch.gloc.of compile-argument)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 290857)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 290839))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 291856))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 287749))
 (set.gloc.of compile-argument-each)
 (ret.const.unspec))
((close
   (2 0 . compile-argument)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 296995)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 296979))
     (if.true
       (touch.gloc.of compile-subr-argument)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-subr-argument "./boot/compile.scm" . 298003))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 299032)
     (const . lambda)
     (if.eq?
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 300086)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 300098)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 300110))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 300063))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of local-closure?)
         (push.iloc.1 . 0)
         (apply.gloc.of local-closure? "./boot/compile.scm" . 301081))
       (if.true
         (push.const . push.close+)
         (iloc.0 . 0)
         (push.cons)
         (ret.subr.gloc.of list "./boot/compile.scm" . 302105))
       (push.const . push.close)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 303129))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 304152)
     (const . quote)
     (if.eq?
       (push.const . push.const)
       (cadr.iloc (0 . 0) "./boot/compile.scm" . 305188)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 304146))
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 307223))
     (push)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 307260)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 306194)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 306194))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (const . |.&UNDEF|)
     (if.eq?
       (push.const . push.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 309293)
       (ret.subr.gloc.of list "./boot/compile.scm" . 309287))
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 311319))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 312354))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 313375)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . push.iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 314418)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 314395))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . push.iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 315442)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 315419))
       (push.const . push.iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 316443))
     (push.const . push.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 311315)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 311315))
   (push.const . push.const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 318475))
 (set.gloc.of compile-argument)
 (ret.const.unspec))
((close
   (4 0 . compile-call)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 324624))
     (push)
     (push.const . apply)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 324661)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 323595)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 323595))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of iloc? "./boot/compile.scm" . 326675))
     (if.true
       (call
         (touch.gloc.of ht-local-closures)
         (apply.gloc.of ht-local-closures "./boot/compile.scm" . 327729))
       (push)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 327703)
       (if.true
         (push.const . apply.iloc+)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 3)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 328743))
         (push)
         (push.iloc.0 . 2)
         (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 327699)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 327699))
       (push.const . apply.iloc)
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 329766))
       (push)
       (push.iloc.0 . 2)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 327699)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 327699))
     (call
       (touch.gloc.of top-level-subr)
       (push.iloc.0 . 0)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 330771))
     (if.true
       (push.const . ret.subr.gloc.of)
       (push.iloc.0 . 0)
       (push.iloc.0 . 2)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 330770)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 330770))
     (push.const . apply.gloc.of)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 332818)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 332818))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (push.const . apply)
   (iloc.0 . 2)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 334859))
 (set.gloc.of compile-call)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-begin)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 339985)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?
     (iloc.1 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 342045)
       (ret.subr.gloc.of list "./boot/compile.scm" . 342039))
     (ret.const))
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 343061)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 344098)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 344078))
   (touch.gloc.of compile-expression-seq)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 346126))
 (set.gloc.of compile-expression-begin)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-quote)
   (iloc.0 . 2)
   (if.true.ret.const)
   (iloc.0 . 3)
   (if.true
     (push.const . ret.const)
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 352269))
   (push.const . const)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 353293))
 (set.gloc.of compile-expression-quote)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-define)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 357413)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 357393))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 359454)
   (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 357381)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 358434)
       (ret.subr.gloc.of list "./boot/compile.scm" . 358428))
     (ret.const))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 357381))
 (set.gloc.of compile-expression-define)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-set!)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 363557)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 363537))
   (push)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 364578)
       (ret.subr.gloc.of list "./boot/compile.scm" . 364572))
     (ret.const))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of iloc?)
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 365589)
     (push.iloc.1 . 1)
     (apply.gloc.of iloc? "./boot/compile.scm" . 365582))
   (if.true
     (push.iloc.0 . 0)
     (push.const . set.iloc)
     (call
       (touch.gloc.of make-iloc-operand)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 366646)
       (push.iloc.1 . 1)
       (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 366627))
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 365581))
   (push.iloc.0 . 0)
   (call
     (subr.gloc.of backtrace 0 "./boot/compile.scm" . 368671)
     (if.true
       (touch.gloc.of compile-touch)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 368698)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-touch "./boot/compile.scm" . 368683))
     (ret.const))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 369711)
   (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 368654)
   (iloc.0 . 1)
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 368654)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 368654))
 (set.gloc.of compile-expression-set!)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-lambda)
   (call
     (touch.gloc.of compile-lambda-helper)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 373800)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 373812)
     (call
       (touch.gloc.of make-closure-comment)
       (push.iloc.0 . 0)
       (apply.gloc.of make-closure-comment "./boot/compile.scm" . 373824))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 373777))
   (push)
   (extend . 1)
   (iloc.1 . 2)
   (if.true.ret.const)
   (iloc.1 . 3)
   (if.true
     (push.const . ret.close)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 375821))
   (push.const . close)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 376845))
 (set.gloc.of compile-expression-lambda)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-let)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 380947)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 381988)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 381964))
   (call
     (touch.gloc.of collect-local-closure)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 384035)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 384012))
   (call
     (push.gloc.of car)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 385057)
     (apply.gloc.of map "./boot/compile.scm" . 385048))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of compile-argument-each)
     (call
       (push.gloc.of cadr)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 386111)
       (apply.gloc.of map "./boot/compile.scm" . 386101))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 386078))
   (push)
   (push.const . extend)
   (push.iloc.0 . 0)
   (subr.gloc.of length 1 "./boot/compile.scm" . 387113)
   (push.cons)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (1 . 0) "./boot/compile.scm" . 388152)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 388164))
     (push)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 388128))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 386068)
   (extend . 1)
   (iloc 2 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 389150))
 (set.gloc.of compile-expression-let)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 1)
   (push.const . set.iloc)
   (iloc.0 . 0)
   (push.cons)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 426038)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 426038))
 (set.gloc.of |.fn1.1`1|)
 (close
   (4 0 . compile-expression-letrec*)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 393235)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 394276)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 394252))
   (push.iloc.0 . 0)
   (subr.gloc.of cdadr 1 "./boot/compile.scm" . 395283)
   (if.null?
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 396315)
     (extend . 1)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 397360)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 397354)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 397337))
     (push)
     (extend . 1)
     (call
       (cadr.iloc (1 . 0) "./boot/compile.scm" . 398371)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 398392)
       (const . lambda)
       (ret.eq? "./boot/compile.scm" . 398387))
     (if.true
       (call
         (touch.gloc.of collect-local-closure)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 399406)
         (apply.gloc.of collect-local-closure "./boot/compile.scm" . 399383))
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 400419)
       (extend . 1)
       (call
         (call
           (touch.gloc.of local-closure?)
           (push.iloc.0 . 0)
           (apply.gloc.of local-closure? "./boot/compile.scm" . 403497))
         (if.true (ret.const . extend.enclose+))
         (ret.const . extend.enclose))
       (push)
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 401473)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 401485)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 401497))
         (push)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 401450))
       (push.cons)
       (call
         (touch.gloc.of compile-expression-seq)
         (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 402498)
         (push.iloc.1 . 0)
         (push.const . #f)
         (push.const . #t)
         (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 402474))
       (push.cons)
       (extend . 1)
       (iloc 4 . 3)
       (if.true (ret.iloc 0 . 0))
       (push.const . call)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 405547))
     (push.const . extend.unbound)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-argument)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 408634)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 408616))
     (push)
     (push.const . enclose)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (2 . 0) "./boot/compile.scm" . 410688)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 410664))
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 407581)
     (push.cons)
     (extend . 1)
     (iloc 3 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 411687))
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 413724)
   (extend . 1)
   (call
     (touch.gloc.of collect-local-closure)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 414734))
   (push.close
     (0 0)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (push.iloc 3 . 0)
         (push.const)
         (ret.subr.gloc.of values "./boot/compile.scm" . 418850))
       (push.iloc.0 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 419886)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (push.car.iloc (0 . 0) "./boot/compile.scm" . 420933)
         (push.const quote lambda)
         (ret.subr.gloc.of memq "./boot/compile.scm" . 420927))
       (if.true
         (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 421934)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 421950)
         (iloc.1 . 1)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/compile.scm" . 421928))
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 422960)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/compile.scm" . 422952))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/compile.scm" . 416796))
   (push.close
     (2 0)
     (call
       (touch.gloc.of cte-extend-iloc)
       (call (push.gloc.of car) (push.iloc.1 . 0) (apply.gloc.of map "./boot/compile.scm" . 423980))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 423963))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of compile-argument-each)
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/compile.scm" . 425019))
       (push)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 424996))
     (push)
     (call
       (push.gloc.of append)
       (call
         (push.gloc.of |.fn1.1`1|)
         (call
           (touch.gloc.of iloc-iota)
           (push.const . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427075)
           (push.iloc.1 . 1)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427090)
           (apply.gloc.of iloc-iota "./boot/compile.scm" . 427062))
         (push)
         (call
           (push.close
             (1 0)
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 428123)
             (push.iloc.1 . 0)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 428103))
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/compile.scm" . 428086))
         (push)
         (apply.gloc.of map "./boot/compile.scm" . 426033))
       (push)
       (apply.gloc.of apply "./boot/compile.scm" . 426019))
     (push)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 429115)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 429091))
     (push)
     (extend . 3)
     (call
       (iloc.0 . 0)
       (if.null?
         (push.const . extend.unbound)
         (push.iloc 3 . 0)
         (subr.gloc.of length 1 "./boot/compile.scm" . 431161)
         (push.cons)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
         (ret.cons "./boot/compile.scm" . 430112))
       (push.const . extend.unbound)
       (push.iloc 3 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432185)
       (push.cons)
       (push.iloc.0 . 0)
       (push.const . enclose)
       (push.iloc.0 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432229)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
       (push.cons)
       (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
       (ret.cons "./boot/compile.scm" . 430112))
     (push)
     (extend . 1)
     (iloc 5 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 433188))
   (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 413708))
 (set.gloc.of compile-expression-letrec*)
 (ret.const.unspec))
((close
   (5 0 . compile-binary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cdadr 1 "./boot/compile.scm" . 478229)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 479253)
   (extend . 2)
   (call
     (touch.gloc.of compile-argument)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 480309)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 480291))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 481335)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 481315))
   (push)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 480283)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 482332))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 483377)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 483357))
   (push)
   (extend . 3)
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 484381)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 484404)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 484398))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 485438)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 485399))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 486423)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 486423))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 487447))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 488471)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 488471))
 (set.gloc.of |compile-binary-special`2|)
 (close
   (5 0 . compile-unary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cadadr 1 "./boot/compile.scm" . 460820)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 461845)
   (extend . 2)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 462875))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 463900))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 464945)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 464925))
   (push)
   (extend . 3)
   (call
     (push.iloc 2 . 4)
     (const . if.null?.ret.const)
     (if.not.eq?.ret.const . #f)
     (iloc.1 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (iloc.1 . 1)
     (ret.eq? "./boot/compile.scm" . 466000))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 466970)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 466970))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 4)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 467994)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 467994)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 467994))
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 470052)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 470075)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 470069))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 471109)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 471070))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 472094)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 472094))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 473118))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 474142)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 474142))
 (set.gloc.of |compile-unary-special`2|)
 (close
   (4 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 441390)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 441370))
   (push)
   (extend . 1)
   (call
     (cdr.iloc (0 . 0) "./boot/compile.scm" . 442395)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 442417)
     (const . const)
     (ret.eq? "./boot/compile.scm" . 442412))
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of cdar 1 "./boot/compile.scm" . 443411)
     (if.true
       (touch.gloc.of compile-expression)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 444455)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 444435))
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 445479)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 445459))
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 446517)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 446497))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 447540)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 447520))
   (push)
   (extend . 2)
   (call
     (cadr.iloc (2 . 0) "./boot/compile.scm" . 448547)
     (if.not.symbol?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 448565)
     (push.iloc 2 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 448577)
     (ret.eq? "./boot/compile.scm" . 448560))
   (if.true
     (iloc 2 . 3)
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 449584)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 449563))
     (push.const . call)
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 450587)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 450587))
   (iloc 2 . 3)
   (if.true
     (call
       (cdr.iloc (0 . 1) "./boot/compile.scm" . 452652)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 1)
       (push.subr.gloc.of caar 1 "./boot/compile.scm" . 452674)
       (const . ret.const)
       (ret.eq? "./boot/compile.scm" . 452669))
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret.const)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 453700)
       (push.cons)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 452636))
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 452636))
   (push.const . call)
   (push.iloc.1 . 0)
   (push.const . if.true)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 0)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 455707)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 455707))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (4 0 . compile-expression-if)
   (push.iloc.0 . 0)
   (subr.gloc.of cdddr 1 "./boot/compile.scm" . 492563)
   (if.null?
     (iloc.0 . 2)
     (if.true
       (touch.gloc.of compile-expression)
       (push.const . and)
       (cdr.iloc (0 . 0) "./boot/compile.scm" . 494636)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 494608))
     (touch.gloc.of compile-expression)
     (push.const . if)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 495659)
     (push.const (unspecified))
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 495632)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 495632))
   (call
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 497695)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 497724)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 497708))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 499750)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 499742)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.null?)
         (push.const . if.null?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 502818))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.pair?)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 504866))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.symbol?)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 506914))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 508962))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.eq?)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`2| "./boot/compile.scm" . 512034))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 513078))
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 514127)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 514120)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 514100)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 514094)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515116))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515142))
         (if.true
           (touch.gloc.of |compile-binary-special`2|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.const . if.eq?)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`2| "./boot/compile.scm" . 516136))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc 3 . 3)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 517160))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 519202))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.iloc 2 . 3)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 521243))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 523283))
 (set.gloc.of compile-expression-if)
 (ret.const.unspec))
((close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 545827)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 545809))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 545866)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 545846))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 545924)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 545908))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 544779)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 544779))
 (set.gloc.of |compile-binary-special`4|)
 (close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 537637)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 537617))
   (push)
   (push.const . if.false.ret.const)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 537707)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 537691))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 536587))
 (set.gloc.of |compile-anonymous-negate`4|)
 (close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 541733)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 541713))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 541790)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 541774))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 540683))
 (set.gloc.of |compile-unary-special`4|)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 533541)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 533521))
   (push)
   (push.const . if.true.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 533563)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 533601)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 533585))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 532491))
 (set.gloc.of |compile-anonymous`4|)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 547860)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 548897)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 548877))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 549920)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 549947)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 549931))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 553006)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 553018)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 554034)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 554061)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 554045))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 556089)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 556081)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.null?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 559157))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.pair?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 561205))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.symbol?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 563253))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 565301))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of |compile-binary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.eq?.ret.const)
             (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 568373))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 569417))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 570464)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 570457)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 570439)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 570433)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571455))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571481))
             (if.true
               (touch.gloc.of |compile-binary-special`4|)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.not.eq?.ret.const)
               (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 572475))
             (touch.gloc.of |compile-anonymous-negate`4|)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 573499))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 575541))
         (touch.gloc.of |compile-anonymous-negate`4|)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 577582))
       (touch.gloc.of |compile-anonymous-negate`4|)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 579622))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 580651)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 580643)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.null?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 583719))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 585767))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 587815))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 589863))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 592935))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 593979))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 595026)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 595019)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 595001)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 594995)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596017))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596043))
         (if.true
           (touch.gloc.of |compile-binary-special`4|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 597037))
         (touch.gloc.of |compile-anonymous`4|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 598061))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 600103))
     (touch.gloc.of |compile-anonymous`4|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 602144))
   (touch.gloc.of |compile-anonymous`4|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 604180))
 (set.gloc.of |compile-clause`2|)
 (close
   (4 0 . compile-expression-or)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 606227)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #f)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 608280))
     (push.const . const)
     (const . #f)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 609304))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 610323)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 611360)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 611340))
   (call
     (iloc.0 . 3)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 613400)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 614424)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of top-level-value-or-false)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caaddr 1 "./boot/compile.scm" . 615472)
       (apply.gloc.of top-level-value-or-false "./boot/compile.scm" . 615446))
     (push)
     (gloc.of assertion-violation)
     (ret.eq? "./boot/compile.scm" . 615441))
   (if.true
     (call
       (touch.gloc.of compile-expression)
       (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 616484)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616464))
     (push)
     (push.const . if.false.call)
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 616544)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616524))
     (push.cons)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 612363)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 612363))
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 618536)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 618520))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 619548))
 (set.gloc.of compile-expression-or)
 (ret.const.unspec))
((close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 633893)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 633873))
   (push)
   (push.const . if.true.ret.const)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 633962)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 633946))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 632843))
 (set.gloc.of |compile-anonymous-negate`4|)
 (close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 642083)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 642065))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 642122)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 642102))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 642180)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 642164))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 641035)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 641035))
 (set.gloc.of |compile-binary-special`4|)
 (close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 637989)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 637969))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 638046)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 638030))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 636939))
 (set.gloc.of |compile-unary-special`4|)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 629797)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 629777))
   (push)
   (push.const . if.false.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 629819)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 629858)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 629842))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 628747))
 (set.gloc.of |compile-anonymous`4|)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 644116)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 645153)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 645133))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 646176)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 646203)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 646187))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 649262)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 649274)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 650290)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 650317)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 650301))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 652345)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 652337)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.null?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 655413))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.pair?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 657461))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.symbol?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 659509))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 661557))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of |compile-binary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.eq?.ret.const)
             (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 664629))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 665673))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 666720)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 666713)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 666695)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 666689)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667711))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667737))
             (if.true
               (touch.gloc.of |compile-binary-special`4|)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.eq?.ret.const)
               (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 668731))
             (touch.gloc.of |compile-anonymous-negate`4|)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 669755))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 671797))
         (touch.gloc.of |compile-anonymous-negate`4|)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 673838))
       (touch.gloc.of |compile-anonymous-negate`4|)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 675878))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 676907)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 676899)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.null?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 679975))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 682023))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 684071))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 686119))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 689191))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 690235))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 691282)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 691275)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 691257)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 691251)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692273))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692299))
         (if.true
           (touch.gloc.of |compile-binary-special`4|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.not.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 693293))
         (touch.gloc.of |compile-anonymous`4|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 694317))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 696359))
     (touch.gloc.of |compile-anonymous`4|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 698400))
   (touch.gloc.of |compile-anonymous`4|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 700436))
 (set.gloc.of |compile-clause`2|)
 (close
   (4 0 . compile-expression-and)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 702483)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #t)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 704536))
     (push.const . const)
     (const . #t)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 705560))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 706579)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 707616)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 707596))
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 709672)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 709656))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 710684))
 (set.gloc.of compile-expression-and)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . begin)
   (push.gloc.of compile-expression-begin)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 714757)
   (push.iloc.0 . 0)
   (push.const . quote)
   (push.gloc.of compile-expression-quote)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 715781)
   (push.iloc.0 . 0)
   (push.const . define)
   (push.gloc.of compile-expression-define)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 716805)
   (push.iloc.0 . 0)
   (push.const . set!)
   (push.gloc.of compile-expression-set!)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 717829)
   (push.iloc.0 . 0)
   (push.const . lambda)
   (push.gloc.of compile-expression-lambda)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 718853)
   (push.iloc.0 . 0)
   (push.const . let)
   (push.gloc.of compile-expression-let)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 719877)
   (push.iloc.0 . 0)
   (push.const . letrec*)
   (push.gloc.of compile-expression-letrec*)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 720901)
   (push.iloc.0 . 0)
   (push.const . if)
   (push.gloc.of compile-expression-if)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 721925)
   (push.iloc.0 . 0)
   (push.const . or)
   (push.gloc.of compile-expression-or)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 722949)
   (push.iloc.0 . 0)
   (push.const . and)
   (push.gloc.of compile-expression-and)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 723973)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 724997))
 (set.gloc.of ht-dispatch-expression)
 (ret.const.unspec))
((close
   (1 0 . reverse-append)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/compile.scm" . 732169))
 (set.gloc.of |reverse-append`2|)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (touch.gloc.of |loop`7|)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 735256)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 735274)
   (push.iloc.0 . 1)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 735266)
   (apply.gloc.of |loop`7| "./boot/compile.scm" . 735250))
 (set.gloc.of |loop`7|)
 (close
   (4 0 . compile-expression-seq)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (touch.gloc.of |reverse-append`2|)
       (push.iloc.0 . 1)
       (apply.gloc.of |reverse-append`2| "./boot/compile.scm" . 740378))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 747542)
     (call
       (touch.gloc.of compile-expression)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 743448)
       (push.iloc 2 . 1)
       (call
         (iloc 2 . 2)
         (if.true.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 745515)
         (ret.pair? "./boot/compile.scm" . 745508))
       (push)
       (call
         (iloc 2 . 3)
         (if.false.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 746537)
         (ret.null? "./boot/compile.scm" . 746530))
       (push)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 742423))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 747536))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 739333))
 (set.gloc.of compile-expression-seq)
 (ret.const.unspec))
((close
   (4 0 . compile-expression)
   (iloc.0 . 0)
   (if.pair?
     (push.gloc.of ht-dispatch-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 755774)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 755731)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (0 . 0) "./boot/compile.scm" . 756773))
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 757795)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 757779))
     (if.true
       (touch.gloc.of compile-subr-expression)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-subr-expression "./boot/compile.scm" . 758803))
     (call
       (subr.gloc.of backtrace 0 "./boot/compile.scm" . 762916)
       (if.true
         (touch.gloc.of compile-touch)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 762943)
         (push.iloc.1 . 1)
         (apply.gloc.of compile-touch "./boot/compile.scm" . 762928))
       (ret.const))
     (push)
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 761910)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 761887))
     (push)
     (call
       (touch.gloc.of compile-call)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 760877)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 760896)
       (push.subr.gloc.of length 1 "./boot/compile.scm" . 760888)
       (call
         (touch.gloc.of make-application-comment)
         (push.iloc.1 . 0)
         (apply.gloc.of make-application-comment "./boot/compile.scm" . 760908))
       (push)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-call "./boot/compile.scm" . 760863))
     (push)
     (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 763931)
     (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 763931)
     (extend . 1)
     (iloc 2 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 764965))
   (iloc.0 . 3)
   (if.true
     (push.iloc.0 . 0)
     (const . |.&UNDEF|)
     (if.eq?
       (push.const . ret.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 769053)
       (ret.subr.gloc.of list "./boot/compile.scm" . 769047))
     (push.iloc.0 . 0)
     (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 770071)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 771101)
       (ret.subr.gloc.of list "./boot/compile.scm" . 771095))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of iloc?)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 773147))
       (if.true
         (push.const . ret.iloc)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 774185))
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 773143))
       (push.const . ret.gloc.of)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 773143)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 773143))
     (push.const . ret.const)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 776214))
   (iloc.0 . 2)
   (if.true.ret.const)
   (push.iloc.0 . 0)
   (const . |.&UNDEF|)
   (if.eq?
     (push.const . const.undef)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 780317)
     (ret.subr.gloc.of list "./boot/compile.scm" . 780311))
   (push.iloc.0 . 0)
   (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 781335)
   (if.true
     (push.const . const.unspec)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 782365)
     (ret.subr.gloc.of list "./boot/compile.scm" . 782359))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 784411))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 785446))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 786467)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 787505)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 787487))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 788529)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 788511))
       (push.const . iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 789535))
     (push.const . gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 784407)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 784407))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 791574))
 (set.gloc.of compile-expression)
 (ret.const.unspec))
((close
   (1 0 . compile-coreform)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of ht-local-closures)
       (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
     (set.iloc 1 . 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 1)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of compile-expression)
     (push.iloc 2 . 0)
     (push.const)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 0)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (apply.gloc.of |.dynamic-wind| "./boot/compile.scm" . 797703))
 (set.gloc.of compile-coreform)
 (ret.const.unspec))

;
((close
   (3 0 . dynamic-wind)
   (call (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 11269))
   (call
     (touch.gloc.of current-dynamic-wind-record)
     (push.iloc.0 . 0)
     (iloc.0 . 2)
     (push.cons)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12342))
     (push.cons)
     (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12293))
   (push.iloc.0 . 1)
   (push.close
     (0 1)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16429))
       (push)
       (push.subr.gloc.of cdr 1 "./boot/dynamic-wind.scm" . 16424)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16395))
     (call (apply.iloc (1 . 2) "./boot/dynamic-wind.scm" . 17419))
     (push.gloc.of values)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/dynamic-wind.scm" . 18443))
   (apply.gloc.of call-with-values "./boot/dynamic-wind.scm" . 13317))
 (set.gloc.of dynamic-wind)
 (ret.const.unspec))
((close
   (2 0 . common-tail)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25619)
   (push.iloc.0 . 1)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25635)
   (extend . 2)
   (touch.gloc.of |.L0`9|)
   (call
     (iloc.0 . 0)
     (>.iloc (0 . 1) "./boot/dynamic-wind.scm" . 26647)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 26670)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 26657))
     (ret.iloc 1 . 0))
   (push)
   (call
     (iloc.0 . 1)
     (>.iloc (0 . 0) "./boot/dynamic-wind.scm" . 27671)
     (if.true
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 27694)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 27681))
     (ret.iloc 1 . 1))
   (push)
   (apply.gloc.of |.L0`9| "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of |common-tail`2|)
 (close
   (2 0 . |.L0|)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq? (ret.iloc 0 . 0))
   (touch.gloc.of |.L0`9|)
   (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 26684)
   (push.cdr.iloc (0 . 1) "./boot/dynamic-wind.scm" . 27708)
   (apply.gloc.of |.L0`9| "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of |.L0`9|)
 (close
   (3 0 . perform-dynamic-wind)
   (call
     (call
       (touch.gloc.of |common-tail`2|)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 30754))
       (push)
       (apply.gloc.of |common-tail`2| "./boot/dynamic-wind.scm" . 30737))
     (push)
     (extend . 1)
     (call
       (extend.enclose+
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 2 . 0)
         (if.eq? (ret.const.unspec))
         (call
           (touch.gloc.of current-dynamic-wind-record)
           (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 33837)
           (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 33808))
         (call (push.iloc.0 . 0) (subr.gloc.of cdar 1 "./boot/dynamic-wind.scm" . 34833) (apply))
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 35862)
         (apply.iloc+ (1 . 0) "./boot/dynamic-wind.scm" . 35856))
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 31767))
       (push)
       (apply.iloc+ (0 . 0) "./boot/dynamic-wind.scm" . 31751))
     (extend.enclose
       (1 0 . loop)
       (push.iloc.0 . 0)
       (iloc 2 . 0)
       (if.eq? (ret.const.unspec))
       (call
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 38934)
         (apply.iloc (1 . 0) "./boot/dynamic-wind.scm" . 38928))
       (call (push.iloc.0 . 0) (subr.gloc.of caar 1 "./boot/dynamic-wind.scm" . 39953) (apply))
       (touch.gloc.of current-dynamic-wind-record)
       (push.iloc.0 . 0)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 40976))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 36871))
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of apply "./boot/dynamic-wind.scm" . 41989))
 (set.gloc.of perform-dynamic-wind)
 (ret.const.unspec))

;
((close
   (1 0 . raise)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 7185))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.true (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 9227))
     (push.const . "error in raise: unhandled exception has occurred~%~%irritants:~%~a")
     (call
       (touch.gloc.of describe-condition)
       (push.const . #f)
       (push.iloc.1 . 0)
       (apply.gloc.of describe-condition "./boot/exception.scm" . 10334))
     (push)
     (apply.gloc.of scheme-error "./boot/exception.scm" . 10251))
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 11271))
   (push.const . "error in raise: returned from non-continuable exception~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 12385))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 12295))
 (set.gloc.of raise)
 (ret.const.unspec))
((close
   (1 0 . raise-continuable)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 16401))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 18443))
   (push.const . "error in raise-continuable: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 19562))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 19467))
 (set.gloc.of raise-continuable)
 (ret.const.unspec))
((close
   (2 0 . with-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 23571))
   (push)
   (extend . 1)
   (push.const . #f)
   (push.close
     (1 0 . tmp2)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-exception-handler)
         (apply.gloc.of current-exception-handler "./boot/exception.scm" . 28689))
       (set.iloc 1 . 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc 3 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 28689))
     (push.close (0 0) (push.iloc 2 . 0) (apply.iloc (4 . 0) "./boot/exception.scm" . 28689))
     (push.close
       (0 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc.1 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 28689))
     (apply.gloc.of |.dynamic-wind| "./boot/exception.scm" . 28689))
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-exception-handler)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 29705))
     (set.iloc 1 . 0)
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 1)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 29705))
   (push.close (0 0) (apply.iloc (3 . 1) "./boot/exception.scm" . 29705))
   (push.close
     (0 0)
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 0)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 29705))
   (apply.gloc.of |.dynamic-wind| "./boot/exception.scm" . 29705))
 (set.gloc.of with-exception-handler)
 (ret.const.unspec))
((close
   (2 1 . assertion-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-assertion-violation "./boot/exception.scm" . 36891))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 37924))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 38939))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 39986))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 36885)
       (apply.gloc.of filter "./boot/exception.scm" . 35853))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 34822))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 33797))
 (set.gloc.of assertion-violation)
 (ret.const.unspec))
((close
   (1 1 . undefined-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 47131))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 48164))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 49224)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 49200))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 47125)
       (apply.gloc.of filter "./boot/exception.scm" . 46093))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 45062))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 44037))
 (set.gloc.of undefined-violation)
 (ret.const.unspec))
((close
   (1 1 . lexical-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-lexical-violation "./boot/exception.scm" . 56347))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 57380))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 58440)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 58416))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 56341)
       (apply.gloc.of filter "./boot/exception.scm" . 55309))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 54278))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 53253))
 (set.gloc.of lexical-violation)
 (ret.const.unspec))
((close
   (3 1 . syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 65612))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 65563))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 66596))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 67611))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 65557)
       (apply.gloc.of filter "./boot/exception.scm" . 64525))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 63494))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 62469))
 (set.gloc.of syntax-violation)
 (ret.const.unspec))
((close
   (2 1 . error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-error "./boot/exception.scm" . 74779))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 75812))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 76827))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 77874))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 74773)
       (apply.gloc.of filter "./boot/exception.scm" . 73741))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 72710))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 71685))
 (set.gloc.of error)
 (ret.const.unspec))
((close
   (2 1 . implementation-restriction-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (apply.gloc.of make-implementation-restriction-violation "./boot/exception.scm" . 85019))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 86052))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 87067))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 88114))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 85013)
       (apply.gloc.of filter "./boot/exception.scm" . 83981))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 82950))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 81925))
 (set.gloc.of implementation-restriction-violation)
 (ret.const.unspec))
((close
   (0 1 . scheme-error)
   (push.const . #t)
   (push.const . "~!")
   (subr.gloc.of format 2 "./boot/exception.scm" . 92165)
   (subr.gloc.of current-error-port 0)
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 93229))
   (if.true
     (call
       (push.gloc.of format)
       (push.iloc.1 . 0)
       (apply.gloc.of apply "./boot/exception.scm" . 94234))
     (push)
     (apply.gloc.of raise "./boot/exception.scm" . 94227))
   (push.iloc.0 . 0)
   (push.const . "~&~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 96270)
   (call
     (push.gloc.of format)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of apply "./boot/exception.scm" . 97294))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 98318)
   (subr.gloc.of display-backtrace 0 "./boot/exception.scm" . 99342)
   (push.iloc.0 . 0)
   (push.const . "~%[exit]~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 100366)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/exception.scm" . 101390))
 (set.gloc.of scheme-error)
 (ret.const.unspec))
((close
   (3 1 . raise-i/o-filename-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-i/o-filename-error "./boot/exception.scm" . 108571))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 109604))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 110619))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 111666))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 108565)
       (apply.gloc.of filter "./boot/exception.scm" . 107533))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 106502))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 105477))
 (set.gloc.of raise-i/o-filename-error)
 (ret.const.unspec))
((close
   (2 1 . raise-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-i/o-error "./boot/exception.scm" . 118811))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 119844))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 120859))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 121906))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 118805)
       (apply.gloc.of filter "./boot/exception.scm" . 117773))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 116742))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 115717))
 (set.gloc.of raise-i/o-error)
 (ret.const.unspec))
((close
   (4 1 . raise-misc-i/o-error-with-port)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 4)
         (apply.gloc.of apply "./boot/exception.scm" . 130075))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 131108))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 132123))
       (push)
       (call
         (iloc.0 . 3)
         (if.false.ret)
         (push.iloc.0 . 3)
         (apply.gloc.of make-i/o-port-error "./boot/exception.scm" . 133157))
       (push)
       (call
         (push.iloc.0 . 3)
         (push.iloc.0 . 4)
         (push.subr.gloc.of cons* 2 "./boot/exception.scm" . 134197)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 134171))
       (push)
       (push.subr.gloc.of list 5 "./boot/exception.scm" . 130069)
       (apply.gloc.of filter "./boot/exception.scm" . 129037))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 128006))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 126981))
 (set.gloc.of raise-misc-i/o-error-with-port)
 (ret.const.unspec))
((close
   (3 1 . raise-misc-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of apply "./boot/exception.scm" . 141339))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 142372))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 143387))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 145440))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 141333)
       (apply.gloc.of filter "./boot/exception.scm" . 140301))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 139270))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 138245))
 (set.gloc.of raise-misc-i/o-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-read-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-read-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 149509))
 (set.gloc.of raise-i/o-read-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-write-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-write-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 153605))
 (set.gloc.of raise-i/o-write-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-protection-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-protection-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 157701))
 (set.gloc.of raise-i/o-file-protection-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-is-read-only-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-file-is-read-only-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 161797))
 (set.gloc.of raise-i/o-file-is-read-only-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-already-exists-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-already-exists-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 165893))
 (set.gloc.of raise-i/o-file-already-exists-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-does-not-exist-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-does-not-exist-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 169989))
 (set.gloc.of raise-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-invalid-position-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-invalid-position-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 174085))
 (set.gloc.of raise-i/o-invalid-position-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-decoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-decoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 178181))
 (set.gloc.of raise-i/o-decoding-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-encoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-encoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 182277))
 (set.gloc.of raise-i/o-encoding-error)
 (ret.const.unspec))

;
((subr.gloc.of make-weak-core-hashtable 0 "./boot/record.scm" . 5156)
 (set.gloc.of nongenerative-record-types)
 (ret.const.unspec))
((close
   (6 0 . make-rtd)
   (push.const . type:record-type-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.iloc.0 . 5)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 9221))
 (set.gloc.of make-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 13322)
   (const . type:record-type-descriptor)
   (ret.eq? "./boot/record.scm" . 13317))
 (set.gloc.of record-type-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rtd-name)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 15395))
 (set.gloc.of rtd-name)
 (ret.const.unspec))
((close
   (1 0 . rtd-parent)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 16419))
 (set.gloc.of rtd-parent)
 (ret.const.unspec))
((close
   (1 0 . rtd-uid)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 17443))
 (set.gloc.of rtd-uid)
 (ret.const.unspec))
((close
   (1 0 . rtd-sealed?)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 18467))
 (set.gloc.of rtd-sealed?)
 (ret.const.unspec))
((close
   (1 0 . rtd-opaque?)
   (push.iloc.0 . 0)
   (push.const . 5)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 19491))
 (set.gloc.of rtd-opaque?)
 (ret.const.unspec))
((close
   (1 0 . rtd-fields)
   (push.iloc.0 . 0)
   (push.const . 6)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 20515))
 (set.gloc.of rtd-fields)
 (ret.const.unspec))
((close
   (2 0 . rtd-ancestor?)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc 2 . 0)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (iloc.0 . 0)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 27670))
     (push)
     (apply.iloc+ (1 . 0) "./boot/record.scm" . 27664))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/record.scm" . 24581))
 (set.gloc.of rtd-ancestor?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |loop`5|)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 33812))
     (push)
     (push.iloc.0 . 1)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 34853))
     (push)
     (push.subr.gloc.of length 1 "./boot/record.scm" . 34845)
     (push.subr.gloc.of + 2 "./boot/record.scm" . 34836)
     (apply.gloc.of |loop`5| "./boot/record.scm" . 33806))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . rtd-inherited-field-count)
   (touch.gloc.of |loop`5|)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 31765))
   (push)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/record.scm" . 31749))
 (set.gloc.of rtd-inherited-field-count)
 (ret.const.unspec))
((close
   (1 0 . rtd-total-field-count)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 40968))
   (push)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 41008))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 41000)
   (ret.subr.gloc.of + "./boot/record.scm" . 40965))
 (set.gloc.of rtd-total-field-count)
 (ret.const.unspec))
((close
   (1 0 . record-type-name)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 45065))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 46128))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 46089))
   (touch.gloc.of rtd-name)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-name "./boot/record.scm" . 47109))
 (set.gloc.of record-type-name)
 (ret.const.unspec))
((close
   (1 0 . record-type-parent)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 51209))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 52272))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 52233))
   (touch.gloc.of rtd-parent)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-parent "./boot/record.scm" . 53253))
 (set.gloc.of record-type-parent)
 (ret.const.unspec))
((close
   (1 0 . record-type-uid)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 57353))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 58416))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 58377))
   (touch.gloc.of rtd-uid)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-uid "./boot/record.scm" . 59397))
 (set.gloc.of record-type-uid)
 (ret.const.unspec))
((close
   (1 0 . record-type-generative?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 63497))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 64560))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 64521))
   (call
     (touch.gloc.of rtd-uid)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-uid "./boot/record.scm" . 65546))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 65541))
 (set.gloc.of record-type-generative?)
 (ret.const.unspec))
((close
   (1 0 . record-type-sealed?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 69641))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 70704))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 70665))
   (touch.gloc.of rtd-sealed?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-sealed? "./boot/record.scm" . 71685))
 (set.gloc.of record-type-sealed?)
 (ret.const.unspec))
((close
   (1 0 . record-type-opaque?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 75785))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 76848))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 76809))
   (touch.gloc.of rtd-opaque?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-opaque? "./boot/record.scm" . 77829))
 (set.gloc.of record-type-opaque?)
 (ret.const.unspec))
((close
   (1 0 . record-type-field-names)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 81929))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 82992))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 82953))
   (call
     (push.gloc.of cdr)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 83996))
     (push)
     (apply.gloc.of map "./boot/record.scm" . 83987))
   (push)
   (apply.gloc.of list->vector "./boot/record.scm" . 83973))
 (set.gloc.of record-type-field-names)
 (ret.const.unspec))
((close
   (2 0 . record-field-mutable?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 88073))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 89136))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 89197)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 89097))
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 90132))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-ref 2 "./boot/record.scm" . 90122)
   (ret.subr.gloc.of car "./boot/record.scm" . 90117))
 (set.gloc.of record-field-mutable?)
 (ret.const.unspec))
((close
   (6 0 . make-record-type-descriptor)
   (push.iloc.0 . 0)
   (subr.gloc.of symbol? 1 "./boot/record.scm" . 94217)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "symbol")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 96286))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 97310)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 95241))
   (push.iloc.0 . 5)
   (subr.gloc.of vector? 1 "./boot/record.scm" . 98313)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "vector")
       (push.iloc.0 . 5)
       (push.const . 6)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 100382))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 101406)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 99337))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call (push.iloc.0 . 1) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 103438))
     (if.false.call
       (push.const . make-record-type-descriptor)
       (call
         (touch.gloc.of wrong-type-argument-message)
         (push.const . "record-type descriptor or #f")
         (push.iloc.0 . 1)
         (push.const . 2)
         (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 105507))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.iloc.0 . 4)
       (push.iloc.0 . 5)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 106531)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 104462))
     (if.false.ret)
     (call
       (touch.gloc.of rtd-sealed?)
       (push.iloc.0 . 1)
       (apply.gloc.of rtd-sealed? "./boot/record.scm" . 107535))
     (if.false.ret)
     (push.const . make-record-type-descriptor)
     (push.const . "attempt to extend a sealed record-type")
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 108559))
   (call
     (iloc.0 . 4)
     (if.true.ret)
     (iloc.0 . 1)
     (if.false.ret)
     (touch.gloc.of rtd-opaque?)
     (push.iloc.0 . 1)
     (apply.gloc.of rtd-opaque? "./boot/record.scm" . 111645))
   (push)
   (call
     (push.close
       (1 0)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (ret.null? "./boot/record.scm" . 113690))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . mutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #t)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . immutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #f)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (push.const . make-record-type-descriptor)
       (push.const . "malformed field specifiers")
       (push.iloc 2 . 5)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 113690))
     (push.iloc.0 . 5)
     (push.subr.gloc.of vector->list 1 "./boot/record.scm" . 120856)
     (apply.gloc.of map "./boot/record.scm" . 109573))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of make-rtd)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of make-rtd "./boot/record.scm" . 121874))
   (push)
   (extend . 1)
   (iloc 2 . 2)
   (if.true
     (push.gloc.of nongenerative-record-types)
     (push.iloc 2 . 2)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/record.scm" . 123920)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 125988))
         (push)
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 126002))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 125982)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127012))
         (push)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127029))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 127006)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128038))
         (push)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128055))
         (push)
         (ret.subr.gloc.of equal? "./boot/record.scm" . 128030))
       (if.true (ret.iloc 0 . 0))
       (push.const . make-record-type-descriptor)
       (push.const . "mismatched subsequent call for nongenerative record-type")
       (push.iloc 3 . 0)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (push.iloc 3 . 3)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 132142)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 130073))
     (push.gloc.of nongenerative-record-types)
     (push.iloc 3 . 2)
     (push.iloc.1 . 0)
     (subr.gloc.of core-hashtable-set! 3 "./boot/record.scm" . 134167)
     (ret.iloc 1 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of make-record-type-descriptor)
 (ret.const.unspec))
((close
   (4 0 . make-rcd)
   (push.const . type:record-constructor-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 138245))
 (set.gloc.of make-rcd)
 (ret.const.unspec))
((close
   (1 0 . record-constructor-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 142346)
   (const . type:record-constructor-descriptor)
   (ret.eq? "./boot/record.scm" . 142341))
 (set.gloc.of record-constructor-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rcd-rtd)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 144428))
 (set.gloc.of rcd-rtd)
 (ret.const.unspec))
((close
   (1 0 . rcd-protocol)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 145452))
 (set.gloc.of rcd-protocol)
 (ret.const.unspec))
((close
   (1 0 . rcd-custom-protocol?)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 146476))
 (set.gloc.of rcd-custom-protocol?)
 (ret.const.unspec))
((close
   (1 0 . rcd-parent)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 147500))
 (set.gloc.of rcd-parent)
 (ret.const.unspec))
((close
   (1 0)
   (ret.close
     (0 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/record.scm" . 160783)))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . default-protocol)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 151571))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 153637))
     (push)
     (extend . 1)
     (ret.close
       (1 0)
       (ret.close
         (0 1)
         (push.close
           (0 0)
           (touch.gloc.of split-at)
           (push.iloc.1 . 0)
           (push.iloc 3 . 0)
           (apply.gloc.of split-at "./boot/record.scm" . 156743))
         (push.close
           (2 0)
           (call
             (push.iloc 2 . 0)
             (push.iloc.0 . 0)
             (apply.gloc.of apply "./boot/record.scm" . 157722))
           (push)
           (push.iloc.0 . 1)
           (apply.gloc.of apply "./boot/record.scm" . 157715))
         (apply.gloc.of |.call-with-values| "./boot/record.scm" . 155663))))
   (ret.gloc.of |.fn2.1`2|))
 (set.gloc.of default-protocol)
 (ret.const.unspec))
((close
   (3 0 . make-record-constructor-descriptor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 164873))
   (if.false.call
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 166942))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 167966)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 165897))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of record-constructor-descriptor?)
       (push.iloc.0 . 1)
       (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 169998))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor or #f")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 172067))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 173091)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 171022))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (push.iloc.0 . 2)
     (subr.gloc.of procedure? 1 "./boot/record.scm" . 175118)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "procedure or #f")
       (push.iloc.0 . 2)
       (push.const . 3)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 177187))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 178211)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 176142))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 180238))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 181262))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 186378))
     (if.false.ret)
     (call
       (touch.gloc.of rcd-rtd)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-rtd "./boot/record.scm" . 187411))
     (push)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 187428))
     (if.eq?.ret.const . #t)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 188430))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 193546))
     (if.false.ret)
     (iloc.0 . 1)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "expected #f for protocol since no parent constructor descriptor is provided")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 195598))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rcd-custom-protocol?)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-custom-protocol? "./boot/record.scm" . 200714))
     (if.false.ret)
     (iloc.0 . 2)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const
       .
       "expected procedure for protocol since parent constructor descriptor have custom one")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 202766))
   (touch.gloc.of make-rcd)
   (push.iloc.0 . 0)
   (call
     (iloc.0 . 2)
     (if.true.ret)
     (touch.gloc.of default-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of default-protocol "./boot/record.scm" . 208930))
   (push)
   (call (iloc.0 . 2) (if.false.ret) (ret.const . #t))
   (push)
   (call
     (iloc.0 . 1)
     (if.true.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 210974))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of make-record-constructor-descriptor "./boot/record.scm" . 213027))
     (ret.const . #f))
   (push)
   (apply.gloc.of make-rcd "./boot/record.scm" . 215047))
 (set.gloc.of make-record-constructor-descriptor)
 (ret.const.unspec))
((close
   (1 0 . record?)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 219171)
     (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 219146))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 220196)
     (apply.gloc.of record-type-opaque? "./boot/record.scm" . 220175))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 220170))
 (set.gloc.of record?)
 (ret.const.unspec))
((close
   (1 0 . record-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/record.scm" . 224265))
   (if.true
     (push.iloc.0 . 0)
     (push.const . 0)
     (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 225289))
   (push.const . record-rtd)
   (call
     (touch.gloc.of wrong-type-argument-message)
     (push.const . "non-opaque record")
     (push.iloc.0 . 0)
     (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 226346))
   (push)
   (apply.gloc.of assertion-violation "./boot/record.scm" . 226313))
 (set.gloc.of record-rtd)
 (ret.const.unspec))
((close
   (3 0 . make-nested-conser)
   (call
     (call
       (extend.enclose
         (1 0 . loop)
         (call
           (touch.gloc.of rcd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rcd-parent "./boot/record.scm" . 232464))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (ret.close
             (0 1)
             (ret.close
               (0 1)
               (ret.close
                 (0 1)
                 (call
                   (call
                     (call (push.iloc 3 . 0) (apply.iloc (5 . 0) "./boot/record.scm" . 238634))
                     (push)
                     (push.iloc.0 . 0)
                     (push.iloc 2 . 0)
                     (push.subr.gloc.of append 2 "./boot/record.scm" . 239658)
                     (apply.gloc.of apply "./boot/record.scm" . 238627))
                   (push)
                   (call
                     (touch.gloc.of rcd-protocol)
                     (push.iloc 3 . 0)
                     (apply.gloc.of rcd-protocol "./boot/record.scm" . 237603))
                   (apply))
                 (push)
                 (push.iloc.1 . 0)
                 (apply.gloc.of apply "./boot/record.scm" . 237595)))))
         (ret.close
           (0 1)
           (ret.close
             (0 1)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.subr.gloc.of append 2 "./boot/record.scm" . 244776)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of length 1 "./boot/record.scm" . 245789)
             (=.iloc (6 . 2) "./boot/record.scm" . 245786)
             (if.true
               (push.gloc.of tuple)
               (push.iloc 6 . 1)
               (push.iloc.0 . 0)
               (apply.gloc.of apply "./boot/record.scm" . 246810))
             (push.const . "record constructor")
             (push.const . "wrong number of arguments")
             (push.iloc.0 . 0)
             (apply.gloc.of assertion-violation "./boot/record.scm" . 247834))))
       (push.iloc.1 . 0)
       (apply.iloc (0 . 0) "./boot/record.scm" . 231431))
     (apply))
   (push)
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 230406))
   (apply))
 (set.gloc.of make-nested-conser)
 (ret.const.unspec))
((close
   (3 0 . make-simple-conser)
   (push.close
     (0 1)
     (push.iloc.0 . 0)
     (subr.gloc.of length 1 "./boot/record.scm" . 253967)
     (=.iloc (1 . 2) "./boot/record.scm" . 253964)
     (if.true
       (push.gloc.of tuple)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of apply "./boot/record.scm" . 254988))
     (push.const . "record constructor")
     (push.const . "wrong number of arguments")
     (push.iloc.0 . 0)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 256012))
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 251910))
   (apply))
 (set.gloc.of make-simple-conser)
 (ret.const.unspec))
((close
   (2 0 . flat-field-offset)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 260104))
   (push)
   (push.iloc.0 . 1)
   (push.const . 1)
   (ret.subr.gloc.of + "./boot/record.scm" . 260101))
 (set.gloc.of flat-field-offset)
 (ret.const.unspec))
((close
   (2 0 . make-accessor)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 265239)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 265258))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 266273)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 266254))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 266292))
     (push.const . "record accessor")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 268398))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 268370)
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 268341))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 268302)))
 (set.gloc.of make-accessor)
 (ret.const.unspec))
((close
   (2 0 . make-mutator)
   (ret.close
     (2 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 273431)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 273450))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 274465)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 274446))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 274484))
     (push.const . "record mutator")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 276589))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 276561)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of list 2 "./boot/record.scm" . 276605)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 276532))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 276494)))
 (set.gloc.of make-mutator)
 (ret.const.unspec))
((close
   (1 0 . make-predicate)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 281620)
     (if.eq?.ret.const . #t)
     (touch.gloc.of rtd-ancestor?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 282654)
     (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 282635)))
 (set.gloc.of make-predicate)
 (ret.const.unspec))
((close
   (1 0 . record-constructor)
   (call
     (touch.gloc.of record-constructor-descriptor?)
     (push.iloc.0 . 0)
     (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 286729))
   (if.false.call
     (push.const . record-constructor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 287794))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 287753))
   (call
     (touch.gloc.of rcd-rtd)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-rtd "./boot/record.scm" . 288784))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of rcd-parent)
     (push.iloc.1 . 0)
     (apply.gloc.of rcd-parent "./boot/record.scm" . 289803))
   (if.true
     (touch.gloc.of make-nested-conser)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 290856))
     (push)
     (apply.gloc.of make-nested-conser "./boot/record.scm" . 290827))
   (touch.gloc.of make-simple-conser)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 291888))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 291880)
   (apply.gloc.of make-simple-conser "./boot/record.scm" . 291851))
 (set.gloc.of record-constructor)
 (ret.const.unspec))
((close
   (1 0 . record-predicate)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 295945))
   (if.false.call
     (push.const . record-predicate)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 297008))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 296969))
   (touch.gloc.of make-predicate)
   (push.iloc.0 . 0)
   (apply.gloc.of make-predicate "./boot/record.scm" . 297989))
 (set.gloc.of record-predicate)
 (ret.const.unspec))
((close
   (2 0 . record-accessor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 302089))
   (if.false.call
     (push.const . record-accssor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 303150))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 303209)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 303113))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 304153))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 304145)
   (subr.gloc.of < 3 "./boot/record.scm" . 304137)
   (if.false.call
     (push.const . record-accssor)
     (push.const . "field index out of range")
     (apply.gloc.of assertion-violation "./boot/record.scm" . 305161))
   (touch.gloc.of make-accessor)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 306200))
   (push)
   (apply.gloc.of make-accessor "./boot/record.scm" . 306181))
 (set.gloc.of record-accessor)
 (ret.const.unspec))
((close
   (2 0 . record-mutator)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 310281))
   (if.false.call
     (push.const . record-mutator)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 311342))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 311401)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 311305))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 312345))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 312337)
   (subr.gloc.of < 3 "./boot/record.scm" . 312329)
   (if.false.call
     (push.const . record-mutator)
     (push.const . "field index out of range")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 313417)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 313353))
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of record-field-mutable? "./boot/record.scm" . 314377))
   (if.false.call
     (push.const . record-mutator)
     (push.const . "specified field is immutable")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 315469)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 315401))
   (touch.gloc.of make-mutator)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 316439))
   (push)
   (apply.gloc.of make-mutator "./boot/record.scm" . 316421))
 (set.gloc.of record-mutator)
 (ret.const.unspec))
((close
   (3 0 . make-record-type)
   (push.const . type:record-type)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 320517))
 (set.gloc.of make-record-type)
 (ret.const.unspec))
((close
   (1 0 . record-type?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 324618)
   (const . type:record-type)
   (ret.eq? "./boot/record.scm" . 324613))
 (set.gloc.of record-type?)
 (ret.const.unspec))
((close
   (1 0 . record-type-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 328713))
   (if.false.call
     (push.const . record-type-rtd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 329775))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 329737))
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 330757))
 (set.gloc.of record-type-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-rcd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 334857))
   (if.false.call
     (push.const . record-type-rcd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 335919))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 335881))
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 336901))
 (set.gloc.of record-type-rcd)
 (ret.const.unspec))

;
((call
   (call
     (push.const . &condition)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 6159))
   (push)
   (extend . 1)
   (push.const . &condition)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 7183))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 8197))
 (set.gloc.of &condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition-component)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/condition.scm" . 10292))
 (set.gloc.of compound-condition-component)
 (ret.const.unspec))
((close
   (0 1 . condition)
   (push.const . type:condition)
   (call
     (push.gloc.of append)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of condition? "./boot/condition.scm" . 17438))
         (if.false.call
           (push.const . condition)
           (push.const . "expected condition, but got ~r")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/condition.scm" . 18494)
           (push.iloc.1 . 0)
           (apply.gloc.of assertion-violation "./boot/condition.scm" . 18462))
         (push.iloc.0 . 0)
         (apply.gloc.of simple-conditions "./boot/condition.scm" . 19482))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/condition.scm" . 16403))
     (push)
     (apply.gloc.of apply "./boot/condition.scm" . 15372))
   (push)
   (ret.subr.gloc.of tuple "./boot/condition.scm" . 14341))
 (set.gloc.of condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition?)
   (push.iloc.0 . 0)
   (subr.gloc.of tuple? 1 "./boot/condition.scm" . 24586)
   (if.false.ret)
   (push.const . type:condition)
   (push.iloc.0 . 0)
   (push.const . 0)
   (subr.gloc.of tuple-ref 2 "./boot/condition.scm" . 25631)
   (ret.eq? "./boot/condition.scm" . 25610))
 (set.gloc.of compound-condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-condition?)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/condition.scm" . 29706))
   (if.false.ret)
   (touch.gloc.of rtd-ancestor?)
   (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 30745))
   (push)
   (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 30774))
   (push)
   (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 30730))
 (set.gloc.of simple-condition?)
 (ret.const.unspec))
((close
   (1 0 . condition?)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 34825))
   (if.true.ret)
   (touch.gloc.of compound-condition?)
   (push.iloc.0 . 0)
   (apply.gloc.of compound-condition? "./boot/condition.scm" . 35849))
 (set.gloc.of condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-conditions)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 39948))
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of list "./boot/condition.scm" . 39970))
   (call
     (touch.gloc.of compound-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition? "./boot/condition.scm" . 40972))
   (if.true
     (touch.gloc.of compound-condition-component)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition-component "./boot/condition.scm" . 40996))
   (push.const . simple-conditions)
   (push.const . "expected condition, but got ~r")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/condition.scm" . 43060)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 43020))
 (set.gloc.of simple-conditions)
 (ret.const.unspec))
((close
   (1 0 . condition-predicate)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 47128))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 47113))
   (if.false.call
     (push.const . condition-predicate)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 48179)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 48137))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 50190))
     (if.true
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 51233))
       (push)
       (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 51214))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 52238))
     (if.true
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of rtd-ancestor?)
         (push.iloc 2 . 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 53307))
         (push)
         (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 53288))
       (call
         (touch.gloc.of compound-condition-component)
         (push.iloc.0 . 0)
         (apply.gloc.of compound-condition-component "./boot/condition.scm" . 54292))
       (push)
       (apply.gloc.of any1 "./boot/condition.scm" . 53262))
     (ret.const . #f)))
 (set.gloc.of condition-predicate)
 (ret.const.unspec))
((close
   (2 0 . wrong-type)
   (push.const . "condition accessor")
   (push.const . "expected condition of a subtype of ~s, but got ~r")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 3 "./boot/condition.scm" . 62515)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 62473))
 (set.gloc.of |wrong-type`2|)
 (close
   (2 0 . condition-accessor)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 64536))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 64521))
   (if.false.call
     (push.const . condition-accessor)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 65586)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 65545))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 68622))
     (if.true
       (call
         (call
           (touch.gloc.of rtd-ancestor?)
           (push.iloc.1 . 0)
           (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 69669))
           (push)
           (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 69650))
         (if.true.ret)
         (touch.gloc.of |wrong-type`2|)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 69687))
       (push.iloc.0 . 0)
       (apply.iloc (1 . 1) "./boot/condition.scm" . 70670))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 71694))
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of rtd-ancestor?)
             (push.iloc 2 . 0)
             (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 72775))
             (push)
             (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 72756))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call
           (touch.gloc.of compound-condition-component)
           (push.iloc.0 . 0)
           (apply.gloc.of compound-condition-component "./boot/condition.scm" . 73755))
         (push)
         (apply.gloc.of any1 "./boot/condition.scm" . 72725))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (apply.iloc (2 . 1) "./boot/condition.scm" . 72718))
       (touch.gloc.of |wrong-type`2|)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 76821))
     (touch.gloc.of |wrong-type`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 78862)))
 (set.gloc.of condition-accessor)
 (ret.const.unspec))
((close
   (1 0 . list-parents)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/condition.scm" . 86025))
 (set.gloc.of |list-parents`2|)
 (close
   (2 0 . loop)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-parent "./boot/condition.scm" . 87058))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |loop`7|)
     (push.iloc.0 . 0)
     (call (push.iloc.0 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 88111))
     (push)
     (iloc.1 . 1)
     (push.cons)
     (apply.gloc.of |loop`7| "./boot/condition.scm" . 88097))
   (push.cdr.iloc (1 . 1) "./boot/condition.scm" . 89120)
   (ret.subr.gloc.of reverse "./boot/condition.scm" . 89111))
 (set.gloc.of |loop`7|)
 (close
   (2 0 . describe-condition)
   (call (push.iloc.0 . 1) (apply.gloc.of condition? "./boot/condition.scm" . 91148))
   (if.true
     (subr.gloc.of make-string-output-port 0)
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . "  #<condition~!")
     (subr.gloc.of format 2 "./boot/condition.scm" . 93198)
     (call
       (call (push.iloc.1 . 1) (apply.gloc.of simple-conditions "./boot/condition.scm" . 94233))
       (push)
       (extend . 1)
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 96295))
         (push)
         (extend . 1)
         (call (push.iloc.0 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 97322))
         (push)
         (call
           (touch.gloc.of |list-parents`2|)
           (push.iloc.0 . 0)
           (apply.gloc.of |list-parents`2| "./boot/condition.scm" . 98349))
         (push)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of record-type-field-names "./boot/condition.scm" . 99386))
         (push)
         (push.subr.gloc.of vector-length 1 "./boot/condition.scm" . 99371)
         (extend . 3)
         (call
           (call
             (push.iloc 3 . 0)
             (push.subr.gloc.of length 1 "./boot/condition.scm" . 100396)
             (push.const . 1)
             (subr.gloc.of > 2 "./boot/condition.scm" . 100393)
             (if.true.ret)
             (push.iloc.0 . 2)
             (push.const . 1)
             (ret.subr.gloc.of > "./boot/condition.scm" . 100412))
           (if.false.ret)
           (push.iloc 4 . 0)
           (push.const . "~%   ")
           (ret.subr.gloc.of format "./boot/condition.scm" . 101413))
         (push.iloc 4 . 0)
         (push.const . " ~a")
         (push.iloc.0 . 0)
         (subr.gloc.of format 3 "./boot/condition.scm" . 102432)
         (call
           (iloc.0 . 1)
           (if.not.pair?.ret.const . #f)
           (push.iloc 4 . 0)
           (push.const . " ~s")
           (push.iloc.0 . 1)
           (ret.subr.gloc.of format "./boot/condition.scm" . 103477))
         (=n.iloc (0 . 2) 1 "./boot/condition.scm" . 104487)
         (if.true
           (push.iloc 4 . 0)
           (push.const . ": ~s")
           (call
             (push.iloc 2 . 0)
             (call
               (push.iloc.1 . 0)
               (push.const . 0)
               (apply.gloc.of record-accessor "./boot/condition.scm" . 105531))
             (apply))
           (push)
           (ret.subr.gloc.of format "./boot/condition.scm" . 105511))
         (>n.iloc (0 . 2) 1 "./boot/condition.scm" . 106535)
         (if.true
           (extend.enclose+
             (2 0 . loop)
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.iloc 6 . 0)
             (push.const . "~%     ~a: ~s")
             (push.car.iloc (0 . 1) "./boot/condition.scm" . 111694)
             (call
               (push.iloc 4 . 0)
               (call
                 (push.iloc 3 . 0)
                 (push.iloc.0 . 0)
                 (apply.gloc.of record-accessor "./boot/condition.scm" . 111705))
               (apply))
             (push)
             (subr.gloc.of format 4 "./boot/condition.scm" . 111666)
             (push.n+.iloc (0 . 0) 1 "./boot/condition.scm" . 112696)
             (push.cdr.iloc (0 . 1) "./boot/condition.scm" . 112704)
             (apply.iloc+ (1 . 0) "./boot/condition.scm" . 112690))
           (push.const . 0)
           (call
             (push.iloc 2 . 0)
             (apply.gloc.of record-type-field-names "./boot/condition.scm" . 107584))
           (push)
           (push.subr.gloc.of vector->list 1 "./boot/condition.scm" . 107570)
           (apply.iloc+ (0 . 0) "./boot/condition.scm" . 108585))
         (ret.const.unspec))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/condition.scm" . 94222))
     (push.iloc.0 . 0)
     (push.const . "~%   >")
     (subr.gloc.of format 2 "./boot/condition.scm" . 114702)
     (push.iloc.1 . 0)
     (push.const . "~a~!")
     (push.iloc.0 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/condition.scm" . 115746)
     (ret.subr.gloc.of format "./boot/condition.scm" . 115726))
   (push.iloc.0 . 0)
   (push.const . "~s~!")
   (push.iloc.0 . 1)
   (ret.subr.gloc.of format "./boot/condition.scm" . 117772))
 (set.gloc.of describe-condition)
 (ret.const.unspec))
((call
   (call
     (push.const . &message)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 120885))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable message)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 120846))
   (push)
   (extend . 1)
   (push.const . &message)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 121912))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 121872))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 122887))
 (set.gloc.of &message)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 123956))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 123936))
 (set.gloc.of make-message-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 124977))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 124956))
 (set.gloc.of message-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 125999))
   (push)
   (call
     (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 126043))
     (push)
     (push.const . 0)
     (apply.gloc.of record-accessor "./boot/condition.scm" . 126026))
   (push)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 125979))
 (set.gloc.of condition-message)
 (ret.const.unspec))
((call
   (call
     (push.const . &warning)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 129077))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 129038))
   (push)
   (extend . 1)
   (push.const . &warning)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 130104))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 130064))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 131079))
 (set.gloc.of &warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 132138))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 132118))
 (set.gloc.of make-warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 133159))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 133138))
 (set.gloc.of warning?)
 (ret.const.unspec))
((call
   (call
     (push.const . &serious)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 136245))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 136206))
   (push)
   (extend . 1)
   (push.const . &serious)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 137272))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 137232))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 138247))
 (set.gloc.of &serious)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 139316))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 139296))
 (set.gloc.of make-serious-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 140337))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 140316))
 (set.gloc.of serious-condition?)
 (ret.const.unspec))
((call
   (call
     (push.const . &error)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 143411))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 143374))
   (push)
   (extend . 1)
   (push.const . &error)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 144440))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 144400))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 145415))
 (set.gloc.of &error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 146472))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 146452))
 (set.gloc.of make-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 147493))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 147472))
 (set.gloc.of error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &violation)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 150583))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 150542))
   (push)
   (extend . 1)
   (push.const . &violation)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 151608))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 151568))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 152583))
 (set.gloc.of &violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 153644))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 153624))
 (set.gloc.of make-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 154665))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 154644))
 (set.gloc.of violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &assertion)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 157751))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 157710))
   (push)
   (extend . 1)
   (push.const . &assertion)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 158776))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 158736))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 159751))
 (set.gloc.of &assertion)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 160822))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 160802))
 (set.gloc.of make-assertion-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 161843))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 161822))
 (set.gloc.of assertion-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &irritants)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 164919))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable irritants)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 164878))
   (push)
   (extend . 1)
   (push.const . &irritants)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 165944))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 165904))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 166919))
 (set.gloc.of &irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 167983))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 167966))
 (set.gloc.of &irritants-irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 169014))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 168994))
 (set.gloc.of make-irritants-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 170035))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 170014))
 (set.gloc.of irritants-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 171057))
   (push)
   (push.gloc.of &irritants-irritants)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 171037))
 (set.gloc.of condition-irritants)
 (ret.const.unspec))
((call
   (call
     (push.const . &who)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 174129))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable who)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 174094))
   (push)
   (extend . 1)
   (push.const . &who)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 175160))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 175120))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 176135))
 (set.gloc.of &who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 177187))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 177170))
 (set.gloc.of &who-who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 178224))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 178204))
 (set.gloc.of make-who-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 179245))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 179224))
 (set.gloc.of who-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 180267))
   (push)
   (push.gloc.of &who-who)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 180247))
 (set.gloc.of condition-who)
 (ret.const.unspec))
((call
   (call
     (push.const . &non-continuable)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 183357))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 183310))
   (push)
   (extend . 1)
   (push.const . &non-continuable)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 184376))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 184336))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 185351))
 (set.gloc.of &non-continuable)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 186428))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 186408))
 (set.gloc.of make-non-continuable-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 187449))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 187428))
 (set.gloc.of non-continuable-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &implementation-restriction)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 190536))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 190478))
   (push)
   (extend . 1)
   (push.const . &implementation-restriction)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 191544))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 191504))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 192519))
 (set.gloc.of &implementation-restriction)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 194583))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 194563))
 (set.gloc.of make-implementation-restriction-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 196632))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 196611))
 (set.gloc.of implementation-restriction-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &lexical)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 199733))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 199694))
   (push)
   (extend . 1)
   (push.const . &lexical)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 200760))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 200720))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 201735))
 (set.gloc.of &lexical)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 202804))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 202784))
 (set.gloc.of make-lexical-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 203825))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 203804))
 (set.gloc.of lexical-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &syntax)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 206900))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable form) (immutable subform)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 206862))
   (push)
   (extend . 1)
   (push.const . &syntax)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 207928))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 207888))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 208903))
 (set.gloc.of &syntax)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 209959))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 209942))
 (set.gloc.of &syntax-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 210986))
   (push)
   (push.const . 1)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 210969))
 (set.gloc.of &syntax-subform)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 212019))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 211999))
 (set.gloc.of make-syntax-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 213040))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 213019))
 (set.gloc.of syntax-violation?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 214067))
   (push)
   (push.gloc.of &syntax-form)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 214047))
 (set.gloc.of syntax-violation-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 215094))
   (push)
   (push.gloc.of &syntax-subform)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 215074))
 (set.gloc.of syntax-violation-subform)
 (ret.const.unspec))
((call
   (call
     (push.const . &undefined)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 218167))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 218126))
   (push)
   (extend . 1)
   (push.const . &undefined)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 219192))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 219152))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 220167))
 (set.gloc.of &undefined)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 221238))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 221218))
 (set.gloc.of make-undefined-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 222259))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 222238))
 (set.gloc.of undefined-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 225329))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 225294))
   (push)
   (extend . 1)
   (push.const . &i/o)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 226360))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 226320))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 227335))
 (set.gloc.of &i/o)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 228396))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 228376))
 (set.gloc.of make-i/o-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 229417))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 229396))
 (set.gloc.of i/o-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-read)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 232502))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 232462))
   (push)
   (extend . 1)
   (push.const . &i/o-read)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 233528))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 233488))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 234503))
 (set.gloc.of &i/o-read)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 235569))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 235549))
 (set.gloc.of make-i/o-read-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 236590))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 236569))
 (set.gloc.of i/o-read-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-write)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 239671))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 239630))
   (push)
   (extend . 1)
   (push.const . &i/o-write)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 240696))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 240656))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 241671))
 (set.gloc.of &i/o-write)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 242738))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 242718))
 (set.gloc.of make-i/o-write-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 243759))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 243738))
 (set.gloc.of i/o-write-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-invalid-position)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 246850))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable position)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 246798))
   (push)
   (extend . 1)
   (push.const . &i/o-invalid-position)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 247864))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 247824))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 248839))
 (set.gloc.of &i/o-invalid-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 250900))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 250883))
 (set.gloc.of &i/o-invalid-position-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 252951))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 252931))
 (set.gloc.of make-i/o-invalid-position-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 254010))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 253989))
 (set.gloc.of i/o-invalid-position-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 256023))
   (push)
   (push.gloc.of &i/o-invalid-position-position)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 256003))
 (set.gloc.of i/o-error-position)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-filename)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 259130))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable filename)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 259086))
   (push)
   (extend . 1)
   (push.const . &i/o-filename)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 260152))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 260112))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 261127))
 (set.gloc.of &i/o-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 262193))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 262176))
 (set.gloc.of &i/o-filename-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 263221))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 263201))
 (set.gloc.of make-i/o-filename-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 264242))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 264221))
 (set.gloc.of i/o-filename-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 265264))
   (push)
   (push.gloc.of &i/o-filename-filename)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 265244))
 (set.gloc.of i/o-error-filename)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-protection)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 268353))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 268302))
   (push)
   (extend . 1)
   (push.const . &i/o-file-protection)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 269368))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 269328))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 270343))
 (set.gloc.of &i/o-file-protection)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 272407))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 272387))
 (set.gloc.of make-i/o-file-protection-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 273465))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 273444))
 (set.gloc.of i/o-file-protection-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-is-read-only)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 276547))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 276494))
   (push)
   (extend . 1)
   (push.const . &i/o-file-is-read-only)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 277560))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 277520))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 278535))
 (set.gloc.of &i/o-file-is-read-only)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 279614))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 279594))
 (set.gloc.of make-i/o-file-is-read-only-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 280635))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 280614))
 (set.gloc.of i/o-file-is-read-only-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-already-exists)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 283717))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 283662))
   (push)
   (extend . 1)
   (push.const . &i/o-file-already-exists)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 284728))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 284688))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 285703))
 (set.gloc.of &i/o-file-already-exists)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 286784))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 286764))
 (set.gloc.of make-i/o-file-already-exists-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 287805))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 287784))
 (set.gloc.of i/o-file-already-exists-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-does-not-exist)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 290885))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 290830))
   (push)
   (extend . 1)
   (push.const . &i/o-file-does-not-exist)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 291896))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 291856))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 292871))
 (set.gloc.of &i/o-file-does-not-exist)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 293952))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 293932))
 (set.gloc.of make-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 294973))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 294952))
 (set.gloc.of i/o-file-does-not-exist-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-port)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 298038))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable port)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 297998))
   (push)
   (extend . 1)
   (push.const . &i/o-port)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 299064))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 299024))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 300039))
 (set.gloc.of &i/o-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 301097))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 301080))
 (set.gloc.of &i/o-port-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 302129))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 302109))
 (set.gloc.of make-i/o-port-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 303150))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 303129))
 (set.gloc.of i/o-port-error?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 304172))
   (push)
   (push.gloc.of &i/o-port-port)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 304152))
 (set.gloc.of i/o-error-port)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-decoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 307258))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 307214))
   (push)
   (extend . 1)
   (push.const . &i/o-decoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 308280))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 308240))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 309255))
 (set.gloc.of &i/o-decoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 310325))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 310305))
 (set.gloc.of make-i/o-decoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 311346))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 311325))
 (set.gloc.of i/o-decoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-encoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 314426))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable char)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 314382))
   (push)
   (extend . 1)
   (push.const . &i/o-encoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 315448))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 315408))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 316423))
 (set.gloc.of &i/o-encoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 317485))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 317468))
 (set.gloc.of &i/o-encoding-char)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 318517))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 318497))
 (set.gloc.of make-i/o-encoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 319538))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 319517))
 (set.gloc.of i/o-encoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 320565))
   (push)
   (push.gloc.of &i/o-encoding-char)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 320545))
 (set.gloc.of i/o-encoding-error-char)
 (ret.const.unspec))

;
((call (push.const . 100) (apply.gloc.of make-parameter "./boot/pp.scm" . 62498))
 (set.gloc.of pretty-print-line-length)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/pp.scm" . 63525))
 (set.gloc.of pretty-print-initial-indent)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 64548))
 (set.gloc.of pretty-print-maximum-lines)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 65572))
 (set.gloc.of pretty-print-unwrap-syntax)
 (ret.const.unspec))
((close
   (1 0 . indent-type3?)
   (push.iloc.0 . 0)
   (push.const do let-optionals)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 87051))
 (set.gloc.of |indent-type3?`4|)
 (close
   (2 0 . fits?)
   (>=n.iloc (0 . 0) 0 "./boot/pp.scm" . 91152)
   (if.false.ret)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 1) "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of |.cdar| 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of |.cddar| 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 2 . 1)
     (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 3 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc 3 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (const . |.&BREAK|)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true.ret.const . #t)
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (const . |.&FLAT|)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.n+.iloc (4 . 0) -1 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (ret.subr.gloc.of string? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of - 2 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (const . |.&GROUP|)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (push.const . |.&FLAT|)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (const . |.&NEST|)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cadr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of + 2 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cddr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (iloc.0 . 0)
   (if.true
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (extend . 2)
     (touch.gloc.of |fits?`4|)
     (push.iloc 5 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (5 . 1) "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (ret.const . #f))
 (set.gloc.of |fits?`4|)
 (close
   (1 0 . indent-type1?)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     define-macro
     define-inline
     define-constant
     syntax-rules
     syntax-case
     with-syntax
     lambda
     let-syntax
     letrec-syntax
     let
     letrec
     let*
     letrec
     letrec*
     let-values
     let*-values
     destructuring-match
     parameterize)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 74763))
 (set.gloc.of |indent-type1?`4|)
 (close
   (1 0 . parse)
   (iloc.0 . 0)
   (if.pair?
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (cddr.iloc (1 . 0) "./boot/pp.scm" . 149522)
       (ret.null? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (cddr.iloc (2 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "'")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quasiquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "`")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote-splicing)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",@")
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . let)
       (if.not.eq?.ret.const . #f)
       (cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (if.not.symbol?.ret.const . #f)
       (push.iloc 3 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(let ~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . 4)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type1?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type1?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type2?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type2?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . 2)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type3?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type3?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (push.iloc 3 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.car.iloc (4 . 0) "./boot/pp.scm" . 149522)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 5 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 3 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of symbol? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . |.&GROUP|)
       (push.const . "(")
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc 3 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
     (push.const . |.&GROUP|)
     (push.const . "(")
     (push.const . |.&NEST|)
     (push.const . 1)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.iloc 3 . 0)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 149522)
     (push.const ")")
     (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/pp.scm" . 184338)
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/pp.scm" . 185369)
     (push.const . 0)
     (subr.gloc.of = 2 "./boot/pp.scm" . 185366)
     (if.true.ret.const . "#()")
     (push.const . |.&GROUP|)
     (push.const . "#(")
     (push.const . |.&NEST|)
     (push.const . 2)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 187453)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 187441))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 185362)
     (push.const ")")
     (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 185362))
   (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/pp.scm" . 188434))
   (if.true
     (push.const . "~u")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/pp.scm" . 189458))
   (push.const . "~s")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/pp.scm" . 191506))
 (set.gloc.of |parse`4|)
 (close
   (1 0 . symbol->length)
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/pp.scm" . 134170)
   (ret.subr.gloc.of string-length "./boot/pp.scm" . 134155))
 (set.gloc.of |symbol->length`4|)
 (close
   (1 0 . indent-type2?)
   (push.iloc.0 . 0)
   (push.const if cond case and or set! import export cons map for-each exists for-all)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 82955))
 (set.gloc.of |indent-type2?`4|)
 (close
   (1 0 . parse-list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 139289)
   (if.null?
     (call
       (touch.gloc.of |parse`4|)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 140319)
       (apply.gloc.of |parse`4| "./boot/pp.scm" . 140312))
     (push)
     (ret.subr.gloc.of list "./boot/pp.scm" . 140306))
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 141337)
   (if.pair?
     (call
       (touch.gloc.of |parse`4|)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 142368)
       (apply.gloc.of |parse`4| "./boot/pp.scm" . 142361))
     (push)
     (push.const . #\;)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 142395)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 142383))
     (push)
     (ret.subr.gloc.of cons* "./boot/pp.scm" . 142354))
   (call
     (touch.gloc.of |parse`4|)
     (push.car.iloc (0 . 0) "./boot/pp.scm" . 144415)
     (apply.gloc.of |parse`4| "./boot/pp.scm" . 144408))
   (push)
   (push.const . #\;)
   (push.const . ".")
   (push.const . #\;)
   (call
     (touch.gloc.of |parse`4|)
     (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 144445)
     (apply.gloc.of |parse`4| "./boot/pp.scm" . 144438))
   (push)
   (ret.subr.gloc.of list "./boot/pp.scm" . 144402))
 (set.gloc.of |parse-list`4|)
 (close
   (1 1 . pretty-print)
   (call
     (iloc.0 . 1)
     (if.pair? (push.iloc.0 . 1) (ret.subr.gloc.of car "./boot/pp.scm" . 69666))
     (ret.subr.gloc.of current-output-port "./boot/pp.scm" . 69677))
   (push)
   (call
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70686))
     (if.false.ret)
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70718))
     (push)
     (push.const . 1)
     (ret.subr.gloc.of - "./boot/pp.scm" . 70715))
   (push)
   (extend . 2)
   (extend.enclose
     (3 0 . print)
     (iloc.0 . 2)
     (if.null?.ret.const . #t)
     (push.gloc.of string?)
     (extend . 1)
     (call
       (iloc.1 . 2)
       (if.not.pair?.ret.const . #f)
       (car.iloc (1 . 2) "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of |.cdar| 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of |.cddar| 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 2 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 3 . 2)
       (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 4 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc 3 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (const . |.&BREAK|)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (call
         (push.iloc 8 . 1)
         (const . #f)
         (if.eq?.ret.const . #t)
         (push.iloc 8 . 1)
         (push.const . 0)
         (ret.subr.gloc.of > "./boot/pp.scm" . 104463))
       (if.true
         (call
           (iloc 8 . 1)
           (if.false.ret)
           (n+.iloc (8 . 1) -1 "./boot/pp.scm" . 104463)
           (set.iloc 8 . 1)
           (ret.const.unspec))
         (push.iloc 8 . 0)
         (push.const . #\linefeed)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
         (call
           (extend.enclose+
             (1 0 . loop)
             (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.iloc 10 . 0)
             (push.const . #\space)
             (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 104463)
             (apply.iloc+ (1 . 0) "./boot/pp.scm" . 104463))
           (push.iloc.1 . 1)
           (apply.iloc+ (0 . 0) "./boot/pp.scm" . 104463))
         (push.iloc 6 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
       (ret.const.unspec))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (const . |.&FLAT|)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (extend . 1)
       (push.iloc 8 . 0)
       (push.const . #\space)
       (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.n+.iloc (6 . 1) 1 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (apply.iloc (4 . 0) "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 8 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of put-string 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (const . |.&GROUP|)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 3)
       (push.iloc.0 . 2)
       (push.const . |.&FLAT|)
       (push.iloc.0 . 1)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (iloc.0 . 0)
       (push.cons)
       (extend . 1)
       (call
         (touch.gloc.of |fits?`4|)
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.subr.gloc.of - 2 "./boot/pp.scm" . 104463)
         (push.iloc.0 . 0)
         (apply.gloc.of |fits?`4| "./boot/pp.scm" . 104463))
       (if.true
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
       (push.iloc 7 . 0)
       (push.iloc 7 . 1)
       (push.iloc.1 . 2)
       (push.const . |.&BREAK|)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (iloc.1 . 0)
       (push.cons)
       (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (const . |.&NEST|)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cadr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cddr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.cons)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (iloc.0 . 0)
     (if.true
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (push.cdr.iloc (6 . 2) "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 104463)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (ret.const . #f))
   (call
     (call
       (touch.gloc.of circular-tree?)
       (push.iloc 2 . 0)
       (apply.gloc.of circular-tree? "./boot/pp.scm" . 193547))
     (if.true
       (push.iloc.1 . 0)
       (push.const . "~w")
       (push.iloc 2 . 0)
       (ret.subr.gloc.of format "./boot/pp.scm" . 194571))
     (call (apply.gloc.of pretty-print-line-length "./boot/pp.scm" . 195608))
     (push)
     (extend . 1)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of collect-notify 0 "./boot/pp.scm" . 197647)
       (set.iloc 1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 197647))
     (push.close
       (0 0)
       (push.iloc 2 . 0)
       (push.const . 0)
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 197666))
       (push)
       (push.const . |.&FLAT|)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc 5 . 0)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 197704))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 197647)
       (push.subr.gloc.of |.list| 1 "./boot/pp.scm" . 197647)
       (apply.iloc (3 . 0) "./boot/pp.scm" . 197647))
     (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 197647))
     (apply.gloc.of |.dynamic-wind| "./boot/pp.scm" . 197647))
   (call
     (iloc.1 . 1)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of <= "./boot/pp.scm" . 198688))
   (if.true
     (push.iloc.1 . 0)
     (push.const . #\linefeed)
     (subr.gloc.of put-char 2 "./boot/pp.scm" . 199694)
     (call
       (extend.enclose+
         (1 0 . loop)
         (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 200769)
         (if.false.ret)
         (push.iloc 3 . 0)
         (push.const . #\space)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 200777)
         (if.false.ret)
         (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 200807)
         (apply.iloc+ (1 . 0) "./boot/pp.scm" . 200801))
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 200732))
       (push)
       (apply.iloc+ (0 . 0) "./boot/pp.scm" . 200718))
     (push.iloc.1 . 0)
     (push.const . "  ...")
     (ret.subr.gloc.of put-string "./boot/pp.scm" . 201742))
   (ret.const.unspec))
 (set.gloc.of pretty-print)
 (ret.const.unspec))

;
((close
   (1 0 . core-eval)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of backtrace 0 "./boot/eval.scm" . 8199)
     (set.iloc 1 . 0)
     (push.const . #f)
     (ret.subr.gloc.of backtrace "./boot/eval.scm" . 8199))
   (push.close
     (0 0)
     (touch.gloc.of interpret-coreform)
     (push.iloc 2 . 0)
     (apply.gloc.of interpret-coreform "./boot/eval.scm" . 8199))
   (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of backtrace "./boot/eval.scm" . 8199))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 8199))
 (set.gloc.of core-eval)
 (ret.const.unspec))
((close
   (1 0 . compile)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
     (set.iloc 1 . 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 1)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
   (push.close
     (0 0)
     (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 14361))
     (push)
     (apply.gloc.of compile-coreform "./boot/eval.scm" . 14343))
   (push.close
     (0 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 0)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 14343))
 (set.gloc.of compile)
 (ret.const.unspec))
((close
   (1 0 . interpret)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call
     (push.const . #f)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
       (set.iloc 1 . 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 1)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
     (push.close
       (0 0)
       (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 21536))
       (push)
       (apply.gloc.of compile-coreform "./boot/eval.scm" . 21518))
     (push.close
       (0 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 0)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 21518))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 22535))
 (set.gloc.of interpret)
 (ret.const.unspec))
((close
   (1 0 . interpret-coreform)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call (push.iloc.0 . 0) (apply.gloc.of compile-coreform "./boot/eval.scm" . 26656))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 27655))
 (set.gloc.of interpret-coreform)
 (ret.const.unspec))
((close
   (0 1 . environment)
   (call
     (touch.gloc.of parse-imports)
     (push.const . environment)
     (iloc.0 . 0)
     (push.cons)
     (push.iloc.0 . 0)
     (apply.gloc.of parse-imports "./boot/eval.scm" . 31749))
   (push.const . type:eval-environment)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/eval.scm" . 32773))
 (set.gloc.of environment)
 (ret.const.unspec))
((close
   (2 0 . eval)
   (call
     (touch.gloc.of environment?)
     (push.iloc.0 . 1)
     (apply.gloc.of environment? "./boot/eval.scm" . 36876))
   (if.true
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 38926)
       (set.iloc 1 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 38926))
     (push.close
       (0 0)
       (touch.gloc.of interpret)
       (push.iloc 2 . 0)
       (apply.gloc.of interpret "./boot/eval.scm" . 38926))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 38926))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 38926))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 40981)
   (push.const . type:eval-environment)
   (subr.gloc.of eq? 2 "./boot/eval.scm" . 40976)
   (if.false.call
     (push.const . eval)
     (push.const . "expected environment, but got ~r, as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/eval.scm" . 42027)
     (apply.gloc.of assertion-violation "./boot/eval.scm" . 42000))
   (touch.gloc.of interpret)
   (push.const . begin)
   (push.const . library)
   (push.const |.&ANONYMOUS|)
   (push.const export |.&RESULT|)
   (push.const . import)
   (push.const rename (only (core intrinsics) define) (define |.&DEFINE|))
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 47142)
   (push.subr.gloc.of |.cons*| 3 "./boot/eval.scm" . 43020)
   (push.const . |.&DEFINE|)
   (push.const . |.&RESULT|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 3 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 5 "./boot/eval.scm" . 43020)
   (push.const . let)
   (push.const . result)
   (call
     (touch.gloc.of generate-global-id)
     (call
       (touch.gloc.of generate-library-id)
       (push.const |.&ANONYMOUS|)
       (apply.gloc.of generate-library-id "./boot/eval.scm" . 49213))
     (push)
     (push.const . |.&RESULT|)
     (apply.gloc.of generate-global-id "./boot/eval.scm" . 49193))
   (push)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 1 "./boot/eval.scm" . 43020)
   (push.const . |.unintern-scheme-library|)
   (push.const . quote)
   (call
     (touch.gloc.of generate-library-id)
     (push.const |.&ANONYMOUS|)
     (apply.gloc.of generate-library-id "./boot/eval.scm" . 50232))
   (push)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 43020)
   (push.const result)
   (push.subr.gloc.of |.cons*| 4 "./boot/eval.scm" . 43020)
   (push.subr.gloc.of |.list| 3 "./boot/eval.scm" . 43020)
   (apply.gloc.of interpret "./boot/eval.scm" . 43020))
 (set.gloc.of eval)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 53277))
 (set.gloc.of scheme-load-verbose)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/eval.scm" . 54299))
 (set.gloc.of scheme-load-paths)
 (ret.const.unspec))
((close
   (1 0 . expand-path)
   (call
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 58396)
     (push.const . 1)
     (subr.gloc.of > 2 "./boot/eval.scm" . 58393)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . 1)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 58426)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 58420))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 59427)
     (push.const . #\~)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 59419))
   (if.true
     (push.const . "~a~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 60445))
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 60480)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 60462)
     (ret.subr.gloc.of format "./boot/eval.scm" . 60430))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 61475)
     (push.const . #\.)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 61467))
   (if.true
     (push.const . "~a~/")
     (subr.gloc.of current-directory 0)
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 62531)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 62513)
     (ret.subr.gloc.of format "./boot/eval.scm" . 62478))
   (push.iloc.1 . 0)
   (push.const . ".")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 63502)
   (if.true
     (push.const . "~/")
     (subr.gloc.of current-directory 0)
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 64526))
   (push.iloc.1 . 0)
   (push.const . "~")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 65550)
   (if.true
     (push.const . "~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 66587))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 66574))
   (push.const . "~/")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 68622))
 (set.gloc.of expand-path)
 (ret.const.unspec))
((close
   (1 0 . confirm-path)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 79886)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of |confirm-path`2|)
 (close
   (1 0 . locate)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 83987)
   (push.const . 0)
   (subr.gloc.of = 2 "./boot/eval.scm" . 83984)
   (if.true
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 85008))
   (call
     (push.iloc.0 . 0)
     (push.const . ":")
     (subr.gloc.of string-contains 2 "./boot/eval.scm" . 86036)
     (if.true.ret)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 86069)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 86063))
   (if.true
     (call
       (touch.gloc.of |confirm-path`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 87060))
     (if.true.ret)
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 87080))
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 88086)
   (push.const #\. #\~)
   (subr.gloc.of memq 2 "./boot/eval.scm" . 88080)
   (if.true
     (call
       (touch.gloc.of |confirm-path`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/eval.scm" . 89122))
       (push)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 89108))
     (if.true.ret)
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 89142))
   (call
     (touch.gloc.of any1)
     (push.close
       (1 0)
       (touch.gloc.of |confirm-path`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (push.const . "/")
         (push.iloc.1 . 0)
         (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 90173)
         (apply.gloc.of expand-path "./boot/eval.scm" . 90160))
       (push)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 90146))
     (push.const . ".")
     (call (apply.gloc.of scheme-load-paths "./boot/eval.scm" . 91168))
     (push.cons)
     (apply.gloc.of any1 "./boot/eval.scm" . 90128))
   (if.true.ret)
   (touch.gloc.of |path-not-found`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 93200))
 (set.gloc.of |locate`2|)
 (close
   (1 0 . path-not-found)
   (push.const . load)
   (push.const . "~a~/~a not found")
   (push.const . #\")
   (push.iloc.0 . 0)
   (push.const . #\")
   (push.subr.gloc.of format 4 "./boot/eval.scm" . 75812)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 75785))
 (set.gloc.of |path-not-found`2|)
 (close
   (1 0 . load)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/eval.scm" . 95244)
   (if.true
     (call
       (touch.gloc.of auto-compile-cache-update)
       (apply.gloc.of auto-compile-cache-update "./boot/eval.scm" . 96268))
     (touch.gloc.of load-scheme-library)
     (push.iloc.0 . 0)
     (apply.gloc.of load-scheme-library "./boot/eval.scm" . 97292))
   (call
     (touch.gloc.of |locate`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |locate`2| "./boot/eval.scm" . 99356))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 100371))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 100393))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 101402))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (push.iloc.1 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 104467)
     (push.iloc.0 . 0)
     (apply.gloc.of raise "./boot/eval.scm" . 105491))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 112661)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 112661)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 112661)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 112661)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 112661)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 112661)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 112661)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 112661))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (call
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 113717)
           (if.false.ret)
           (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 113729))
         (push)
         (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 113687)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 114723)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 115744)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 116768))
         (call
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 118818))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 119840))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 112661))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 112661)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 112661)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 112661)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 112661))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 108593))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 101390))
 (set.gloc.of load)
 (ret.const.unspec))
((close
   (1 0 . load-cache)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 123914))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 123936))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 124945))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (push.iloc.1 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 128010)
     (push.iloc.0 . 0)
     (apply.gloc.of raise "./boot/eval.scm" . 129034))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-environment 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 135180)
       (set.iloc 1 . 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 135180)
       (set.iloc 1 . 1)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 135180)
       (set.iloc 1 . 2)
       (push.const . #f)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 135180)
       (push.const . #f)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 135180)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 135180))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (push.iloc 5 . 0)
         (push.const . #f)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 136218)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 137239)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 138263))
         (call
           (touch.gloc.of run-vmi)
           (push.const 1 . 0)
           (iloc.0 . 0)
           (push.cons)
           (apply.gloc.of run-vmi "./boot/eval.scm" . 140311))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 141335))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 135180))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 135180)
       (push.iloc.1 . 1)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 135180)
       (push.iloc.1 . 2)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 135180))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 134180))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 124933))
 (set.gloc.of load-cache)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 143390))
 (set.gloc.of auto-compile-verbose)
 (ret.const.unspec))
((close
   (1 0)
   (iloc.0 . 0)
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of string? 1 "./boot/eval.scm" . 150546)
       (if.false.ret)
       (push.const . "~//.")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/eval.scm" . 150572)
       (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 150558))
     (if.true
       (push.const . "~/")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/eval.scm" . 150592))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const
       .
       "~&;; warning in auto-compile-cache: directory ~s not exist (temporary disable caching)~!~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/eval.scm" . 152589)
     (ret.const . #f))
   (ret.iloc 0 . 0))
 (set.gloc.of |.fn1.1`1|)
 (call
   (push.const . #f)
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 148484))
 (set.gloc.of auto-compile-cache)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 160821)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 161848)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 161880)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 161877)
   (ret.subr.gloc.of = "./boot/eval.scm" . 161845))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 164929))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 164914)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 165942)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 166950)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 166976))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 167974)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 168004))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 168998))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 169021))
 (set.gloc.of |.fn3.1`3|)
 (close
   (0 0 . auto-compile-cache-clean)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 157708))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn3.1`3|)
     (call
       (touch.gloc.of filter)
       (push.gloc.of |.fn1.1`1|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 162858)
       (apply.gloc.of filter "./boot/eval.scm" . 159778))
     (push)
     (apply.gloc.of for-each "./boot/eval.scm" . 159761))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-clean)
 (ret.const.unspec))
((close (0 0) (ret.const . #f))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 187447))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 187432)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 188460)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 189468)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 189494))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 190492)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 190522))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 191516))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 191539))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . inconsistent-cache-state)
   (call
     (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 184334))
     (if.false.ret)
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~&;; reset ~s~%")
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 185405))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 185358))
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/eval.scm" . 183303))
 (set.gloc.of |inconsistent-cache-state`2|)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 197685)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 198712)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 198744)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 198741)
   (ret.subr.gloc.of = "./boot/eval.scm" . 198709))
 (set.gloc.of |.fn4.1`4|)
 (close
   (2 0 . call-with-port)
   (push.gloc.of |.fn1.1`1|)
   (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (1 . 1) "./boot/eval.scm" . 179221))
   (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 180245))
   (apply.gloc.of dynamic-wind "./boot/eval.scm" . 177161))
 (set.gloc.of |call-with-port`2|)
 (close
   (0 0 . auto-compile-cache-update)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 194572))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of filter)
       (push.gloc.of |.fn4.1`4|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 199722)
       (apply.gloc.of filter "./boot/eval.scm" . 196642))
     (push)
     (extend . 1)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (call
           (iloc.0 . 1)
           (if.false.ret)
           (push.close
             (1 0)
             (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 204879))
             (push)
             (push.const . "/")
             (push.iloc.0 . 0)
             (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 204864)
             (extend . 1)
             (push.iloc.0 . 0)
             (push.const . ".time")
             (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 205892)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 206902)
             (if.true
               (touch.gloc.of |call-with-port`2|)
               (call
                 (touch.gloc.of make-file-input-port)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-file-input-port "./boot/eval.scm" . 208954))
               (push)
               (push.close
                 (1 0)
                 (push.iloc.0 . 0)
                 (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 211027)
                 (extend . 1)
                 (push.iloc.1 . 0)
                 (subr.gloc.of close-port 1 "./boot/eval.scm" . 212030)
                 (iloc.0 . 0)
                 (>=.iloc (5 . 1) "./boot/eval.scm" . 213061)
                 (if.true
                   (push.iloc 2 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 214085)
                   (push.iloc 3 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 215109)
                   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 216138))
                   (if.false.ret)
                   (push.const . #t)
                   (push.const . "~&;; clean ~s~%")
                   (push.iloc 3 . 0)
                   (ret.subr.gloc.of format "./boot/eval.scm" . 216161))
                 (ret.const.unspec))
               (apply.gloc.of |call-with-port`2| "./boot/eval.scm" . 207926))
             (touch.gloc.of |inconsistent-cache-state`2|)
             (push.iloc 5 . 0)
             (apply.gloc.of |inconsistent-cache-state`2| "./boot/eval.scm" . 218166))
           (push.iloc 2 . 0)
           (apply.gloc.of for-each "./boot/eval.scm" . 202780))
         (ret.const.unspec))
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 222270))
       (push)
       (push.const . "/")
       (push.car.iloc (0 . 0) "./boot/eval.scm" . 222295)
       (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 222255)
       (extend . 1)
       (push.iloc.0 . 0)
       (push.const . ".time")
       (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 223283)
       (extend . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 224293)
       (if.true
         (touch.gloc.of |call-with-port`2|)
         (call
           (touch.gloc.of make-file-input-port)
           (push.iloc.0 . 0)
           (apply.gloc.of make-file-input-port "./boot/eval.scm" . 226345))
         (push)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 228419)
           (extend . 1)
           (push.iloc.1 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 229444)
           (extend . 1)
           (push.iloc 2 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 230463)
           (extend . 1)
           (push.iloc 3 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 231469)
           (call
             (push.iloc 2 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 232510)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 232536)
             (if.false.ret)
             (push.iloc.0 . 0)
             (subr.gloc.of string? 1 "./boot/eval.scm" . 232563)
             (if.false.ret)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 232585))
           (if.true
             (call
               (touch.gloc.of stat-mtime)
               (push.iloc.0 . 0)
               (apply.gloc.of stat-mtime "./boot/eval.scm" . 234551))
             (=.iloc (1 . 0) "./boot/eval.scm" . 234548)
             (if.true
               (push.cdr.iloc (6 . 0) "./boot/eval.scm" . 235578)
               (push.iloc 6 . 1)
               (apply.iloc (7 . 0) "./boot/eval.scm" . 235572))
             (push.cdr.iloc (6 . 0) "./boot/eval.scm" . 237626)
             (call
               (iloc 6 . 1)
               (if.true
                 (iloc 2 . 0)
                 (<.iloc (6 . 1) "./boot/eval.scm" . 239681)
                 (if.true (ret.iloc 2 . 0))
                 (ret.iloc 6 . 1))
               (ret.iloc 2 . 0))
             (push)
             (apply.iloc (7 . 0) "./boot/eval.scm" . 228395))
           (touch.gloc.of |inconsistent-cache-state`2|)
           (push.iloc 8 . 0)
           (apply.gloc.of |inconsistent-cache-state`2| "./boot/eval.scm" . 233524))
         (apply.gloc.of |call-with-port`2| "./boot/eval.scm" . 222236))
       (push.iloc.1 . 0)
       (subr.gloc.of delete-file 1 "./boot/eval.scm" . 242725)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 243754))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; clean ~s~%")
         (push.iloc.1 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 243777))
       (push.cdr.iloc (2 . 0) "./boot/eval.scm" . 244779)
       (push.iloc 2 . 1)
       (apply.iloc (3 . 0) "./boot/eval.scm" . 244773))
     (push.iloc.1 . 0)
     (push.const . #f)
     (apply.iloc (0 . 0) "./boot/eval.scm" . 200723))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-update)
 (ret.const.unspec))
((close
   (4 0 . make-cache)
   (touch.gloc.of |call-with-port`4|)
   (call
     (touch.gloc.of make-file-output-port)
     (push.iloc.0 . 1)
     (apply.gloc.of make-file-output-port "./boot/eval.scm" . 263183))
   (push)
   (push.close
     (1 0)
     (touch.gloc.of |call-with-port`4|)
     (call
       (touch.gloc.of open-script-input-port)
       (push.iloc.1 . 0)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 266261))
     (push)
     (push.close
       (1 0)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 270362)
         (push.iloc 2 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 271386)
         (call
           (iloc 3 . 1)
           (if.false.ret)
           (push.iloc 3 . 1)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 272419)
           (if.false.ret)
           (push.iloc 3 . 1)
           (ret.subr.gloc.of delete-file "./boot/eval.scm" . 272438))
         (push.iloc.0 . 0)
         (apply.gloc.of raise "./boot/eval.scm" . 273434))
       (push.close
         (0 0)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (subr.gloc.of current-source-comments 0)
         (push)
         (subr.gloc.of current-environment 0)
         (push)
         (subr.gloc.of extend-lexical-syntax 0)
         (push)
         (subr.gloc.of backtrace 0)
         (push)
         (extend . 8)
         (push.close
           (0 0)
           (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 280604)
           (set.iloc 1 . 0)
           (subr.gloc.of current-environment 0 "./boot/eval.scm" . 280604)
           (set.iloc 1 . 1)
           (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 280604)
           (set.iloc 1 . 2)
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 280604)
           (set.iloc 1 . 3)
           (push.iloc.1 . 4)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 280604)
           (push.iloc.1 . 5)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 280604)
           (push.iloc.1 . 6)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 280604)
           (push.iloc.1 . 7)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 280604))
         (push.close
           (0 0)
           (extend.enclose+
             (0 0 . loop)
             (call
               (subr.gloc.of backtrace 0 "./boot/eval.scm" . 281660)
               (if.false.ret)
               (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 281672))
             (push)
             (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 281630)
             (push.iloc 5 . 0)
             (subr.gloc.of current-source-comments 0)
             (push)
             (push.const . load)
             (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 282665)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 283687)
             (if.true
               (push.iloc 7 . 0)
               (push.const . "~%")
               (subr.gloc.of format 2 "./boot/eval.scm" . 284711)
               (push.iloc 6 . 0)
               (subr.gloc.of close-port 1 "./boot/eval.scm" . 285735)
               (push.iloc 7 . 0)
               (ret.subr.gloc.of close-port "./boot/eval.scm" . 286759))
             (call
               (push.const . #f)
               (subr.gloc.of make-core-hashtable 0)
               (push)
               (extend . 2)
               (push.close
                 (0 0)
                 (call
                   (touch.gloc.of current-closure-comments)
                   (apply.gloc.of current-closure-comments "./boot/eval.scm" . 291888))
                 (set.iloc 1 . 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 1)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 291888))
               (push.close
                 (0 0)
                 (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 291906))
                 (push)
                 (apply.gloc.of compile-coreform "./boot/eval.scm" . 291888))
               (push.close
                 (0 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 0)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 291888))
               (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 291888))
             (push)
             (extend . 1)
             (push.iloc 8 . 0)
             (push.iloc.0 . 0)
             (subr.gloc.of put-fasl 2 "./boot/eval.scm" . 292905)
             (push.iloc 8 . 0)
             (push.const . "~%")
             (subr.gloc.of format 2 "./boot/eval.scm" . 293929)
             (call
               (touch.gloc.of run-vmi)
               (push.const 1 . 0)
               (iloc.0 . 0)
               (push.cons)
               (apply.gloc.of run-vmi "./boot/eval.scm" . 294953))
             (apply.iloc+ (3 . 0) "./boot/eval.scm" . 295977))
           (apply.iloc+ (0 . 0) "./boot/eval.scm" . 280604))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 280604)
           (push.iloc.1 . 1)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 280604)
           (push.iloc.1 . 2)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 280604)
           (push.iloc.1 . 3)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 280604))
         (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 276536))
       (apply.gloc.of with-exception-handler "./boot/eval.scm" . 267285))
     (apply.gloc.of |call-with-port`4| "./boot/eval.scm" . 264207))
   (apply.gloc.of |call-with-port`4| "./boot/eval.scm" . 261129))
 (set.gloc.of |make-cache`4|)
 (close
   (2 0 . call-with-port)
   (push.gloc.of |.fn5.1`5|)
   (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (1 . 1) "./boot/eval.scm" . 257047))
   (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 258071))
   (apply.gloc.of dynamic-wind "./boot/eval.scm" . 254987))
 (set.gloc.of |call-with-port`4|)
 (close
   (2 0 . locate-cache)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 310288))
   (if.false.ret)
   (push.const . "~a/~a.cache")
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 311352))
   (push)
   (call
     (touch.gloc.of symbol-list->string)
     (push.iloc.0 . 0)
     (push.const . ".")
     (apply.gloc.of symbol-list->string "./boot/eval.scm" . 311373))
   (push)
   (push.subr.gloc.of format 3 "./boot/eval.scm" . 311330)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 312343)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . ".time")
     (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 313389)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 314398)
     (if.false.ret)
     (touch.gloc.of |call-with-port`4|)
     (call
       (touch.gloc.of make-file-input-port)
       (push.iloc.0 . 0)
       (apply.gloc.of make-file-input-port "./boot/eval.scm" . 316450))
     (push)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 318500)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 319524)
       (push.iloc 3 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 320575)
       (subr.gloc.of equal? 2 "./boot/eval.scm" . 320555)
       (if.true (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 322603)
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/eval.scm" . 323627))
       (ret.const . #f))
     (apply.gloc.of |call-with-port`4| "./boot/eval.scm" . 314393))
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of |locate-cache`4|)
 (close (0 0) (ret.const . #f))
 (set.gloc.of |.fn5.1`5|)
 (close
   (1 1 . load-scheme-library)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #t)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of car "./boot/eval.scm" . 250922))
   (push)
   (extend . 1)
   (extend.enclose
     (1 0 . locate-source)
     (call
       (touch.gloc.of symbol-list->string)
       (push.iloc.0 . 0)
       (push.const . "/")
       (apply.gloc.of symbol-list->string "./boot/eval.scm" . 300055))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.const . "~a/~a.scm")
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of format 3 "./boot/eval.scm" . 302123)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 303136)
         (if.false.ret)
         (ret.iloc 0 . 0))
       (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 304151))
       (push)
       (apply.gloc.of any1 "./boot/eval.scm" . 301073))
     (if.true.ret)
     (iloc 3 . 0)
     (if.false.ret)
     (push.const . load-scheme-library)
     (push.const . "~s not found in scheme-library-paths: ~s.scm")
     (push.iloc.0 . 0)
     (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 306286))
     (push)
     (push.subr.gloc.of format 3 "./boot/eval.scm" . 306226)
     (apply.gloc.of error "./boot/eval.scm" . 306198))
   (call
     (push.iloc 2 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 327691)
     (if.true.ret)
     (push.const . "internal error in load-scheme-library: unrecognized argument: ~s")
     (push.iloc 2 . 0)
     (apply.gloc.of scheme-error "./boot/eval.scm" . 328715))
   (call (push.iloc 2 . 0) (apply.iloc (0 . 0) "./boot/eval.scm" . 330766))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 332823))
     (if.true
       (call
         (touch.gloc.of |locate-cache`4|)
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |locate-cache`4| "./boot/eval.scm" . 333865))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of load-cache)
         (push.iloc.0 . 0)
         (apply.gloc.of load-cache "./boot/eval.scm" . 335901))
       (push.const . "~a/~a.cache")
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 336965))
       (push)
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc 4 . 0)
         (push.const . ".")
         (apply.gloc.of symbol-list->string "./boot/eval.scm" . 336986))
       (push)
       (push.subr.gloc.of format 3 "./boot/eval.scm" . 336943)
       (extend . 1)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 337956))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; compile ~s~%~!")
         (push.iloc 2 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 337979))
       (call
         (touch.gloc.of |make-cache`4|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 5 . 0)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 2 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 339014))
         (push)
         (apply.gloc.of |make-cache`4| "./boot/eval.scm" . 338975))
       (touch.gloc.of |call-with-port`4|)
       (call
         (touch.gloc.of make-file-output-port)
         (push.iloc.0 . 0)
         (push.const . ".time")
         (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 340021)
         (apply.gloc.of make-file-output-port "./boot/eval.scm" . 342053))
       (push)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.const . "~s ~s ~s")
         (subr.gloc.of microsecond 0)
         (push)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 3 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 343134))
         (push)
         (push.iloc 3 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 343094))
       (apply.gloc.of |call-with-port`4| "./boot/eval.scm" . 341025))
     (push.iloc.0 . 0)
     (apply.gloc.of load "./boot/eval.scm" . 344087))
   (ret.const.unspec))
 (set.gloc.of load-scheme-library)
 (ret.const.unspec))

;
((close
   (1 0 . add-load-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 7180)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 8208)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 9244))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 10275))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 10262)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 11316))
       (push.cons)
       (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 11286))
     (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 12300))
   (push.const . add-load-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 14384)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 14348))
 (set.gloc.of add-load-path)
 (ret.const.unspec))
((close
   (1 0 . add-library-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 18444)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 19472)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 20508))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 21539))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 21526)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 22583))
       (push.cons)
       (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 22550))
     (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 23564))
   (push.const . add-library-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 25651)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 25612))
 (set.gloc.of add-library-path)
 (ret.const.unspec))
((close
   (0 0 . home-directory)
   (push.const . "~/")
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 31783)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 31766)
     (if.true
       (call
         (push.const . "HOMEDRIVE")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 32809)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (call
         (push.const . "HOMEPATH")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 33833)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (ret.subr.gloc.of string-append "./boot/interaction.scm" . 32790))
     (push.const . "HOME")
     (ret.subr.gloc.of lookup-process-environment "./boot/interaction.scm" . 34838))
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 29713)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/interaction.scm" . 35852)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of home-directory)
 (ret.const.unspec))
((close
   (1 1 . apply-scheme-proc-assistant)
   (push.const . #t)
   (extend . 1)
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.true.ret)
     (push.const . apply-scheme-proc-assistant)
     (push.const . "scheme continuation interleave with c/c++ continuation")
     (apply.gloc.of assertion-violation "./boot/interaction.scm" . 43028))
   (push.close
     (0 0)
     (call
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of apply "./boot/interaction.scm" . 45077))
     (push)
     (extend . 1)
     (const . #f)
     (set.iloc 2 . 0)
     (ret.iloc 0 . 0))
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.false.ret)
     (touch.gloc.of escape)
     (apply.gloc.of escape "./boot/interaction.scm" . 48149))
   (apply.gloc.of dynamic-wind "./boot/interaction.scm" . 40967))
 (set.gloc.of apply-scheme-proc-assistant)
 (ret.const.unspec))
((close
   (0 0 . nonblock-skip-whitespace)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of nonblock-byte-ready? 1 "./boot/interaction.scm" . 52234)
   (if.false.ret)
   (call
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of lookahead-char 1 "./boot/interaction.scm" . 53268)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 54294)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of char-whitespace? "./boot/interaction.scm" . 55313))
   (if.false.ret)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of get-char 1 "./boot/interaction.scm" . 56330)
   (if.false.ret)
   (touch.gloc.of nonblock-skip-whitespace)
   (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 57354))
 (set.gloc.of nonblock-skip-whitespace)
 (ret.const.unspec))
((close
   (0 0 . read-eval-print-loop)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 61464)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 61511)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 61506)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 61501))
   (push)
   (extend . 1)
   (extend.enclose
     (0 0 . loop)
     (call
       (push.close
         (1 0)
         (push.close
           (1 0)
           (subr.gloc.of current-output-port 0)
           (push)
           (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 67599)
           (touch.gloc.of default-exception-handler)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 68623))
         (push.close
           (0 0)
           (call
             (touch.gloc.of nonblock-skip-whitespace)
             (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 70671))
           (call
             (subr.gloc.of current-environment 0)
             (push)
             (subr.gloc.of interaction-environment 0 "./boot/interaction.scm" . 71726)
             (if.eq?
               (push.const . #t)
               (push.const . "~&> ~!")
               (ret.subr.gloc.of format "./boot/interaction.scm" . 72723))
             (push.const . #t)
             (push.const . "~&~a: ~!")
             (subr.gloc.of current-environment 0)
             (push)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 73747))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 74767))
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 75791)
           (call
             (touch.gloc.of set-port-current-line!)
             (subr.gloc.of current-input-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-line! "./boot/interaction.scm" . 76815))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-output-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 77839))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-error-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 78863))
           (subr.gloc.of current-input-port 0)
           (push)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . read)
           (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 79899)
           (extend . 1)
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 80918)
             (if.false.ret)
             (push.const . 0)
             (ret.subr.gloc.of exit "./boot/interaction.scm" . 80937))
           (call
             (iloc 5 . 0)
             (if.false.ret)
             (push.const . #t)
             (push.const . "~%~!")
             (ret.subr.gloc.of format "./boot/interaction.scm" . 81950))
           (call
             (touch.gloc.of interpret)
             (push.iloc.0 . 0)
             (apply.gloc.of interpret "./boot/interaction.scm" . 82972))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of unspecified? 1 "./boot/interaction.scm" . 83994)
           (if.true.ret)
           (call (push.iloc.0 . 0) (apply.gloc.of pretty-print "./boot/interaction.scm" . 86042))
           (subr.gloc.of current-output-port 0)
           (push)
           (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 87066))
         (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 65548))
       (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 63497))
     (apply.iloc (1 . 0) "./boot/interaction.scm" . 88073))
   (apply.iloc (0 . 0) "./boot/interaction.scm" . 62471))
 (set.gloc.of read-eval-print-loop)
 (ret.const.unspec))
((close
   (0 0)
   (call
     (touch.gloc.of nonblock-skip-whitespace)
     (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 100365))
   (call
     (touch.gloc.of current-macro-expression)
     (push.const . #f)
     (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 101389))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 102413)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.const . read)
   (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 103449)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 104470)
   (if.true (push.const . 0) (ret.subr.gloc.of exit "./boot/interaction.scm" . 104489))
   (call
     (touch.gloc.of interpret)
     (push.iloc.0 . 0)
     (apply.gloc.of interpret "./boot/interaction.scm" . 106518))
   (subr.gloc.of current-output-port 0)
   (push)
   (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 107542))
 (set.gloc.of |.fn6.1`6|)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 98357))
 (set.gloc.of |.fn3.1`3|)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 97293)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of |.fn3.1`3|)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 98317))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0)
   (push.gloc.of |.fn2.1`2|)
   (push.gloc.of |.fn6.1`6|)
   (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 94216))
 (set.gloc.of |.fn4.1`4|)
 (close
   (0 0 . loop)
   (call
     (push.gloc.of |.fn4.1`4|)
     (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 92165))
   (touch.gloc.of |loop`4|)
   (apply.gloc.of |loop`4| "./boot/interaction.scm" . 108551))
 (set.gloc.of |loop`4|)
 (close
   (0 0 . quiet-read-eval-print-loop)
   (touch.gloc.of |loop`4|)
   (apply.gloc.of |loop`4| "./boot/interaction.scm" . 92165))
 (set.gloc.of quiet-read-eval-print-loop)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/interaction.scm" . 145436)
       (apply.gloc.of |loop`7| "./boot/interaction.scm" . 145430))
     (push)
     (call
       (touch.gloc.of |loop`7|)
       (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 145453)
       (apply.gloc.of |loop`7| "./boot/interaction.scm" . 145447))
     (ret.cons "./boot/interaction.scm" . 145424))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.const
       (|.LIST| . |.list|)
       (|.CONS| . |.cons|)
       (|.CONS*| . |.cons*|)
       (|.APPEND| . |.append|)
       (|.VECTOR| . |.vector|)
       (|.LIST->VECTOR| . |.list->vector|)
       (|.EQ?| . |.eq?|)
       (|.EQV?| . |.eqv?|)
       (|.MEMQ| . |.memq|)
       (|.MEMV| . |.memv|)
       (|.CALL-WITH-VALUES| . |.call-with-values|)
       (|.APPLY| . |.apply|)
       (|.CDR| . |.cdr|)
       (|.IDENTIFIER?| . |.identifier?|)
       (|.MAKE-VARIABLE-TRANSFORMER| . |.make-variable-transformer|)
       (|.ASSERTION-VIOLATION| . |.assertion-violation|)
       (|.UNSPECIFIED| . |.unspecified|)
       (|.QUOTE| . quote)
       (|.LET| . let)
       (|.LETREC*| . letrec*)
       (|.BEGIN| . begin)
       (|.LAMBDA| . lambda)
       (|.IF| . if)
       (|.SET!| . set!)
       (|.OR| . or)
       (|.COND| . cond)
       (|.ELSE| . else)
       (|.DEFINE-SYNTAX| . define-syntax)
       (|.SYNTAX| . syntax)
       (|.SYNTAX-CASE| . syntax-case))
     (push.subr.gloc.of assq 2 "./boot/interaction.scm" . 147479)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/interaction.scm" . 147472))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/interaction.scm" . 149520)
   (if.true
     (call
       (push.gloc.of |loop`7|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/interaction.scm" . 150568)
       (apply.gloc.of map "./boot/interaction.scm" . 150558))
     (push)
     (apply.gloc.of list->vector "./boot/interaction.scm" . 150544))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . unrename-private-primitives)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`7| "./boot/interaction.scm" . 143367))
 (set.gloc.of |.fn1.2`1|)
 (gloc.of |.fn1.2`1|)
 (set.gloc.of unrename-private-primitives)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . "~r")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 178248))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . default-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/interaction.scm" . 155653))
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 1)
   (call
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of backtrace-line-length 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (call (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 161801))
       (set.iloc 1 . 0)
       (call (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 161801))
       (set.iloc 1 . 1)
       (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 161801))
       (set.iloc 1 . 2)
       (call
         (push.iloc.1 . 3)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 161801))
       (call
         (push.const . 10)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 161801))
       (push.const . #t)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 161801))
     (push.close
       (0 0)
       (extend.unbound . 3)
       (push.close
         (0 0 . output-who-message)
         (push.iloc 4 . 0)
         (push.const . "error")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 163853)
         (call
           (call (push.iloc 5 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 164882))
           (if.false.ret)
           (push.iloc 4 . 0)
           (push.const . " in ~u")
           (call (push.iloc 5 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 165928))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 165906))
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of message-condition? "./boot/interaction.scm" . 166930))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . ": ~a")
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of condition-message "./boot/interaction.scm" . 167974))
         (push)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 167954))
       (push.close
         (0 0 . output-irritants)
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of irritants-condition? "./boot/interaction.scm" . 172052))
         (if.true
           (push.iloc 4 . 0)
           (push.const . "~%~%irritants:")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 173076)
           (push.close
             (1 0)
             (push.iloc 5 . 0)
             (push.const . "~% ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 175136)
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/interaction.scm" . 176167)
             (if.true
               (push.iloc 5 . 0)
               (push.const . " (")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 177191)
               (extend.enclose+
                 (1 0 . loop)
                 (iloc.0 . 0)
                 (if.pair?
                   (push.iloc 7 . 0)
                   (push.const . "~a")
                   (push.car.iloc (0 . 0) "./boot/interaction.scm" . 180290)
                   (subr.gloc.of format 3 "./boot/interaction.scm" . 180272)
                   (cdr.iloc (0 . 0) "./boot/interaction.scm" . 181310)
                   (if.pair?
                     (push.iloc 7 . 0)
                     (push.const . " ")
                     (subr.gloc.of format 2 "./boot/interaction.scm" . 182327)
                     (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 183357)
                     (apply.iloc+ (1 . 0) "./boot/interaction.scm" . 183351))
                   (push.iloc 7 . 0)
                   (push.const . ")")
                   (ret.subr.gloc.of format "./boot/interaction.scm" . 185399))
                 (ret.const.unspec))
               (call
                 (push.gloc.of |.fn1.1`1|)
                 (push.iloc.1 . 0)
                 (apply.gloc.of map "./boot/interaction.scm" . 178231))
               (push)
               (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 178215))
             (push.iloc 5 . 0)
             (push.const . " ~r")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 186412))
           (call
             (touch.gloc.of condition-irritants)
             (push.iloc 5 . 0)
             (apply.gloc.of condition-irritants "./boot/interaction.scm" . 187422))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 172045))
         (ret.const.unspec))
       (push.close+
         (0 0 . output-expansion)
         (call (apply.gloc.of expansion-backtrace "./boot/interaction.scm" . 191506))
         (if.false.ret)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 192530))
         (if.false.ret)
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 194580))
           (set.iloc 1 . 0)
           (push.const . 7)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 194580))
         (push.close
           (0 0)
           (push.iloc 6 . 0)
           (push.const . "~%~%expanding:~%  >  ")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 194580)
           (call
             (call
               (touch.gloc.of unrename-private-primitives)
               (call
                 (touch.gloc.of current-macro-expression)
                 (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 195647))
               (push)
               (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 195618))
             (push)
             (push.iloc 6 . 0)
             (apply.gloc.of pretty-print "./boot/interaction.scm" . 195604))
           (push.iloc 6 . 0)
           (push.const . "~%  ~n")
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 196650))
           (push)
           (subr.gloc.of format 3 "./boot/interaction.scm" . 196628)
           (push.close
             (1 0)
             (push.iloc 7 . 0)
             (push.const . "~%  *  ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 198688)
             (call
               (call
                 (touch.gloc.of unrename-private-primitives)
                 (push.iloc.0 . 0)
                 (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 199726))
               (push)
               (push.iloc 7 . 0)
               (apply.gloc.of pretty-print "./boot/interaction.scm" . 199712))
             (push.iloc 7 . 0)
             (push.const . "~%  ~n")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 200736))
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 201758))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 197652))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 194580))
         (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 194580))
       (enclose . 3)
       (call
         (push.iloc 4 . 0)
         (apply.gloc.of undefined-violation? "./boot/interaction.scm" . 203792))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unbound variable")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 204816)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 205845))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " ~s")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 206888))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 206869))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 207893))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ", ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 208937))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 208917))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 209936))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 210960))
       (call (push.iloc 4 . 0) (apply.gloc.of syntax-violation? "./boot/interaction.scm" . 213008))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 214032))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 215063))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 218142))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 218142))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  >  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 218142)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 219180))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 219166))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 220208))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 218142))
             (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 218142))
           (ret.const.unspec))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 221207))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 224286))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 224286))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  @  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 224286)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 225324))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 225310))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 226352))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 224286))
             (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 224286))
           (ret.const.unspec))
         (call
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 227360))
           (if.not.null?.ret.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 228386))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 228413))
           (if.eq?.ret.const . #t)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 229410))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 229437))
           (ret.eq? "./boot/interaction.scm" . 229405))
         (if.true.ret)
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 230420))
       (call (push.iloc 4 . 0) (apply.gloc.of error? "./boot/interaction.scm" . 232464))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 233488))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 234512))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 235536))
       (call (push.iloc 4 . 0) (apply.gloc.of violation? "./boot/interaction.scm" . 237584))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 238608))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 239632))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 240656))
       (call (push.iloc 4 . 0) (apply.gloc.of condition? "./boot/interaction.scm" . 242704))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unknown exception caught~%~%irritants:~%~a")
         (call
           (touch.gloc.of describe-condition)
           (push.const . #f)
           (push.iloc 4 . 0)
           (apply.gloc.of describe-condition "./boot/interaction.scm" . 243793))
         (push)
         (subr.gloc.of format 3 "./boot/interaction.scm" . 243728)
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 244752))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 245776))
       (push.iloc 3 . 0)
       (push.const . "error: unknown exception caught, ~a")
       (push.iloc 4 . 0)
       (subr.gloc.of format 3 "./boot/interaction.scm" . 248848)
       (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 249872))
       (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 250896))
     (push.close
       (0 0)
       (call
         (push.iloc.1 . 0)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 161801))
       (call
         (push.iloc.1 . 1)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 161801))
       (push.iloc.1 . 2)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 161801))
     (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 157744))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 252935)
   (push.iloc.0 . 0)
   (subr.gloc.of display-backtrace 1 "./boot/interaction.scm" . 253959)
   (call
     (call
       (push.const . "EMACS")
       (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 256026)
       (if.true.ret)
       (subr.gloc.of current-input-port 0)
       (push)
       (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 256073)
       (push.const . char)
       (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 256068)
       (ret.subr.gloc.of not "./boot/interaction.scm" . 256063))
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~a~!")
       (push.iloc.0 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 258097)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 258061))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~%~a~%~!")
     (push.iloc.0 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 259125)
     (ret.subr.gloc.of format "./boot/interaction.scm" . 259085))
   (push.const . 10000)
   (subr.gloc.of usleep 1 "./boot/interaction.scm" . 260105)
   (iloc.1 . 1)
   (if.false.ret)
   (apply.iloc (1 . 1) "./boot/interaction.scm" . 261143))
 (set.gloc.of default-exception-handler)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 319538))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 319519))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 320558))
     (push)
     (apply.gloc.of add-load-path "./boot/interaction.scm" . 320543))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_LOADPATH': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 322591))
 (set.gloc.of |.fn12.1`12|)
 (close
   (0 0 . init-env-sitelib)
   (push.const . "YPSILON_SITELIB")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 301072)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn17.1`17|)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 309300)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 309283)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 310307))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 311331))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 309270)
     (apply.gloc.of for-each "./boot/interaction.scm" . 301065))
   (ret.const.unspec))
 (set.gloc.of |init-env-sitelib`2|)
 (close
   (1 0 . directory-exists?)
   (push.const . "~a/.")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 268311)
   (ret.subr.gloc.of file-exists? "./boot/interaction.scm" . 268297))
 (set.gloc.of |directory-exists?`2|)
 (close
   (0 0 . show-info)
   (call
     (touch.gloc.of |show-banner`2|)
     (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 392201))
   (call
     (push.const . "YPSILON_ACC")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 393232)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_ACC=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 394274))
     (push.const . #t)
     (push.const . ";; YPSILON_ACC unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 395285))
   (call
     (push.const . "YPSILON_SITELIB")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 396304)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_SITELIB=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 397346))
     (push.const . #t)
     (push.const . ";; YPSILON_SITELIB unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 398357))
   (call
     (push.const . "YPSILON_LOADPATH")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 399376)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_LOADPATH=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 400418))
     (push.const . #t)
     (push.const . ";; YPSILON_LOADPATH unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 401429))
   (push.const . #t)
   (push.const . ";; (auto-compile-cache) => ~s~%")
   (call (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 402486))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 402441)
   (push.const . #t)
   (push.const . ";; (scheme-library-paths) => ~s~%")
   (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 403512))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 403465)
   (push.const . #t)
   (push.const . ";; (scheme-load-paths) => ~s~%")
   (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 404533))
   (push)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 404489))
 (set.gloc.of |show-info`2|)
 (close
   (0 0 . init-env-acc)
   (push.const . "YPSILON_ACC")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 290832)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 292911))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 292892))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 293936))
       (push)
       (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 293916))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in environment variable 'YPSILON_ACC': directory ~s not exist~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/interaction.scm" . 295964)
     (push.const . #f)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 296988))
   (ret.const.unspec))
 (set.gloc.of |init-env-acc`2|)
 (close
   (1 0)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 305202))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 305183))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 306225))
     (push)
     (apply.gloc.of add-library-path "./boot/interaction.scm" . 306207))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_SITELIB': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 308255))
 (set.gloc.of |.fn17.1`17|)
 (close
   (0 0 . show-usage)
   (push.const . #t)
   (push.const . "usage: ypsilon [options] [--] [file] [arguments]~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 368649)
   (push.const . #t)
   (push.const . "options:~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 369673)
   (push.const . #t)
   (push.const . "  --mute (-m)            suppresses greeting~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 370697)
   (push.const . #t)
   (push.const . "  --quiet (-q)           suppresses greeting, repl prompt, and repl output~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 371721)
   (push.const . #t)
   (push.const . "  --verbose (-v)         prints load and compile activities~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 372745)
   (push.const . #t)
   (push.const . "  --interactive (-i)     enters repl after running the script file~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 373769)
   (push.const . #t)
   (push.const . "  --r6rs (-6)            conforms r6rs lexical syntax (default)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 374793)
   (push.const . #t)
   (push.const . "  --compatible (-c)      extends lexical syntax for compatibility~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 375817)
   (push.const . #t)
   (push.const . "  --sitelib=path         adds sitelib path (YPSILON_SITELIB)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 376841)
   (push.const . #t)
   (push.const . "  --loadpath=path        adds load search path (YPSILON_LOADPATH)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 377865)
   (push.const . #t)
   (push.const . "  --acc=dir              sets a auto-compile-cache directory (YPSILON_ACC)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 378889)
   (push.const . #t)
   (push.const . "  --disable-acc          disables auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 379913)
   (push.const . #t)
   (push.const . "  --clean-acc            cleans auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 380937)
   (push.const . #t)
   (push.const . "  --version              prints version and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 381961)
   (push.const . #t)
   (push.const . "  --help                 prints help and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 382985)
   (push.const . #t)
   (push.const . "  --                     indicates no more option to proceed~%")
   (ret.subr.gloc.of format "./boot/interaction.scm" . 384009))
 (set.gloc.of |show-usage`2|)
 (close
   (0 0 . init-sys-sitelib)
   (push.const . "~a/sitelib")
   (subr.gloc.of system-share-path 0)
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 272405)
   (extend . 1)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 273424))
   (if.false.ret)
   (push.iloc.0 . 0)
   (apply.gloc.of add-library-path "./boot/interaction.scm" . 273449))
 (set.gloc.of |init-sys-sitelib`2|)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 421949))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . add-opt-sitelib)
   (push.close
     (1 0)
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 330799))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 330780))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 331822))
       (push)
       (apply.gloc.of add-library-path "./boot/interaction.scm" . 331804))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '-sitelib=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 333852)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 334876))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 335921)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 335904)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 336928))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 337952))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 335891)
   (apply.gloc.of for-each "./boot/interaction.scm" . 328711))
 (set.gloc.of |add-opt-sitelib`2|)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 420885)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of |.fn2.1`2|)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 421909))
 (set.gloc.of |.fn13.1`13|)
 (close
   (1 0 . add-opt-loadpath)
   (push.close
     (1 0)
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 343087))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 343068))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 344107))
       (push)
       (apply.gloc.of add-load-path "./boot/interaction.scm" . 344092))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '-loadpath=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 346140)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 347164))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 348209)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 348192)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 349216))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 350240))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 348179)
   (apply.gloc.of for-each "./boot/interaction.scm" . 340999))
 (set.gloc.of |add-opt-loadpath`2|)
 (close
   (0 0 . show-banner)
   (subr.gloc.of current-output-port 0)
   (push)
   (push.const . "Ypsilon 0.9.5 Copyright (c) 2008 Y.Fujita, LittleWing Company Limited.\n")
   (ret.subr.gloc.of put-string "./boot/interaction.scm" . 388105))
 (set.gloc.of |show-banner`2|)
 (close
   (0 0 . init-env-loadpath)
   (push.const . "YPSILON_LOADPATH")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 315408)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn12.1`12|)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 323636)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 323619)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 324643))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 325667))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 323606)
     (apply.gloc.of for-each "./boot/interaction.scm" . 315401))
   (ret.const.unspec))
 (set.gloc.of |init-env-loadpath`2|)
 (close
   (0 0 . init-sys-acc)
   (push.const . operating-system)
   (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 277537)
   (push.const . "windows")
   (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 277520)
   (if.true
     (push.const . "TEMP")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 278551)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of |directory-exists?`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 280611))
       (if.true
         (call
           (call
             (touch.gloc.of |directory-exists?`2|)
             (push.const . "~//Ypsilon")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/interaction.scm" . 281658)
             (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 281639))
           (if.true.ret)
           (push.const . "~//Ypsilon")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/interaction.scm" . 282681)
           (ret.subr.gloc.of create-directory "./boot/interaction.scm" . 282663))
         (push.const . "~//Ypsilon")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/interaction.scm" . 283703)
         (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 283683))
       (ret.const.unspec))
     (ret.const.unspec))
   (call
     (touch.gloc.of |directory-exists?`2|)
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 285760))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 285738)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 285719))
   (if.true
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 286785))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 286763)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 286743))
   (ret.const.unspec))
 (set.gloc.of |init-sys-acc`2|)
 (close
   (1 0 . bad-option)
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '~a'~%")
   (push.iloc.0 . 0)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 362505)
   (call
     (touch.gloc.of |show-usage`2|)
     (apply.gloc.of |show-usage`2| "./boot/interaction.scm" . 363529))
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 364553))
 (set.gloc.of |bad-option`2|)
 (close
   (1 0 . set-opt-acc)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 354339))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 354320))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 355364))
     (push)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 355344))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '-acc=~a': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of format 4 "./boot/interaction.scm" . 357392)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 358416))
 (set.gloc.of |set-opt-acc`2|)
 (close
   (0 0 . start-scheme-session)
   (extend.unbound . 8)
   (push.close
     (1 0 . exec-script)
     (subr.gloc.of command-line 0)
     (push)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 408608)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 408632)
     (push.subr.gloc.of - 2 "./boot/interaction.scm" . 408605)
     (subr.gloc.of command-line-shift 1 "./boot/interaction.scm" . 408585)
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 409621)
     (extend . 1)
     (iloc 2 . 4)
     (if.true
       (push.close
         (1 0)
         (subr.gloc.of current-output-port 0)
         (push)
         (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 413717)
         (touch.gloc.of default-exception-handler)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 414741))
       (push.close (0 0) (push.iloc.1 . 0) (apply.gloc.of load "./boot/interaction.scm" . 416789))
       (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 411666))
     (push.gloc.of |.fn13.1`13|)
     (push.close
       (0 0)
       (call (push.iloc.1 . 0) (apply.gloc.of load "./boot/interaction.scm" . 423957))
       (subr.gloc.of current-error-port 0)
       (push)
       (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 424981)
       (subr.gloc.of current-output-port 0)
       (push)
       (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 426005))
     (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 418834))
   (push.close
     (0 0 . exec-repl)
     (call
       (iloc.1 . 6)
       (if.true.ret)
       (iloc.1 . 2)
       (if.true
         (touch.gloc.of |show-info`2|)
         (apply.gloc.of |show-info`2| "./boot/interaction.scm" . 431128))
       (touch.gloc.of |show-banner`2|)
       (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 432149))
     (call
       (iloc.1 . 5)
       (if.true.ret)
       (touch.gloc.of interpret)
       (push.const import (core) (rnrs))
       (apply.gloc.of interpret "./boot/interaction.scm" . 433172))
     (iloc.1 . 3)
     (if.true
       (touch.gloc.of quiet-read-eval-print-loop)
       (apply.gloc.of quiet-read-eval-print-loop "./boot/interaction.scm" . 435213))
     (touch.gloc.of read-eval-print-loop)
     (apply.gloc.of read-eval-print-loop "./boot/interaction.scm" . 436237))
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (enclose . 7)
   (subr.gloc.of command-line 0 "./boot/interaction.scm" . 443426)
   (set.iloc 0 . 7)
   (call
     (touch.gloc.of |init-sys-acc`2|)
     (apply.gloc.of |init-sys-acc`2| "./boot/interaction.scm" . 445445))
   (call
     (touch.gloc.of |init-env-acc`2|)
     (apply.gloc.of |init-env-acc`2| "./boot/interaction.scm" . 446469))
   (call
     (touch.gloc.of |init-sys-sitelib`2|)
     (apply.gloc.of |init-sys-sitelib`2| "./boot/interaction.scm" . 447493))
   (call
     (touch.gloc.of |init-env-sitelib`2|)
     (apply.gloc.of |init-env-sitelib`2| "./boot/interaction.scm" . 448517))
   (call
     (touch.gloc.of |init-env-loadpath`2|)
     (apply.gloc.of |init-env-loadpath`2| "./boot/interaction.scm" . 449541))
   (iloc.0 . 7)
   (if.not.pair?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 4)
       (if.true (apply.iloc (2 . 1) "./boot/interaction.scm" . 456729))
       (iloc 2 . 5)
       (if.true.ret)
       (apply.iloc (2 . 1) "./boot/interaction.scm" . 457764))
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 459808)
     (extend . 1)
     (extend.enclose
       (2 0 . opt?)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of string-contains 2 "./boot/interaction.scm" . 463908)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (=n.iloc (0 . 0) 0 "./boot/interaction.scm" . 465961)
         (if.true
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (subr.gloc.of string=? 2 "./boot/interaction.scm" . 466980)
           (if.true.ret.const . "")
           (iloc.1 . 1)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 468038)
           (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 468022)
           (push.const . #\=)
           (subr.gloc.of char=? 2 "./boot/interaction.scm" . 468014)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 469046)
           (push.const . 1)
           (push.subr.gloc.of + 2 "./boot/interaction.scm" . 469043)
           (push.iloc 3 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 469070)
           (ret.subr.gloc.of substring "./boot/interaction.scm" . 469028))
         (ret.const . #f))
       (ret.const . #f))
     (call
       (push.const . "--version")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 472094))
     (if.true
       (call
         (touch.gloc.of |show-banner`2|)
         (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 473118))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 474142))
     (call
       (push.const . "--help")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 475166))
     (if.true
       (call
         (touch.gloc.of |show-usage`2|)
         (apply.gloc.of |show-usage`2| "./boot/interaction.scm" . 476190))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 477214))
     (call
       (call
         (push.const . "--compatible")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 478242))
       (if.true.ret)
       (push.const . "-c")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 478267))
     (if.true
       (push.const . #t)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 479262)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 480292)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 480286))
     (call
       (call
         (push.const . "--verbose")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 481314))
       (if.true.ret)
       (push.const . "-v")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 481336))
     (if.true
       (call
         (push.const . #t)
         (apply.gloc.of scheme-load-verbose "./boot/interaction.scm" . 482334))
       (call
         (push.const . #t)
         (apply.gloc.of auto-compile-verbose "./boot/interaction.scm" . 483358))
       (const . #t)
       (set.iloc 4 . 2)
       (const . #f)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 486436)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 486430))
     (call
       (call
         (push.const . "--mute")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 487458))
       (if.true.ret)
       (push.const . "-m")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 487477))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 490532)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 490526))
     (call
       (call
         (push.const . "--quiet")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 491554))
       (if.true.ret)
       (push.const . "-q")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 491574))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (const . #t)
       (set.iloc 4 . 3)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 495652)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 495646))
     (call
       (call
         (push.const . "--interactive")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 496674))
       (if.true.ret)
       (push.const . "-i")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 496700))
     (if.true
       (const . #t)
       (set.iloc 4 . 4)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 498724)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 498718))
     (call
       (push.const . "--acc")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 499742))
     (if.true
       (call
         (cdr.iloc (2 . 0) "./boot/interaction.scm" . 500777)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc.1 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 500788))
       (call
         (touch.gloc.of |set-opt-acc`2|)
         (push.cadr.iloc (2 . 0) "./boot/interaction.scm" . 501803)
         (apply.gloc.of |set-opt-acc`2| "./boot/interaction.scm" . 501790))
       (push.cddr.iloc (2 . 0) "./boot/interaction.scm" . 502820)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 502814))
     (call
       (push.const . "--acc")
       (push.const . #t)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 503838))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 505898)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 2 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 506922))
       (call
         (touch.gloc.of |set-opt-acc`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |set-opt-acc`2| "./boot/interaction.scm" . 508970))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 510000)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 509994))
     (call
       (push.const . "--disable-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 511006))
     (if.true
       (call (push.const . #f) (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 512030))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 513060)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 513054))
     (call
       (push.const . "--clean-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 514078))
     (if.true
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/interaction.scm" . 515102))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 516132)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 516126))
     (call
       (push.const . "--sitelib")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 517150))
     (if.true
       (call
         (cdr.iloc (3 . 0) "./boot/interaction.scm" . 518185)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc 2 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 518196))
       (call
         (touch.gloc.of |add-opt-sitelib`2|)
         (push.cadr.iloc (3 . 0) "./boot/interaction.scm" . 519215)
         (apply.gloc.of |add-opt-sitelib`2| "./boot/interaction.scm" . 519198))
       (push.cddr.iloc (3 . 0) "./boot/interaction.scm" . 520228)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 520222))
     (call
       (push.const . "--sitelib")
       (push.const . #t)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 521246))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 523306)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 3 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 524330))
       (call
         (touch.gloc.of |add-opt-sitelib`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |add-opt-sitelib`2| "./boot/interaction.scm" . 526378))
       (push.cdr.iloc (4 . 0) "./boot/interaction.scm" . 527408)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 527402))
     (call
       (push.const . "--loadpath")
       (push.const . #f)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 528414))
     (if.true
       (call
         (cdr.iloc (4 . 0) "./boot/interaction.scm" . 529449)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc 3 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 529460))
       (call
         (touch.gloc.of |add-opt-loadpath`2|)
         (push.cadr.iloc (4 . 0) "./boot/interaction.scm" . 530480)
         (apply.gloc.of |add-opt-loadpath`2| "./boot/interaction.scm" . 530462))
       (push.cddr.iloc (4 . 0) "./boot/interaction.scm" . 531492)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 531486))
     (call
       (push.const . "--loadpath")
       (push.const . #t)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 532510))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 534570)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 4 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 535594))
       (call
         (touch.gloc.of |add-opt-loadpath`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |add-opt-loadpath`2| "./boot/interaction.scm" . 537642))
       (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 538672)
       (apply.iloc+ (6 . 0) "./boot/interaction.scm" . 538666))
     (call
       (push.const . "--")
       (push.const . #f)
       (apply.iloc (3 . 0) "./boot/interaction.scm" . 539678))
     (if.true
       (const . #t)
       (set.iloc 7 . 5)
       (call
         (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 541739)
         (apply.iloc (7 . 0) "./boot/interaction.scm" . 541726))
       (iloc 7 . 4)
       (if.false.ret)
       (apply.iloc (7 . 1) "./boot/interaction.scm" . 542767))
     (push.iloc 4 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 543782)
     (push.const . #\-)
     (subr.gloc.of char=? 2 "./boot/interaction.scm" . 543774)
     (if.true
       (touch.gloc.of |bad-option`2|)
       (push.iloc 4 . 0)
       (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 544798))
     (const . #t)
     (set.iloc 7 . 5)
     (call (push.iloc 5 . 0) (apply.iloc (7 . 0) "./boot/interaction.scm" . 547870))
     (iloc 7 . 4)
     (if.false.ret)
     (apply.iloc (7 . 1) "./boot/interaction.scm" . 548911))
   (push.cdr.iloc (1 . 7) "./boot/interaction.scm" . 453660)
   (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 453644))
 (set.gloc.of start-scheme-session)
 (ret.const.unspec))

;
((subr.gloc.of make-core-hashtable 0 "./boot/libraries.scm" . 5150)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))
((close
   (1 0 . core-primitive-name)
   (push.const . ".~a")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/libraries.scm" . 9275)
   (ret.subr.gloc.of string->symbol "./boot/libraries.scm" . 9259))
 (set.gloc.of |core-primitive-name`1|)
 (close
   (2 0 . setup-core-primitive-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 49169))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 49199))
   (push)
   (extend . 2)
   (call
     (push.gloc.of |core-primitive-name`1|)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 50200))
   (push)
   (extend . 1)
   (call
     (push.gloc.of |.fn9.1`9|)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 50185))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 56331)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn11.1`11|)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 58415))
     (push)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 59439)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 58407)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 57382))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 57355))
 (set.gloc.of |setup-core-primitive-macros`1|)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 17455)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 17431)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 18455))
 (set.gloc.of |.fn3.1`3|)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 38959)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 38935)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 39959))
 (set.gloc.of |.fn7.1`7|)
 (close
   (2 0 . setup-core-primitive-procs)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 35857))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 35887))
   (push)
   (extend . 2)
   (call
     (push.gloc.of |core-primitive-name`1|)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 36888))
   (push)
   (extend . 1)
   (call
     (push.gloc.of |.fn7.1`7|)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 37899))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 41995)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn4.1`4|)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 44079))
     (push)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 45103)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 44071)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 43046))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 43019))
 (set.gloc.of |setup-core-primitive-procs`1|)
 (close
   (2 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 52254)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 54307))
   (ret.const.unspec))
 (set.gloc.of |.fn9.1`9|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 58442))
   (ret.cons "./boot/libraries.scm" . 58434))
 (set.gloc.of |.fn11.1`11|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 22602))
   (ret.cons "./boot/libraries.scm" . 22594))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 44106))
   (ret.cons "./boot/libraries.scm" . 44098))
 (set.gloc.of |.fn4.1`4|)
 (close
   (2 0 . setup-intrinsic-procs)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 1)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 13319)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 14353))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 14383))
   (push)
   (extend . 2)
   (call
     (push.gloc.of |core-primitive-name`1|)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 15384))
   (push)
   (extend . 1)
   (call
     (push.gloc.of |.fn3.1`3|)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 16395))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 20491)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 22575))
     (push)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 23599)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 22567)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 21542))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 21515))
 (set.gloc.of |setup-intrinsic-procs`1|)
 (close
   (2 0 . compound-exports)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 63505))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 63535))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 64556)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.1 . 1)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 63571))
   (push)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 65580)
   (push.subr.gloc.of append 2 "./boot/libraries.scm" . 64548)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 64521))
 (set.gloc.of |compound-exports`1|)
 (close
   (2 0 . setup-intrinsic-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 27665))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 27695))
   (push)
   (extend . 2)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 28681)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn2.1`2|)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 30765))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 31789)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 30757)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 29732))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 29705))
 (set.gloc.of |setup-intrinsic-macros`1|)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 30790))
   (ret.cons "./boot/libraries.scm" . 30782))
 (set.gloc.of |.fn2.1`2|)
 (call
   (touch.gloc.of |setup-intrinsic-macros`1|)
   (push.const core intrinsics)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (apply.gloc.of |setup-intrinsic-macros`1| "./boot/libraries.scm" . 67587))
 (call
   (touch.gloc.of |setup-intrinsic-procs`1|)
   (push.const core intrinsics)
   (push.const
     eq?
     eqv?
     equal?
     procedure?
     number?
     complex?
     real?
     rational?
     integer?
     real-valued?
     rational-valued?
     integer-valued?
     exact?
     inexact?
     inexact
     exact
     =
     <
     >
     <=
     >=
     zero?
     positive?
     negative?
     odd?
     even?
     finite?
     infinite?
     nan?
     max
     min
     +
     *
     -
     /
     abs
     div-and-mod
     div
     mod
     div0-and-mod0
     div0
     mod0
     gcd
     lcm
     numerator
     denominator
     floor
     ceiling
     truncate
     round
     rationalize
     exp
     log
     sin
     cos
     tan
     asin
     acos
     atan
     sqrt
     exact-integer-sqrt
     expt
     make-rectangular
     make-polar
     real-part
     imag-part
     magnitude
     angle
     number->string
     string->number
     not
     boolean?
     boolean=?
     pair?
     cons
     car
     cdr
     caar
     cadr
     cdar
     cddr
     caaar
     caadr
     cadar
     caddr
     cdaar
     cdadr
     cddar
     cdddr
     caaaar
     caaadr
     caadar
     caaddr
     cadaar
     cadadr
     caddar
     cadddr
     cdaaar
     cdaadr
     cdadar
     cdaddr
     cddaar
     cddadr
     cdddar
     cddddr
     null?
     list?
     list
     length
     append
     reverse
     list-tail
     list-ref
     map
     for-each
     symbol?
     symbol=?
     symbol->string
     string->symbol
     char?
     char->integer
     integer->char
     char=?
     char<?
     char>?
     char<=?
     char>=?
     string?
     make-string
     string
     string-length
     string-ref
     string=?
     string<?
     string>?
     string<=?
     string>=?
     substring
     string-append
     string->list
     list->string
     string-copy
     string-for-each
     vector?
     make-vector
     vector
     vector-length
     vector-ref
     vector-set!
     vector->list
     list->vector
     vector-fill!
     vector-map
     vector-for-each
     error
     assertion-violation
     apply
     call-with-current-continuation
     call/cc
     values
     call-with-values
     dynamic-wind)
   (apply.gloc.of |setup-intrinsic-procs`1| "./boot/libraries.scm" . 79875))
 (call
   (touch.gloc.of |setup-core-primitive-macros`1|)
   (push.const core primitives)
   (push.const do syntax-case syntax define-macro)
   (apply.gloc.of |setup-core-primitive-macros`1| "./boot/libraries.scm" . 125955))
 (call
   (touch.gloc.of |setup-core-primitive-procs`1|)
   (push.const core primitives)
   (push.const
     environment
     eval
     flonum?
     real->flonum
     fl=?
     fl<?
     fl>?
     fl<=?
     fl>=?
     flinteger?
     flzero?
     flpositive?
     flnegative?
     flodd?
     fleven?
     flfinite?
     flinfinite?
     flnan?
     flmax
     flmin
     fl+
     fl*
     fl-
     fl/
     fldiv
     fldiv0
     flnumerator
     fldenominator
     flfloor
     flceiling
     fltruncate
     flround
     flexp
     fllog
     flsin
     flcos
     fltan
     flasin
     flacos
     flatan
     flabs
     flsqrt
     fixnum->flonum
     fixnum?
     fixnum-width
     least-fixnum
     greatest-fixnum
     fx=?
     fx<?
     fx>?
     fx<=?
     fx>=?
     fxzero?
     fxpositive?
     fxnegative?
     fxodd?
     fxeven?
     fxmax
     fxmin
     fx+
     fx*
     fx-
     fxdiv
     fxdiv0
     fxnot
     fxand
     fxior
     fxxor
     fxif
     fxbit-count
     fxlength
     fxfirst-bit-set
     fxbit-set?
     fxcopy-bit
     fxarithmetic-shift
     fxarithmetic-shift-left
     fxarithmetic-shift-right
     fxbit-field
     fxcopy-bit-field
     bitwise-not
     bitwise-and
     bitwise-ior
     bitwise-xor
     bitwise-arithmetic-shift
     bitwise-first-bit-set
     bitwise-length
     bitwise-bit-count
     make-variable-transformer
     identifier?
     bound-identifier=?
     free-identifier=?
     datum->syntax
     syntax->datum
     generate-temporaries
     syntax-violation
     memq
     memv
     member
     assq
     assv
     assoc
     cons*
     list-head
     raise
     raise-continuable
     with-exception-handler
     record?
     record-rtd
     record-type-name
     record-type-parent
     record-type-uid
     record-type-generative?
     record-type-sealed?
     record-type-opaque?
     record-type-field-names
     record-field-mutable?
     make-record-type-descriptor
     record-type-descriptor?
     make-record-constructor-descriptor
     record-constructor
     record-predicate
     record-accessor
     record-mutator
     make-record-type
     record-type?
     record-type-rtd
     record-type-rcd
     condition
     simple-conditions
     condition?
     condition-predicate
     condition-accessor
     &condition
     &message
     make-message-condition
     message-condition?
     condition-message
     &warning
     make-warning
     warning?
     &serious
     make-serious-condition
     serious-condition?
     &error
     make-error
     error?
     &violation
     make-violation
     violation?
     &assertion
     make-assertion-violation
     assertion-violation?
     &irritants
     make-irritants-condition
     irritants-condition?
     &who
     make-who-condition
     who-condition?
     condition-who
     &non-continuable
     make-non-continuable-violation
     non-continuable-violation?
     &implementation-restriction
     make-implementation-restriction-violation
     implementation-restriction-violation?
     &lexical
     make-lexical-violation
     lexical-violation?
     &syntax
     make-syntax-violation
     syntax-violation?
     syntax-violation-form
     syntax-violation-subform
     &undefined
     make-undefined-violation
     undefined-violation?
     set-car!
     set-cdr!
     string-set!
     string-fill!
     quotient
     remainder
     modulo
     char-whitespace?
     display
     write
     newline
     read-char
     write-char
     eof-object
     eof-object?
     standard-input-port
     standard-output-port
     standard-error-port
     current-input-port
     current-output-port
     current-error-port
     input-port?
     output-port?
     port?
     flush-output-port
     output-port-buffer-mode
     close-port
     native-transcoder-descriptor
     port-transcoder-descriptor
     extract-accumulated-bytevector
     extract-accumulated-string
     get-accumulated-string
     open-port
     nonblock-byte-ready?
     lookahead-char
     get-char
     port-has-port-position?
     port-position
     port-has-set-port-position!?
     set-port-position!
     port-eof?
     get-u8
     lookahead-u8
     get-bytevector-n
     get-bytevector-n!
     get-bytevector-all
     get-bytevector-some
     get-string-n
     get-string-n!
     get-string-all
     get-line
     get-datum
     put-u8
     put-bytevector
     put-char
     put-string
     put-datum
     &i/o
     make-i/o-error
     i/o-error?
     &i/o-read
     make-i/o-read-error
     i/o-read-error?
     &i/o-write
     make-i/o-write-error
     i/o-write-error?
     &i/o-invalid-position
     make-i/o-invalid-position-error
     i/o-invalid-position-error?
     i/o-error-position
     &i/o-filename
     make-i/o-filename-error
     i/o-filename-error?
     i/o-error-filename
     &i/o-file-protection
     make-i/o-file-protection-error
     i/o-file-protection-error?
     &i/o-file-is-read-only
     make-i/o-file-is-read-only-error
     i/o-file-is-read-only-error?
     &i/o-file-already-exists
     make-i/o-file-already-exists-error
     i/o-file-already-exists-error?
     &i/o-file-does-not-exist
     make-i/o-file-does-not-exist-error
     i/o-file-does-not-exist-error?
     &i/o-port
     make-i/o-port-error
     i/o-port-error?
     i/o-error-port
     &i/o-decoding
     make-i/o-decoding-error
     i/o-decoding-error?
     &i/o-encoding
     make-i/o-encoding-error
     i/o-encoding-error?
     i/o-encoding-error-char
     file-exists?
     delete-file
     string-hash
     symbol-hash
     equal-hash
     command-line
     exit
     native-endianness
     bytevector?
     make-bytevector
     bytevector-length
     bytevector=?
     bytevector-fill!
     bytevector-copy!
     bytevector-copy
     bytevector-u8-ref
     bytevector-s8-ref
     bytevector-u8-set!
     bytevector-s8-set!
     bytevector->u8-list
     u8-list->bytevector
     bytevector-u16-ref
     bytevector-s16-ref
     bytevector-u16-native-ref
     bytevector-s16-native-ref
     bytevector-u16-set!
     bytevector-s16-set!
     bytevector-u16-native-set!
     bytevector-s16-native-set!
     bytevector-u32-ref
     bytevector-s32-ref
     bytevector-u32-native-ref
     bytevector-s32-native-ref
     bytevector-u32-set!
     bytevector-s32-set!
     bytevector-u32-native-set!
     bytevector-s32-native-set!
     bytevector-u64-ref
     bytevector-s64-ref
     bytevector-u64-native-ref
     bytevector-s64-native-ref
     bytevector-u64-set!
     bytevector-s64-set!
     bytevector-u64-native-set!
     bytevector-s64-native-set!
     bytevector-ieee-single-ref
     bytevector-ieee-single-native-ref
     bytevector-ieee-single-set!
     bytevector-ieee-single-native-set!
     bytevector-ieee-double-ref
     bytevector-ieee-double-native-ref
     bytevector-ieee-double-set!
     bytevector-ieee-double-native-set!
     string->utf8
     utf8->string
     put-fasl
     put-byte
     make-string-output-port
     make-string-input-port
     make-transcoded-port
     make-temporary-file-port
     port-device-subtype
     core-eval
     command-line-shift
     unspecified
     unspecified?
     generate-temporary-symbol
     list-transpose
     list-transpose+
     list-transpose*
     make-parameter
     gensym
     format
     pretty-print
     pretty-print-line-length
     pretty-print-initial-indent
     pretty-print-maximum-lines
     pretty-print-unwrap-syntax
     peek-char
     read
     write-with-shared-structure
     tuple
     tuple?
     make-tuple
     tuple-ref
     tuple-set!
     tuple-length
     tuple-index
     tuple->list
     make-weak-mapping
     weak-mapping?
     weak-mapping-key
     weak-mapping-value
     make-core-hashtable
     core-hashtable?
     make-weak-core-hashtable
     weak-core-hashtable?
     core-hashtable-contains?
     core-hashtable-ref
     core-hashtable-set!
     core-hashtable-delete!
     core-hashtable-clear!
     core-hashtable->alist
     core-hashtable-size
     core-hashtable-copy
     core-hashtable-mutable?
     core-hashtable-equivalence-function
     core-hashtable-hash-function
     usleep
     microsecond
     scheme-error
     architecture-feature
     load-shared-object
     lookup-shared-object
     call-shared-object->void
     call-shared-object->int
     call-shared-object->intptr
     call-shared-object->double
     stdcall-shared-object->void
     stdcall-shared-object->int
     stdcall-shared-object->intptr
     stdcall-shared-object->double
     make-callback
     flonum->float
     string->cstring
     cstring->string
     collect
     collect-notify
     collect-stack-notify
     collect-trip-bytes
     display-heap-statistics
     display-object-statistics
     backtrace
     expansion-backtrace
     backtrace-line-length
     display-backtrace
     restricted-print-line-length
     extend-lexical-syntax
     macro-expand
     compile
     compile-coreform
     closure-code
     current-environment
     current-macro-environment
     current-variable-environment
     current-dynamic-environment
     system-environment
     interaction-environment
     make-environment
     copy-environment-variables!
     copy-environment-macros!
     top-level-bound?
     top-level-value
     set-top-level-value!
     core-read
     current-source-comments
     current-after-expansion-hook
     string-contains
     subr?
     make-bytevector-mapping
     scheme-library-exports
     scheme-library-paths
     scheme-load-paths
     scheme-load-verbose
     add-load-path
     add-library-path
     auto-compile-verbose
     auto-compile-cache
     directory-list
     current-directory
     create-directory
     home-directory
     time-usage
     load
     system-share-path
     lookup-process-environment
     set-current-input-port!
     set-current-output-port!
     set-current-error-port!
     open-builtin-data-input-port)
   (apply.gloc.of |setup-core-primitive-procs`1| "./boot/libraries.scm" . 132099))
 (touch.gloc.of |compound-exports`1|)
 (push.const core primitives)
 (push.const core intrinsics)
 (apply.gloc.of |compound-exports`1| "./boot/libraries.scm" . 475139))
((gloc.of assertion-violation) (set.gloc.of |.@assertion-violation|) (ret.const.unspec))
((gloc.of undefined-violation) (set.gloc.of |.@undefined-violation|) (ret.const.unspec))
((gloc.of lexical-violation) (set.gloc.of |.@lexical-violation|) (ret.const.unspec))
((gloc.of error) (set.gloc.of |.@error|) (ret.const.unspec))
((gloc.of implementation-restriction-violation)
 (set.gloc.of |.@implementation-restriction-violation|)
 (ret.const.unspec))
((gloc.of raise-i/o-read-error) (set.gloc.of |.@raise-i/o-read-error|) (ret.const.unspec))
((gloc.of raise-i/o-write-error) (set.gloc.of |.@raise-i/o-write-error|) (ret.const.unspec))
((gloc.of raise-i/o-file-protection-error)
 (set.gloc.of |.@raise-i/o-file-protection-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-is-read-only-error)
 (set.gloc.of |.@raise-i/o-file-is-read-only-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-already-exists-error)
 (set.gloc.of |.@raise-i/o-file-already-exists-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-does-not-exist-error)
 (set.gloc.of |.@raise-i/o-file-does-not-exist-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-decoding-error) (set.gloc.of |.@raise-i/o-decoding-error|) (ret.const.unspec))
((gloc.of raise-i/o-encoding-error) (set.gloc.of |.@raise-i/o-encoding-error|) (ret.const.unspec))
((gloc.of raise-i/o-invalid-position-error)
 (set.gloc.of |.@raise-i/o-invalid-position-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-filename-error) (set.gloc.of |.@raise-i/o-filename-error|) (ret.const.unspec))
((gloc.of raise-i/o-error) (set.gloc.of |.@raise-i/o-error|) (ret.const.unspec))
((gloc.of perform-dynamic-wind) (set.gloc.of |.@perform-dynamic-wind|) (ret.const.unspec))
((gloc.of start-scheme-session) (set.gloc.of |.@start-scheme-session|) (ret.const.unspec))
((gloc.of apply-scheme-proc-assistant)
 (set.gloc.of |.@apply-scheme-proc-assistant|)
 (ret.const.unspec))
((gloc.of pretty-print) (set.gloc.of |.@pretty-print|) (ret.const.unspec))
((push.const . |.run-vmi|)
 (push.gloc.of run-vmi)
 (ret.subr.gloc.of set-top-level-value! "./boot/libraries.scm" . 500737))
((close
   (1 0)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 508953))
 (set.gloc.of |.fn1.1`1|)
 (push.const
   |.set-top-level-macro!|
   |.require-scheme-library|
   |.intern-scheme-library|
   |.unintern-scheme-library|
   |.patvars|
   |.syntax-dispatch|
   |.syntax-transcribe|
   |.flatten-syntax|
   |.transformer-thunk|
   |.run-vmi|)
 (extend . 1)
 (call
   (push.gloc.of |.fn1.1`1|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/libraries.scm" . 508931))
 (subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.iloc.0 . 0)
 (ret.subr.gloc.of copy-environment-variables! "./boot/libraries.scm" . 509955))
((subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.const import)
 (ret.subr.gloc.of copy-environment-macros! "./boot/libraries.scm" . 514049))
((push.gloc.of immutable-primitives)
 (push.const . #f)
 (subr.gloc.of core-hashtable-copy 2 "./boot/libraries.scm" . 515100)
 (touch.gloc.of immutable-primitives)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))

;
